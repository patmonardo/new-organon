The Language

Part 1 - The Language
Table of Contents

1.1
1.2
1.3

General Information .............. ~ ........................... 1-1
The M aclisp Language....... '.' ...................... '. ... . . . . .. 1-1
Structure of the Manual ...................................... 1-3
Notational Conventions ....................................... 1-4

2.

Data. Objects .............................. '.' ................. 1-7

3.
3.1
3.2
3.3

The Basic Actions of LISP .. ~ . . . . .. . . . . . . . . . . . . . ... . . . . . . . . . .. 1-11
Binding of Variables ................................. ;, ....... 1-11
Evaluation of Forms ............................ f • • • • • • • • • • • • 1-13
Application of Functions ..................................... 1-15
SpeCial Forms .............................................. 1-19
Binding Context Pointers...................................•. 1-22

I.

3.4

3.5

-I:)

,JilTAmUn ,'4 A ¢.

. Page 1-1

july 27, 1978

4,

a I@ $$It

m, ;:U===:=:WUUi;""MiMi,CWDM;';;,;A,4A4Nmu Al,ilMAmn;;,;g4\ MA@MIifI!(i5M.JliiAMi44lMilAWtiXMAiiWi&ldMl&&U&1&Mi&6iMiW&===MWGId

LEMIi. . ."AS.......2&C&Gll

o

o

General Information

1. General Information
1.1 The Maclisp Language
Mac1isp is a dialect of Lisp developed at M.I.T.'s Project MAC' and M.lT.'s
Artificial Intel1igence Laboratory for use in artificial intelligence research and related
fields. M ac1isp is descended from the commonly-known Lisp 1.5 dialect; however,. many
features of the language have been changed or augmented.

o

This document is intended both as a reference source for the language and as a
user's gUide to three implementations. These are, in chronological order, the M.I.T.
Artificial Intelligence Lab's implementation on the DEC pdp-lO computer under their
operating system ITS, hereafter referred to as "the ITS implementation,· Project M ACts
implementation on Honeywe1l's version of the Multics system, hereafter referred to as
"the Multics implementation," and the version that runs on the DEC pdp-tO under
DEC's TOPS-]O operating system, hereafter called "the DEC-tO implementation." The
DEc-to implementation also runs under TENEX by means of a TOPS-tO emulator.
Since the ITS and DEC-tO implementations are closely related, they are sometimes
referred to collectively as the pdp-tO implementation. There are reputed to be several
other implementations"
'
These implementations are mostly compatible; however, some implementations have
extra features designed to exploit peculiar features of the system on ,which they run, and
some implementations are temporarily missing some features. Most programs will work
on any implementation, although it is possible to write machine-dependent code If you try
hard enough.
The M ac1isp system is structured as an envtronment, which is essential1y a set of
names and bindings of those names to data structures and function definitions. The
environment contains a Ia.rge number of useful functions. These functions can be used
through an tnterpreter to define other functions, to contn)1 the environment, to do useful
work, etc.
The interpreter is the basic user interface to the system. This is how the user enters
"commands." When Mac1isp is not doing anything else, such as running a program, it
waits for the user to enter a Lisp form. This form is evaluated and the value is printed
out. The form may call upon one of the system functions (or a user-defined function, of
course) to perform some useful task. The evaluation of a form may initiate the execution

July 27, 1978

11-1.

Page 1-1

_-=:A,""'-

o

Maclisp Reference Manual

of a large and complex program, perhaps never returning to the "top level" interpreter,
or it lJ1ay perform some simple action and immediately wait for the user to type another
form.
It is also possible to get into the interpreter while a program is running, using the

break facility. This is primarily used in debu~ging and related programming activities.
The functions invoked by the top-level interpreter may be executable machine
programs, or they may themselves be interpre~ed. This is entirely a matter of choice and
convenience. The system functions are mostly m'a-chine programs. User functions are
usually first used in_terpretively. After they work, the complier may be applied to them,
turning them into machine programs which can then be loaded into the environment.
All of this is done within a single consistent language, Lisp, whose virtue is that the
data structure is simple and general enough that programs may easily operate on
programs, and that the program structure is 'simple and general enough that it can be
used as a command language.
.

Page l ..2

~1-1.1

July 27, 1978

°1

o

General Information

1.2

Struoture of the Man~al

The manual is generally, structured into sections, on particular topics; each section
contains explanatory text and function definitions interspersed. In general, each section
contains both elementary and complex material with complexity increasing toward the
end of the section. An axiomatic, step-by-step development is not used. Frequentl, the
more complex information in a section will assume knOWledge from other sections which
appear later in the manual. The new user is advised to skip around, reading earl,
chapters and early sections of chapters first.
t

t

Often descriptions of Lisp functions will be given not only in prose but also in terms
of other Lisp functions. These are as accurate as possible but should not be taken too
literally. Their main purpose is to serve as a source of examples.
t

C\
,;

o

. Accessing information in the manual is dependent on both the user's level of ability
and the purpose for which she or he is using the manual. Though cover to cover reading
is not recommended (though not excluded), it is suggested tha.t someone who has never
previously seen this manual browse through it, touching the beginning of each
subdivision that is listed in the Table of Contents, in order to familiarize himself or
herself with the material that it contains. To find an answer to some particular
question, one must use one of the provided access methods. Since the manual is
structured by topiCS one can use the Table of Contents that is found at the beginning of
the manual, and the more detailed tables of contents found at the beginning of each of
the six major parts, to find where information of a general class win be found. Entry
into the manual is also facilitated by the Glossary and the Concept Index, which are
found at the end. Also at the end of the manual are a Function Index and an Atomic
Symbol Index which are probably most useful to a regular and repeated user of the
dialect, or to an experienced user ~f another dialect, who wishes to 'find out the answer to
a question about a specific function. When one section of the manual assumes knowledge
of another section a page number reference to theother·section win generally be given.

July 27, 1978

11-1.2

Page 1-3

o

Mac1isp Reference Manual

1.3

Notational- Conventions

There are some conventions of notation that must be mentioned at this time, due to
their being used in examples.
Most numbers are in octal radix (base eight). Numbers with a decimal point and
spelled-out numbers are in decimal radix. It is important to remember that by default
M ac1isp inputs and outputs all numbers in octal radix. If you want to change this, see
the variables base and i base.
A combination or- the characters equal sign and greater than symbol, "->., will be
used in examples of Lisp code to mean evaluation. For instance, "F => II" means that
evaluating the form F produces the value ll.

An uses of the phrase "Lisp reader," unless further qualified, refer to that part of
the Lisp system which reads input, and not to the person reading this document.
The terms "S-expression" and "Lisp .object" are synonyms for "any piece of Lisp
data."
The character "I" always stands for dollar-sign, never for "alt mode," unless that is
specifically stated.
The two characters accent acute, """~ and semi-colon, ";", are examples of what are
called macro characters. Though the macro character facility, which is explained in Part
5, is not of immediate .interest to a new user of the dialect, these two macro characters
come preset by the Lisp system and are useful. When the Lisp reader encounters an
accent acute, or quote mark, it reads in the next S-expression and encloses it in a quoteform, which prevents evaluation of the S-expression. That is:
"some-atom
turns into:
(quote some-atom)
and
"(cons "a "b)

o

turns into

Page 1-4

fl-1.3

july Z'/, 1978

o

General Information
(qtio~e

(cons (quote .8) (quote b»)'

The semi-colon (;) is used as a commenting character. When the Lisp reader
encounters it, the remainder of the line is discarded.
The term "newline" is used to refer to that character or sequence of characters which
indicates the end of a line. This is implementation dependent. In Multics Maclisp.
newline is the Multics newline character, octal 012. In ITS Maclisp, newline is
car"riage return (octal 015), optionally followed by line feed (octal 012.) In dec-IO
M ac1isp, newline is ~arriage return followed by line feed.
An Lisp examples in this manual 'are written according to the case conventions of
the Multics.implementation, which uses both upper and lower case letters and spells the
names of most system functions in lower case. Some implementations of M aclisp use
only upper case letters because they exist on systems which are not, or have not always
been, equipped with terminals capable of 'generating and displaying the fun ascii
character set. However, these implementations will accept Input in lower case and
translate it to upper case, unless the user has explicitly said not to.

Page 1-5

July 27, 1978

HiiiMlfIMiifimmAlliJlJilMUiliiiiidWL&mlf;=1j[MI&aUffiIiJMTff\if1F\if'4f "MF.fi!AR ,;

'IiI
",

o

Mac1isp Reference Manual

o
il-1.3

Page 1;,.6

. --------------~-

July 27, 1978

0,

Data Objects

"

2.

Data ObJeots

Lisp works with pieces of data called "objects" or "S-expressions." rhese can be simple
"atomic" objects or complex objects compounded out of other objects. Functions, the basic
units of a Lisp program, are also objects and may be manipulated as data.
Objects come in several types. An types are manifest; that is, it is possible for a
program to te11 what type an object is just by looking' at, the object itself, so it is, not
necessary to declare the types of variables as in some other languages. One can make
declarations, however, in order to aid the compiler in producing optimal code. (See part
4.2.)

It is important to know that Lisp represents objects as pointers, so that a storage cell
(a "variable") wilt hold any object, and the same object may be held by several different
storage cells~ For example, the same identical object may be a component of two different
compound objects.

()

The data-types are divided into three broad dasses: the atomic types, the non-atomic
types, and the composite types. Objects are divided into the same three classes according'
to their type. Atomic objects are basic units which cannot be broken down by ordinary
chemical means (car and cdr), while non-atomic objects are structures constructed out of
other objects. Composite objects are indivisible, atomic, entities which have other objects
associated with them. These other objects may be examined and replaced.
The atomic data types are numbers, atomic symbols, strings, and subr-objects. Atomic
, symbols can also be regarded as composite. See below.
In Lisp numbers can be represented by three types of atomic objects: fixnums, flonums,
and bignums. A fixnum is a fixed-paint binary integer whose range of values is
machine-dependent. A flonum is a floating-point number whose precision and range of
values are machine-dependent. A 'bignum is an infinite-precision integer. It is
impossible to get "overflow" in bignum arithmetic, as any integer can be represented by a
bignum. However, fixnum and flonum arithmetic is faster than bignum arithmetic and
requires less memory. Sometimes the word "fixnum" is used to include both fixnums and
bignums (i.e. all integers); in this manual: 'however, the word "fixnum" will never be used
to include bignums unless that is explicitly stated.
The printed representations for numbers are as follows: a fixnum is represented as a
sequence of digits in a specified base, usually octal. A trailing decimal point indicates a

o

July ,27, 1978

11-2.

Page 1-7

Wiil

o

Maclisp Reference Manual

decimal base. A ftonum is represented as a set of digits containing an embedded or
leading decimal point and/or a trailing exponent. The exponent is introduced by an
upper or lower case "e". A bignum looks like a fixnum except that it has enough'digits
that it will not fit within the range available to fixnums. Any number may be preceded
by a + or - sign. Some examples of fixnums are 4" -1232, -191., +46. An example of
a bignum is 1565656565656565656565656565656565. Some examples of flonums are:
4.0, .01, -6e5, 4.~e-l.
One of the most important Lisp data types is the atomic symbol. In fact, the word
"atom" is often used to mean just atomic symbols, and not the other atomic types. An
atomic symbol has associated with it a name, a value, and pOSSibly a list of "properties".
The name is a sequence of characters, which is the printed representation of the atomic
symbol. This name is often called the "pname," or "print-name." A pname may contain
any ascii character except the null character, which causes trouble in some
implementations. For example, a c'ertain atomic symbol would be represented externally
as foo; internally as a structure containing the value, the pname "foo", and the
properties.
There are two special atomic symbols, t and n i 1. These always have their respective
selves as values and their values may not be changed. nil is used as a "marker" in
rna ny contexts; it is essential to the construction of data structures such as lists. t is
usually u~ed when an antithesis to nil is reqUired for some purpose, e.g. to represent
the logical conditions' "true" and "false." Another property of the special atomic symbol
nil is that its car and its cdr are always n i 1.

o

The value of an atomic symbol can be any object of any type. There are functions to
set and get the value of a symbol. Because atomic symbols have values associated with
. them, they can be used as variables in programs and as '"dummy arguments" in
functions. It is also possible for an atomic symbol to have no value, in which case it is
.
said to be "undefined" or "unbound."
The property list of an atomic symbol, is explained on page 2-52. It is used for such
things as recording the fact that an atomic symbol is the name of a function.
An atomic symbol with one or no characters in its· pname is often caned a "character
object" and used to represent an ascii character. The atomic symbol with a zero-length
pname represents the ascii null character, and the symbols with one-character pnames
represent the character which is their pname. Functions which take character objects as
input usually also accept a string one character long or a fixnum equal to the ascii-code
value for the character. Character objects are always interned. on the obarray (see page
2-58).

o
Page 1-8

11-2.

July ?J, 1978

o

Data Objects

Another Lisp data type is the string. This is a sequence of characters (possibly zerolength). St~ings are used to hold messages to be typed out and to manipulate text when
the structure of the text is not appropriate for the use of "list processing." The printed .
representation of a string is a sequence of characters enclosed in double-quotes, e.g.
"foo". If a " is to be included in the string, it is written twice, e.g. ·foo· ·bar· is
foo"bar. In implementations without strings, atomic ~ymbols are used instead. The
pdp-IO implementations currently lack strings.
A "subr-object" is a special atomic data-type whose use is normally hidden in the
implementation .. A subr-object represents executable machine code. The functions built
into the Lisp system are subr-objects, as are user functions that have been complied. A
subr-object has no printed representation, so each system functlon has an atomic symbol·
which serves as its name. The sy.mbol has the subr-object as a property.

o

One composite data type is the array. An array consists of a number of cells, each of
which may contain any Lisp object. The cells of an array are accessed by subscripting;
each cell is named by a tU'ple of integers. An array may have one or more dimensions;
the upper limit on the number of dimenSions is implementation-defined. An array is not
always associated with an atomic symbol which is its name. Rather, an array is always
designated' by an array-pointer, which is a spec·lal kind of atomic Lisp object.
Frequently, an array-pointer will be placed on the property list of a symbol under the
indicator array and then that symbol will be used as the name of the array, since
symbols can have mnemonic names and a reasonable printed representation. See page 289 for an explanation of how to create, use, and delete arrays.
Another composite data type is the file-object, which is described on part 5.S.
The sole non-atomic data type is the "cons." A cons is a structure containing two
components, called the "car" and the "cdr" for historical reasons. (These are names of
fields in an IBM 7094 machine word.) These two components may be any Lisp object,
even another cons' (in fact, they could even be the same cons). In this way complex
structures can be built up out of simple conses. Internally a cons is represented in a
form Similar to:

car

cdr

where the boxes represent cells of memory large enough to hold a pointer, and "car" and
"cdr" are two pointers to objects. The printed representation of a cons is the "dottedpair" notation (A • B) where A is the car and B is the cdr.

o

11-2.

July 27, 1978

g,¢M4n;,¥4¥HA, M#¥i\f/ii,";;#lQWP¥MlIlli;i4;

\fTl$/lI/d4/Hj1iM_Mfffif!riiiifffi%.*

1

$"

I

4"

,:&C.T ___4;;;=P,wmo;..MIG&&&.&MM&MilMii4lWlWWU.......IiJfSWM;Wfa. .

Page 1-9

o

Mac1isp Reference Manual

Another way to write the internal representation of a cons, which is more, convenient
for large structures, is:
--~ 0 -----)

cdr

I
I
V
car

There are three Lisp functions associated with conses: cons, car, and cdr. The
. function cons combines its two arguments into a cons; (1 • 2) can be generated by
evaluating (cons 1 Z). The function car returns. the car component of its argument,
and the function cdr returns the cdr component of its argument.
.One type of structure, built out of (:onses, that is used quite often, is the "list." A list
is a row of objects, of arbitrary length. A list of three things 1, 2, and 3 is constructed
by (cons 1 (cons 2 (cons 3 ni 1»); ni 1 is a special atom that is used to mark the
end of a list. The structure of a list can be diagrammed as:
--~ 0 ----) 0 ----) 0

V
1

I
I

I
I

V

V
3

2

0

----) nil

From this it can be seen that the car of a list is its first element, that the cdr of a list
is a list of the elements after the first, and that the list of no elements. is the same as
nil.
This list of 1, 2, and 3 could be represented in the' dot-notation used for conses as
• (2 • (3 • nil»). However, a more convenient· notation for the printed
representation of lists has been defined: the "list-notation" (1 2' 3). It is also possible
to have a hybrid of the two notations which is used for structures which are almost a list
except that they· ·end in an atom other than n i 1. For example, (A • (B • (C • D»)
can be represented as (A Be. D).
.
(1

A list not containing any elements is perfe,ctly legal and frequently used. This zerolength list is identified with the atom n11. It may be typed in as either nil or ().

o

"I

II

Page I~IO

11-2.

July ·27, 1978

o

The Basic Actions of LISP

3.

The Basio Aotions of LISP

3~1

Binding ()f Variables

The basic primitives of programming in Lisp are variables, forms, and functions. A
variable is an atomic ~ymbol which has a value associated with it; the symbol is said to be
bound to that value. The value may of course be any Lisp object whatsoever. The atomic
symbol acts simply as a name by which the program may refer to the value while it is
processing it.
This is similar to the concept of variables in other programming languages.
However, LiSp's concept of the scope of names is subtly different from that of most "blockstructured" languages. At a given moment, a variable may actually have several
bindings in existence. Only the most recent, or current binding, can be used. When a
new binding is created, the previous one is pushed onto a stack. It will become accessible
again when the binding which superseded it is removed. Creation and removal of
bindings is synchronized with subroutine calling (and with certain special forms
described below) so this mechanism corresponds closely to the "local variables" concept of
other programming languages. However, Lisp considers that there is only one variable
whose binding changes, rather than several separate variables which happen to have the
same name. Any reference to a variable, even from outside the particular program which
gave it its current binding, gets the current binding and not one determined by ·scope
rules." It is possible to simulate the other concept of scope of names by using binding
context pOinters, which are described later (see page 1-22).
Unlike many other languages, Lisp does not combine the concepts of name and
storage. Many languages associate with a variable (a name) a piece of storage which
can hold one object of a particular type, such as a floating point number. The variable's.
value resides in this storage.' It is then impossible for two variables to really have "the
same" value; one could have a copy of the value of another but not the same identical
object.
The situation in Lisp is quite different. Binding a variable to a value is not
copying the value into storage associated with that variable. Values exist as separate
objects in their own right and in their own storage. Binding is simply an association
between a variable and a value; consequently there is no reason why two variables cannot
have truly identical values. Similarly. erasing the binding between a variable arid its
value does not destroy or throwaway the value; it simply breaks the association. or

o

11-3.

July 27. 1978

-PAT

'##44.

WAPA

.N ?#4T\AM44M#.#T\M4#M4. ;MTf4lMAWf.4I4M\P#MHRIff,;

. !4&fiiiffTH.·¥f·

Page 1-11

4 r;p;:U.AA:44JU&Mi4&4IMWlb11illMThWOJA.U&.iJA&QiAM,WlkIlDM;;a&&MtQi.....-WIlliGi&RiWiRiil. . .

o

Mac1isp Reference Manual

course, if there is no other use for the value the storage it occupies will eventually be
reclaimed by the system and put to more productive use.
Often these processes. of creating a new binding of a variable to a value and
reverting to a previous binding are referred to as bindtng and unbinding the variable,
respectively.
A slightly different way of creating a binding between a variable and a value is

assignment. When.a variable is bound to a value, the previous binding is. saved and
can be restore~, but when a variable ~as a: value assigned to it, the previous binding is
not saved, but is simply replaced. Thus binding may be regarded as creating a new
level of usa:ge of a variable, while assignment switches a variable to a different value
within the same level. For instance, a subroutine or function' may bind a variable to an
initial value ~hen it is entered, and then proceed to make use of that variable, possibly
assigning a different value to it from time to time. The initial binding of the variable
estab1ishes the (temporary) ownership of that variable by the subroutine.
Due to the sub.tlety of the'distinction between binding and aSSignment, some people
have proposed that assignment be eliminated wherever possible. The Mac1isp do
function can often be useful in this regard.

o

There are several program constructs by which a variable can be bound. These will
be explained after forms and functions have been introduced.

o
Page 1-12

it-3.t

july

2'.

----

1978

----------------

o

The Basic Actions of LISP

3.2

Evaluation of Forms

The process of "executing" a Lisp program consists of the ,valuatton of forms.
Evaluation takes a form and produces from it a value (any Lisp object), according to a
strict set of rules which might be regarded as the complete semantics of Lisp.
If the form is atomic, it is evaluated in a way which depends on itS data type. An
atomic symbol is a variable; it evaluates to the value to which it Is currently bound. If It
is not bound, an error occurs. (See part 3.4.) A number or a string is a literai constant;
it evaluates to itself. The special atomic symbols t and nil are also treated as
constants. A constant can also be created by use of the quote special form; the value of
(Quote x) is x.
If the form is a list, its first element specifies the operation to be performed, and Its
remaining elements specify arguments to that.operation. Non-atomic forms come tn two
types: special forms, which include the .necessary programming operations such as
aSSignment and conditionals, and funCtion ref,rencts, in which the "operation" is a
function which is applied to the specified arguments. Thus functional composition is the
method by which programs are built up out of parts - as distinguished from composition
of data structure$, for example. Lisp functions correspond closely to subroutines In other
. programming languages.

c

A function may be either a primitive which is directly executable by the machine,

called a subr (short for "subroutine"), or a function defined by composition of functions
and special forms, called an expr (short for "expression.") Most subrs are built In to the
language, but it is possible for
user to convert his exprs into subrs by using the
compiler (see part 4.) Th·is gains· ~peed and compactness at some cost In debugging
features.

a

There is additional complexity because special forms are actually implemented as if
they were function .references. There is a special type of subr called an fs~br which is
used for this purpose. An fsubr is permitted to make any arbitrary interpretation of its
argument speCification list, instead of following the standard procedure which is
described below. It is also possible to define a special form by an expr, which Is then
called a fexpr. Most of the built-in special forms are handled specially by. the compiler.
They are compiled as the appropriate code rather than as a call to the fsubr.
Other types of functions are lsubr, which is just a subr with a variable number of
arguments, lexpr, which is an expr with a variable number of arguments, and macro,
which is a type of .special form whose result is not a value. but another f~rm; this allows
a "transformational" type of semantics.

o
;..#@444LP

11-3.2

july 27, 1978

A¢¥

. -, 4

.r ..#

M 1#44##44&

Rf .

Page I-IS

4i

i/fiIIifW ¥Tr+f'ffliNihijtM J,Jidl4MOQiPi.iCf£4WGLMtmiM itt&GI IGWdIiMG&W&&&N&!&&iM&:iNH&Wi£M\l&&i\IliW

o

Mac1isp Reference Manual

Consider the form .
(F Al A2 ... An)

The evaluator first examines F to see if it is a function which defines a special form,
i.e. an fsubr, a fexpr, or a macro. If so, F is consulted and it decides how to produce a
value. If not, F must be an ordinary function. The sub-forms Al through An are
evaluated, producing n arguments, and then the defi~ition of F is applttd to the
arguments. (Application is described in the following section.) This yields a result
(some Lisp object), which is then taken as the value or'the form.
An atomic form of some random type, such as a subr-object, a file, or an array-pointer,
evaluates to something· random, often itself; or else causes an error depending on the
convenience of the implementation. Note that an array-pointer is different from an
atomic symbol which happens to be the name of an array; such an atomic symbol is
evalJlated the same as any other atomic symbol.

o

o
11-3.2

July 2'7. 1978

o

The Basic Actions of LISP

3.3

Application of Functions

When a non-atomic form is evaluated, the function specified by that form is combined
with the arguments specified .by that form to produce a value. This process is called
application; the function is said to beapplitd to the arguments.
The first step in application is to convert the function-specifier into a functltmal
expression (sometimes confusingly called a functional form.) A functional expression is a
Lisp object which is stylized so that Lisp can know how to, apply it to arguments. The·
rules for this conversion will be described after the types of functional expressions have
been explained.
There are basically two types of functional expression. A 1ambda-expression is a
functional expressiQn which specifies some variables which are to be bound to the
arguments, and some forms which are to be evaluated. One 'would expect the forms to
depend on the variables. The value of the last form is used as .the value of the
application of the 1ambda-expression. Any preceding forms are present purely for their
side~effects. A 1ambda-expression looks like:
(lambda (a bed)
forml
formZ
form3)
Here a, b, c, and d are the variables to be bound to the values of the arguments,
called the 1ambda-variables. If at a certain moment the current binding of a was the
one created by this lambda-expression, a would be said to be 1ambda-bound. Clearly this
1ambda-expression is a function which accepts four arguments. The application of the
functional expression to four arguments produces a value by evaluating form I, then
form2, and then form3. The value of ·form3 is the value of the whole form. For
example, the value of the form
«lambda (a b) b) 3 4)
is 4. The functional expression used is a very simple one which accepts two arguments
and returns the second ·one.

If we grant the existence of a primitive addition operation, whose functional
expression may be deSignated by +, then the value of the form
«lambda (a b) (+ a b»

o

. july 27, 1978

fl-3.3

3 4)

Page 1-15

o

Mac1isp Reference Manual

is 7. Actually,
(+ 3 4)

evaluates to the same thing.

.

The second basic type of functional expression is the sub.r, which Is' a program
directly executable by the machine. The arguments of the form are conveyed to this
program in a machine-dependent manner, it performs some arbitrary computation, and it
returns a result. .The built in primitives of' the language aresubrs, and the user may
write lambda-expressions which make use of ' these subrs to define his own functions.
The compiler may be used to convert user functions into subrs jf extra efficiency is
reqUired.
It is extremely convenient to be able to assign names to functional expressions.
Otherwise the definition of a function would have to be written out in full each time it
'.Vas used, which would be impossibly cumbersome~
Lisp uses atomic symbols to name functions. The "property list" mechanism is used
to associate an atomic symbol with a fu~ctional expression. (See page 2·-52 for an
explanation o~ property lists.) Because .the binding mechanism is not used, it is possible
for the same name to be used for both a variable and a function with no conflict. Usually
the defun s'pecial form is used to establish the association bet,ween a function name and
a functional expression.

o

Thus, the car of a form may be either a functional expression itself, or an atomic
symbol which names a functional expression. In the latter case, the name of the
"property" which associates the symbol with the expression gives additional information:
A 1ambda-expression is normally placed under the expr property. This defines an
ordinary expr.
If a 1ambda-expression is placed under the fexpr property, it defines a special form.
In that case, the first 1ambda-variable is bound to the cdr of the form being evaluated.
For example, if foo isa fexpr, and (foo (a b) (c d» is evaluated, then foo's
lambda-variable would be bound to «a b) (c d». A second lambda-variable may
optionally be included in a fexpr. It win be bound to a "binding context pointer" to the
context of the evaluation of the form. (See page 1-22 for the details of binding context
pointers.)

If a 1ambd a-ex pression with one 1ambda-variable Is placed under the macro
property, it defines the "macro" special form mentioned above. The lambda-expression is

Page 1':'16

11-3.3

July 27, 1978

- . - - - - - - - -..- -..

----~.--------.

o

o

The Basic Actions of LISP
applied to the entire f9rm, as a single argument, and the valu~ Is a new form that Is
evaluated in place of the original form.
If a subr-object is placed under the subr property, it defines a subr. If a subr-object
is placed uilder the fsubr property, it defines a special form. A subr-object under the
1 subr property defines a subr which accepts varying numbers of arguments.
There are some additional refinements. A 1ambda-expresslon which· accepts varying .
'
. numbers of arguments, called a 1expr, looks as follows:
(lambda n
forml
form2)
The single, unparenthesized, 1ambda-variable n is bound to the number of arguments.
The function arg, described on page 2-12, may be used to obtain the arguments.
Another property which resembles a functional property is the autoload property. If
Lisp encounters an auto load property while searching the property'list of a symbol for
functional properties, it loads in the file of compiled functions specified by the property,
then searches the property list again. Presumably the file would contain a definition for
the function being applied, and that definition would be found the second time through.
In this way packages of functions which are not always used can be present in the
environment only when needed.

()

An array may also be used as a function. The arguments are the subscripts and the
value is the .contents of the selected cell of the array. An atomic symbol with an array
property appearing in the function position in a form causes that array to be used.
If the function-specifier of a form doesn't"meet any of the above tests, Lisp evaluates
it and tries again. In this way, "functional variables" and "computed functions· can be
used. However, it is better to use the funca 11 function. (See page 2-13.)
.There are some other cases of lesser importance:
There is an obscure type of functional expression called a 1abe l-expression. It looks
like
(l~bel

The atomic symbol name is bound to the enclosed lambda-expression for the duration of
t'he, application of the 1abe l-expression. Thus if name is used as a functional variable
this temporary definition will be used. This is mostly of historical interest and is rarel,
used in actual prog(amming.

o
« @44

name (lambda ( ••• ) ••• »

July 27, 1978

$

n

;

- q

#44.4T44

"" A%n# M4¥MMM:;;;4 ... ·,. 7WaqgH·;PYF?PM.

11-3.3

t T4f4MIHM8W9fAffMF ; ;

Page 1-17

4lfT\i!\ffT4I+N¥,MF.4WiiiHIriiPiil'dfit;!Ifd\,f,iIfffi\ , l"; .;kAil4ifi£KMi.mWIlKggUJtm 1&JU1&i4MG iIM If &G11 lMAW4l!G]1M6RJJmGUIlllLffi1 iffU,M:;;;:m;:M!00i44J

o

Mac1isp Reference Manual

Another type of functional expression is the funarg. A funarg is a list beginning
with the atomic symbol funarg, as you might expect, and containing a function and a
binding context pointer. Applying a funarg causes the contained function to be applied
in the contained binding context instead of the usual context. funargs are created by
the*funct 1on special form.
An expr property may be an atomic symbol rather than a 1ambda-expresslon. In this
case, the atomic symbol is used as the function. The original symbol is simply a synonym
for it.
In addition to the variety of application just described, which is used internally by
the evaluation procedure, there isa similar but not identical application procedure
available through the function apply. The main difference is,that the function and the
arguments are passed to apply separately. They are not encoded into a form,
consequently macros are not accepted by this version of application. Note that what is
passed to apply is a list of arguments, not a list of expressions which,.evaluated, would
yield arguments.
.

o

Page 1-18

ll-3.3

July 't7, 1978

o

The Basic Actions of LISP

o
3.4 Speoial Forms'

This section briefly describes some of the special forms In Maclisp. For full details
on a specific special form, consult the Function Index in the back.
Constants
(quote .x) evaluates to the S-expression x.
( funct i on x) evaluates to the functional expression x. There is little rea1
difference between quote and funct ion. The latter is simply a mne.reonic
reminder to anyone who reads the program - including the compiler - that the
specified expression is supposed to be some kind of function.
Conditionals
Conditionals control whether or not certain forms are evaluated, depending on the
results of evaluating other forms. Thus both the value and 'the side effects. of the
conditional form can be controlled ..

o

(cond <predicate forml form2 • •• ) (predicate forml form2 • •• ) ••• )
is a general conditional form. The lists of a predicate and some forms are called
clauses. The cond is evaluated by considering the clauses one by one in the order
they are written. The predicate of a clause is 'evaluated, and if the result is tnu,
that is, anything other. than nil, then the forms in that clause are evaluated and
the cond is finished without examining the remaining Clauses. If. the result is not
trut, i.e. if it is nil, then the next clause is examined in the same way. If all the
clauses are exhausted, that is not an error. The value of a cond is the value of
the last form it evaluates, which could be nil if no predicate Is true, or the value
of a prediqtte if that predicate is true but has no forms in its clause.
(and form! form2 form] • •• ) evaluates the forms in succession until one is nil

or the forms are exhausted, and the result is the value of the I~st form evaluated.
(or forml form2 formJ ••• ) evaluates the forms until one is non-n 11 or the
forms are exhausted, and the result is the value of the last form evaluated.

o
fP.-J1IifJIijJijfflAflrp;;;MfjlhFFiiiii$iifiWfIffMiA, ;

11-3.4

July 27, 1978

ififfifiih'ffAAlR'flf\i4h¥Rif\Mff¥fYII

# ;;414,

4;; 4Th;; J..

i

,hii¥fTt'j'fTffll/Jl4l:'fll1'tl¥ili5ijAl]IIfi.1IfT'Itl1lmj I, .1

~

.'LJit . .¥fI'jri Q. !.

L,un

·'ffiJJ!fti&I!iJ;;tc fm·@ MC£itUJ _W.t¥1Ml'- "L_'-. Uf .QLA4.JbI.n

Page 1-19

L.Ll. J. ~ MI . .Yi;CJICR_·,4\;;lftllflII!Mltt.bfi[iWniatYL4@Mk-l[bW'i l.}} l§4bMg~.m"",n&ttq;:jIUf;;fL,j!i*-\fuMgm;·· -.-

o

Maclisp Reference Manual

Non-Local Exits
( ca tch form tag) evaluates the form, but if the special form (throw val~ tag)
is encountered, and the tags are the same, the catch immediately ret"rns the
value without further ado. See page 2-44 for the fun details.
Iteration
(prog (variable ••• ) form-or-tag ••• ) allows Fortranoid ·'programs· with
goto's, local variables, and return's to be written.
(do ••• ) is the special form for iteration. See page 2-38 for the details of prog
and do.
Defining Functions
( defun name (arg 1 arg2 ••• ) forml form2 ••• ) defines an (interpreted)
function. See page 2-60 for full details."

o

Error Control
(br.eak name t) causes "; bkpt name"' to be typed out and gives control to a
read-eval-print loop so that the user can examine and change the state of the
world. When he is satisfied, the user can cause the break to return a value. See
page 3-5 for the details of break.
(errset form) evaluates the form, but if an error occurs the err set simply
returns n 11. If no error occurs, the value is a list whose single element is what
the value of the form would have been without errset.
ASSignment
(setq varl valuel var2 value2 ••• ) assigns the values to the variables. The
values are forms which are evaluated.
( store (arra, subscriptl subscript2 ••• ) value) assigns the value to the array
. cell selected by subscripting. See part 2.8 for further information on arrays.
Miscellaneous Parameters
(status name -optional args-) returns miscellaneous parameters of LISP. nalM
is a mnemonic name for what is to be done.

Page r"20

11-3.4.

July 27, 1978

o

The Basic Actions of LISP

'0

(sstatus name -opttonal args-) sets miscellaneous parameters.
See part 3.7 for the details of status and sstatus.
Pretty-Printing
( gr 1"def x) prettily prints the value and function definition (If any) of the

atomic symbol x. Indentation is used to reveal structu~e, the quote special form is
represented by , etc. See part 6.3 f,or the details..
t

Tracing

(trace name) causes the function name to print a message whenever it Is called
and whenever it returns. See page 3-35 for the many features and options of
trace.

()

o

july 27, 1978

11-3.4 "

Page 1-21

o

Mac1isp Reference Manual

3.5

Binding Context Pointers

There is a special type of object called a bindtng context pOinter, or sometimes an -alist pOinter", which can be used to refer to a binding context (a set of bindings of
variables and values which was extant at a particular instant.) Due to the stack
implementation of Mac1isp, a binding context pointer is only v~did while control is
nested within the binding context it names. It is not possible to exit from within a
binding context but keep it around by retaining a pointer to it.
A binding context pointer is either a negative fixnum or nil. nil means the
"global" or "top level" binding context. The negative fixnum is a special value of
implementation dependent meaning which should be obtained only from one of the four
following sources: the function eva 1frame, the function errframe, the special form
*funct i on, or the second 1ambda-variable of a fexpr. '
The only use for binding context pointers is to pass them to the functions eval and
app ly to specify the binding context in which variables are to be evaluated and
aSSignments are to be performed during that evaluation or application. Binding context
pointers are also used 'internally by *funct ion. When it generates a funarg, it puts in
the funarg the functional expression it was given and a binding context pointer
designating the binding environment current at the time *funct 1on was called.

Page,F22

July 27, 1978

ll-3.S

---_ .. --------- .. -------- .. -------------- _-----------_ ..-.. _-----_ .. _------_ .... _---- -- --.

_ ..

- _.. ----

o

o

c

Function Descriptions

Part 2 - Funotion Desoriptions
Table of Contents

C!

c

I.

Predicates ..................................

2.

The Evaluator . ~ ........................

3.
3.1
3.2
3.3
3.4
3.5
3.6

Manipulating List Structure ..........' ......
Conses ..................... '.......... ~
Lists
................................
Alteration of, List Structure ....................
Tables ....................................
SQrting .....................
Hunks ; ........... '......................

4.
4.1
4.2
4.3
4.4

Flow of Control. ............... ~ ....
Conditionals .................
Iteration ....................
Non-loca~ Exits .... '..........................
Causing and Controlling Errors ...

5.
'5.1
5.2
5.3
5.4
5.5

Atomic Symbols...................................
The Value Cell ......................................
The Property List ........................... '.....
The Print-Name ................ '..
Interning of Symbols. ........................
Defining Atomic Symbols as Functions. ...................

6.
6.1
6.2
6.3
6.4
6.5
6.6
6.7
6.8

Numbers. '...........................
Number Predicates, ..•....... '................
Comparison .............................
Conversion ..........................
Arithmetic .........................
Exponentiation and Logarithm Functions .......
'Trigonometric Functions ............ o.
Random Functions ....... ~ ...
Logical Operations on Numbers. .........

7.

Character ManipulatioD ................

0

0

0

0

0

•

0

•

0

••••••

•

0

•••

0

0

0

0

•

0

0

0

0

0

0

•••

0

•

0

••••

0

0

0

••••••••

0

0

0

••

0

•••

0

0

0

0

0

0

•

0

•

0

0

•••••

0

0

•

0

0

0

•

0

0

0

0

•

0

0

0

•

0

0

0

•••

0

0

0

0

•

0

0

•

0

•

0

0

••

0

0

0

••••••

0

•

0

0

••

0

0

•

0

•

0

••

0

•••

0

•

0

•••

0'

0

•

'0

0

•

0

•

0

0

•

0

•

0

•

0

0

0

0

0

0

0

••

0

•

0

0

0

0

••

0

0

0

•

•

•

0

0

0

0

•••••

•••••

•

•

•

•

•

•

•

••

•

••••

0

•

0,0

0

•

0

0

0

••••••

0

•

0

0

•

00

0

•

•

•

•

•

0

0

0

0

••

0

•••••

0

0

July 27, 1978

0

0

•

•••••

0

0

•

••

o.

0

••••••••••

••

0

0

0

0

•••••

0

••

0

0

0

0

0

•

0

0

0

0

0

•••

0

••

0

0

•

0

•••

0

••

0

0

0

0

0

••

0

••

0

••••

0

••

0

••

0

0

•••

0

•••

•

0

•

0

0

••

0

....

0

0

••••

0

•

0

0

••••••

0

•••••••

0

••••

0

0

0

•

0

•

0

•

•

0

••••••

0

•

0

0

0

••

0

0

0

••

0

'0

0

•

0

••

0

0

0

•

0

0

0

••

••

0

0

••

0

••

0

0

••••••••

0

0

0

0

0

0

•

0

•

0

••

0

••••••

0

•

0

••••

0

0

••

0

••

0

••••••

0

•••••••

0

••••••

0

••••

••

0

0

0

2-35
2-36
2-3 8
2-44
2-46

2.. 49
2-49
2-52
2-56
2-58
o. 2-60

•

0

0

2-7

2-15
2-15
2-18
2~ 2 2
~ 2-24
2-30
o. 2-32

0

0

2-1

0

•••

0

0

0

••••••

••••••

0

0

••••••••

••••••••••

0

0

•••••••••••••••••

0

0

•

0

•••••

2-63
2-63
2-65
2-67
2-69
2-77
2-78
2-79
2-80
2-83

Page 2-1

i1!i

o

Maclisp Reference Manual

7.1
7.2

C~aracter Strings ." ....................................

Character Objects .........................

8.

Arrays ............

9.

"Mapping Functions .......

0

••••••••••••••••••••

0

'0

0

•••••

0

•••

0

•••

0

0

•

•••

0

••••

0

0

•

•••••••••

0

0

0

•••••••••••••••••••••••••

0

•••••••

2-83
2... 86
2-89
2-97

o
Page 2-2

july 27. 1978

o·

Predicates

1. Predicates
A predicate is a function which tests for some condition involving its argument and
returns t if that condition is true, or nil if it is not true.
. The fonowing predicates are for checking data types. These predicates return t if
their argument is of the type indicated bY'the name of the function, n t 1 if it Is of some .
other type. Note that the name of most predicates ends In the letter p, by convention.

SUBR 1 arg

atom

The atom predicate returns nil if its argument is a dotted~pair or a list, or t if
it is any kind of atomic object such as a number, a character string, or an atomic
symbol.
.

C'

symbolp

SUBR 1 arg

/

The symbo 1p predicate returns t if its argument is an atomic symbol, or n t 1 if It
is anything else.

SUBR 1 arg

f1xp

The f 1xp predicate returns t if its argument is a fixnum or a bignum, otherwise
nil ..

floatp

SUBR 1 arg

The floatp predicate returns t if its argument is a ftonum, nil if- it Is not.

SUBR 1 arg

b1gp

The predicate b 1gp returns t if its. argument is a bignum, and n t 1 otherWise.

july 27, 1978

!2-1.

Page 2-1

ZOG&&&L&llM&ilMMiI"'Mf_&

,\

o

Maclisp Reference Manual

SUBR 1 arg

numberp

The numberp predicate returns t if its argument is any kind of number, nil if it
is not:

SUBR 1 arg

hunkp

The hunkp predicate returns t if its argument is a !zunk (see page 2-33 for a
discussion of hunks). 'hunkp does not consider list ce11s to be· hunks. This
predicate does not exist in the Multics implementation.

typep

SUBR 1 arg
typep is a general function for constructing type-predicates. It returns an atomic
symbol describing the type of its argument, chosen from the list
(fixnum flonum bignum list symbol string array random)
symbo 1 means atomic symbol. 1i st means a list or a cons. array means arraypointer. random is for all types that don't fit in any other category. Thus
numberp could have been defined by:

o

.(defun numberp (x)
(and (memq (typep x) "(fixnum flonum b1gnum»
t) )

The following two functions only exist in the Multics implementation.

stringp

SUBR 1 arg

The stringp predicate returns t if its argument is a string, otherwise nil.

SUBR 1 arg

subrp

The subrp predicate returns t if its argument is a "subr" object, i.e. a pointer to
the machine code for a compiled or system function. Example:
(subrp (get "car "subr»

l2-1.

Page 2-2

----.---~-----

....

o

=> t
July 27, 1978

o

Predicates
The fol1oWi~g are a more miscellaneous set of predicates.

eq

SUBR 2 args
(eq x ,) => t if x and, are exactly the same object, nil otherwise (cr. equal).
It should be noted that things that print the same are not necessarily eq to each
other. In particular, numbers with the same value need not be eq, and two similar.
lists are usually not eq. In general, two atomic SYOlbois with the same print-name
are eq, but it is possible with maknam or multiple obarrays to generate symbols which have the same print-name but are not. eq. Examples:
(eq 'a 'b) => nil
(eq 'a 'a) =) t
(eq , (a . b) , (a . b) l => nil (usually)
(eq (cons 'a 'b) (cons 'a 'b» =) nil (always)
(setq x ' ( a . b» (eq -x x) =) t since it is
the same copy of (a • b) in both arguments.
(setq x (setq y 17» (eq x y) => t or nil
depending-on the implementation. You can
never rely on numbers being eq.

c
equal

SUBR Z args
The equa 1 predicate returns t if its arguments are similar (isomorphic) objects.
(cf. eq) Two numbers are equal if they have the same value (a ftonum is never
equal to a fixnum though). Two strings are equal jf they have the same length,
and the characters composing them are the same. All other atomic objects are
equa 1 if and only if they are eq. For dotted pairs and lists, equa 1 is defined
recursively as the two car's being equal and the two cdr's being equal. Thus
equa 1 could have been defined by:

o

July 27, 1978

12-1.

Page 2-3

LLLZ-=,· ~.,

o

Mac1isp Reference Manual

(defun equal (x y)
(or (eq x y)
(and (numberp x) (numberp y) (numequal x
(and (not (atom x»
(not (atomy»
(equal (car x) (car y»
(equal (cdr x) (cdr y»»)

y»

if there was an auxiliary function for numeric equality:
(defun numequal (x y)
(and (eq (typep x) (typep y»
(zerop (difference x y»»
This numequa 1 function is not the same as the Mac1isp numeric-equality function,
=, because the latter only compares non-big numbers.
As a consequence of the above definition, it can be seen that equa 1 need not
terminate when applied to looped list structure. In addition;eq always implies
equa 1. An intuitive definition of equa 1 (which ,is not quite correct) is that two
objects are equa 1 if they look the same when printed out.

0

SUBR 1 arg

not

not returns t if its argument is nil, otherwise n i 1.

SUBR 1 arg

null

This is the same as not. Both functions are provided for the sake of clarity.
nu 11 should be used to check if something is nil' and return a logical value. not
should be used to invert the sense of a ,Jogic~1 value. Even though Lisp uses nil
to represent logical "false," you shouldn't make understanding your program
depend on this. For example, one often writes
(cond «not (null x»

•.• )

( .•• »

o
Page 2-4

!2-1.

July 27, 1978

--~

~.~~

~

-~~.~.~--.~-

....- ..

--~.-~---~~

--~--~--~

..

---~-~

.... ..
~

~--~-~.~------~

1

o

Predicates

rather than
(cond (x ••• )

( ... »
There is no Joss of efficiency since these will compile into exactly the same
instructions.

See also the number predicates (page 2-63).

July 27, 1978

12-1.

Page 2-5

o

Mac1isp Reference Manual

()

o
Page 2-6

l2-1.

July 27, 1978

The Evaluator

o
2.

The Evaluator
LSUBR 1 or 2 args

eval

( eva 1 x) evaluates x, as a. form, atomic or otherwise, and returns the result.
( eva 1 x p) evaluates x in the context specified by the binding context pointer p.
Example:
.
(setq x 43 foo /bar)
(eval (list /cons x /foo»
=> (43 • bar)

LSUBR 2 or 3 args

apply

( app ly f y) applies the function f to the list of arguments ,. Unless f is an
fsubr or fexpr, such as cond or and, which evaluates its arguments in a funny
way, the arguments in the list" are used' without being evaluated. Examples:

()

(setq f /+) (apply f /(12 3» => 6
(~etq f /_) (apply f /(1 2 3»
=> -4
(apply /cons
2 3) 4») =>
« + 2 3) . 4) not (5 • 4)

/«+

(apply f" p) works like apply with two arguments except that the application
is done with the Yari~ble bindings specified by the binding context pointer p.

FSUBR

quote

The special form (quote x) returns x Without trying to evaluate it.. quote is
used to include constants in a form. For convenience, the read function normally
converts' any S-expression preced'ed by the apostrophe or acute accent character ('>
into the quote special form. For example,
(setq x /(some list»
is converted by the reader to:

o

July 27, 1978

l2-2.

Page 2-7

" " ' _.... !iG;,mJt"=a;;;iA:m&J."'-1;MMAli·;;;:;~

#;

#¥.M. ,

¥ ,·,4 447.Q# .. 'r:,'

o

Maclisp Reference Manual

(setq x (quote (some list»)
which when evaluated causes the variable x to be set to the constant list value
shown. For more information on input syntax, see the detailed discussion in part
5.1.
Quote could have been defined by: ,
(defun Quote fexpr (x) (car x»

function

FSUBR

funct i on is like quote except that its argument is a functional expression. To
the interpreter, ~uote and funct i on are identical, but th,e compiler needs to be
able to distinguish between a random piece of data. which should be left alone,
and a function, which should be compiled into machine code. Example:
(mapcar (function (lambda (p Q)
(cond «eq p '.) q)
(t (list p '= q»
first-ljst-of-things
(compute-another-1ist) )

c
»)

calls mapcar with three arguments, the first of which is the function defined by
the. 1ambda-expression. The actual value passed to mapcar depends on whether
the form has been compiled. If it is interpreted, the 1ambda-expression written
above will be passed. If it is compiled, an automatically-generated atomic symbol
with the compiled code for the 1ambda-expression as its subr property will be
passed. The usual thing to do with functional arguments is to invoke them via
app ly or funca 11, which accept both the compiled and the interpreted functional
forms.
function makes no attempt to solve the "funarg problem." .function should be
used for this purpose.

o
Page 2-8

------.~--

~2-2. '

July 21, 1918

o

The Evaluator
.function

FSUBR

The value of (*funet ion· f) is a "funarg" of the function f. A funarg can be
used like a function. It has the additional property that it contains a binding
context pointer so that the values of variables are bound the same during the
app~ication of the funarg as at the time it was created, provided that the binding
environment in which the funarg was created still exists on the stack. Hence if
foo is a function that a~cepts a functional argument, such as
(defun foo (f)
(append one-value (f the-other-value)

»

or, better
(defun foo (f)
(append one-value (funeall f the-other-value)

»

then
(foo (.function bar»

o

works, but
(foo, (pr.og (x y z)
(do something,)
(return (.function bar»

»

does not if bar intends to reference the prog variables x ,y, and z.
*funct ion is intended to help solve the "funarg problem; however it only works
in some easy cases. Funargs generated by *funet i on are intended for use as
functional arguments and cannot be returned as values of functional applications.
Thus, the user should be careful in' his use of .funct 1on to make sure that his
. use does not exceed the limitations of the Maclisp funarg mechanism.
It is possible to assign a value to a variable wh~n a previous binding of that
variable has been made current by a funarg. The assignment win be executed in
the proper context. (This has not always been the case in. Maclisp; it is a fairly
new feature.)
A funarg has the form

(funarg function. context-ptr)

o

July 27, 1978

12-2.

Page 2-9

;

"

o

Maclisp Reference Manual

FSUBR

comment

comment ignores its arguments and returns the atomic symbol connent.
Example:
(defun foo (x)
(cond «~ull x) 0)
(t (comment x has something 'in it)
(1+ (foo (cdr x»»»
, Usually it is preferable to comment code using the semicolon-macro feature of the
standard input syntax. This allows the user to add comments to his code which
are ignored by the lisp reader.
Example:
(defun foo (x)
(cond «null x) 0)
(t (1+ (foo (cdr x»»

;x has something in it

))

o

A problem with such comments is that they are discarded when the S-expression is
read into lisp. If it is edited within lisp and printed back into a file. the
commen~s win be lost. However, most users edit the original file and read the
changes into lisp, since this allows them to use the editor of their choice. Thus
this is not a real problem.

lSUBR 2 or more args

prog2

The expressions in a prog2 form are evaluated from left to right. as in any Isubr...
form. The ·result is the second argument. prog2 is most commonly used to
evaluate an expression with side effects, then return a value which needs to be
computed before the side effects happen.
Ex~mples:

(prog2 (do-this) (do-that»

;just get 2 things evaluated

(setq x (prog2 ni,l y
;para11el assignment
(setq y x») ;which exchanges x and y
(defun prog2 nargs (arg 2»

;a lexpr definition for prog2

01

I
I

l2-2.

Page 2-10

---.~- ..

--.-----.-------- ----- .. _--_. __ .. -- ........... _--------_ ..._----_

..

July 27. 1978

o

The Evaluator

progn

lSUBR 1 or more args

The expressions in a progn form are evaluated from left to right, as usual, and
the result is the .value of the last one. In other words, progn is an Isubr which
does nothing but return its last argument. Although 1ambda-expressions, progforms, do-forms, cond-forms, and iog-forms aU use progn implicitly, that is, they
allow multiple forms in their bodies, there are occasions when one needs to
evaluate a number of forms for side-effects and make them appear to be a single
form. progn serves this purpose. Example:
(progn (setq a (cdr frob»

(eq (car a) (cadr a»)

might be used as the antecedent of a cond clause.
progn could have been defined by:
(defun progn nargs
(and (> nargs 0)
(arg nargs»)

o

FSUBR

progv

progv is a special form to provide the user' with extra control over lambdabinding. It binds a list of variables to a list of values, and the~ evaluates some
forms. The lists of variables and values are computed quantities; this is what
makes progv different from lambda, prog, and do.
(progv var-itst value-list forml form2 ••• )
first evaluates var-list and value-list. Then the variables are bound to the values.
In compiled code the variables must be special, since the compiler has no way of
knowing what symbols might appear·· in the var-list. If too few values are
supplied, the remaining variables are bound to nil. If too many values are
supplied, the excess values are ignored.
After the variables have been bound to the values, the forms are evaluated, and
finally the variable bindings are undone. The result returned is the value of the
last form. Note that the "body" of a progv is similar to that of progn, not that of
prog.
Example:

o

July 27, 1978

12-2.

Page 2-11

_.....

,;

o

Maclisp Reference Manual

(setQ a 'foo b 'bar)
(progv (list a b 'b) (list b) (list a b foo bar»
=> (foo nil bar nil)
During the evaluation of the body of this progv, foo is bound to bar, bar is
bound to ni 1, b is bound to ni 1, and a remains bound to foo.

SUBR 1 arg

arg

, (arg nil), when evaluated during the application of a lexpr, gives the number
of arguments supplied to that lexpr. This is primarily a debugging aid, since
lexprs also receive their number of arguments as the value of their 1ambdavariable.
(arg i), when evaluated during the application of a lexpr, gives the value of the
i'th argument to the lexpr. i must be a fixnum in this case. It is an error if t is
less than I or greater than the number of arguments supplied to the lexpr.

o

Example:
(defun foo nargs
(print (arg Z»
(+ (arg 1)
(arg (- nargs 1»»

setarg

;define a I!!xpr foo.
;print the second argument.
; return the sum of the first
;and next to last arg~ments.

SUBR Z args

setarg is used only during the application of a lexpr. (setarg t x) sets the
lexpr's i'th argument to x. t must be greater than zero and not greater than the
number of arguments. passed to the lexpr. After (setarg t x) has been done,
(arg t) will return x.

o
Page 2-12

---------------

l2-2.

-

------------~-------------

July 27, 1978

-

--------~-----------~----

,

o

.

The Evaluator'

11stify

SUBR 1 arg

( 1 is t i fy n) efficiently manufactures a list of' n of the arguments of a lexpr.
With a positive argument n, it returns a list of the first n arguments of the lexpr.
With a negative .argument n, it returns a list of the last (abs n) arguments of
the lexpr. Basically, it works a~ if defined as follows:
(defun l1st1fy (n)
(cond «m1nusp n)
(11st1fyl,(arg nil) (+ (arg nil) n 1»)
(t

(11st1fyl n 1»

»

'(defun 11stifyl (n m)
; auxi1iary.function.
(do «1 n (1- i»
(result nil (cons (arg 1) result»)
«< 1 m) result) »

funca11

lSUBR 1 or more args

( funca 11 f al a2 ... an) calls the function f with the arguments aI, 42, ..., 4~. It
is similar to app 1y except that the, separate arguments are given to funea 11, .
rather than a list of arguments. If f is a fexpr or an fsubr there must be exactly
one argument. f may not be a macro. Example:
(setq cons 'plus)
(cons 1 Z) => (1 . 2)
(funcal1 cons 1 2) => 3

subrca11

FSUBR

subrca 11 is used to invoke a subr-pointer directly, rather than by referring to an
atomic sym~ol of which the subr-pointer is the subr property. The form is:
( subrca 11 type p 41 42 ... an)

A11 arguments except the first are evaluated. t'!Pe is the type of result expected:
fixnum, f1onum, or ni 1 (any type). P is the subr pointer to be caned. 41
through an are the arguments to be passed to the subr. subrea 11 compiles into
efficient machine code.

o

July 27, 1978

12-2.

Page 2-13

iQiiiiiQ"ii&"MMbQTA:;;;;;:g4MNiAAlM!L#@-_;;l,#MlfHliffl\/£ifHYfiiff&?f4H\N]i6AGF¥/i!.M 7 ",:.

o

Mac1isp Reference Manual

lsubrcal1

FSUBR

1subrca 11 is identical to subrca 11 except that the subr-pointer called has to be
an 1subr instead of a subr. This is because many Lisps use different internal
caning sequences for lsubrs than for subrs.

arraycall

FSUBR

arrayca 11 is similar to subrca 11 and 1subrca 11 except that an array-pointer
is used instead of a subr-poi'nter. The first argument of arrayca 11 must
correspond to the type that the array was given when it was created. An
arrayca 11 expression may be used as the first argument to store.

o

Page 2-14

12-2.

July 27, 1978

o

Manipulating List Structure

3.

Manipulating List Struoture

3.1

Conses
SUBR 1 arg

car

Returns the first component of a cons.
E~ample:

(car ~(a b»

=> a

SUBR 1 arg

cdr

Returns the second component of a cons.
Example:

(cdr ~(a be»

=> (b c)

CI
. car

SWITCH

cdr

SWITCH
Officia11y car and cdr are only applicable to lists. However, as a matter of
convenience the car and cdr of nil are n 11. This allows programs to car and
cdr off the ends of lists without having to check, which is sometimes helpful.
Furthermore, some old programs apply car and cdr to objects other than lists in
order to hack with the internal representation. To provide control over this, the
value of car can be set to control which data types are subject ,to the car operation.
Similarly, the value of cdr controls the cdr operation .. Illegal operations will
cause errors. For reasons of efficiency, this error checking is only ,enabled in
(*r set t) mode (see page 3-29) and is mostly turned off, in compiled programs.
The values to which the switches may be set are:

o

Value

Operation applicable to

list
ni 1
symbol

lists.
'lists and 'n i 1.
lists, nil, and symbols.
anything.

t

july .27, 1978

l2-3.

Page 2-15

o

Mac1isp Reference Manual

The default value of the switches is n i 1.

SUBR 1 arg

c ... r

An the compositions of up to four car's and cdr's are defined as functions In
their own right. The names begin with c and end with r, and j~ between is a
sequence of' a's and d's corresponding to the composition performed by the
function.
For example,
(cddadr x) = (cdr (cdr (car (cdr x»»
Some of the most commonly used ones are: cadr, which gets the second element of
a list; caddr,which gets the third element of a list; cadddr, which gets the fourth
element of a list; caar, to car'twice.
The car'ing and edr'ing operations of these functions have error checking under
the control of the car and cdr switches explained above, Just as the car and cdr
functions themselves do.

o

, ·SUBR Z args

cons

This is a primitive function to construct a new dotted pair whose car is the first
argument to cons, and whose cdr is the second argument to cons. Thus the
following identities hold (except when numbers are involved; as always numbers
are not well-behaved with respect to eq):

(eq (car (cons x y» x) ,=) t
(eq (cdr (cons x y) y) =) t
Examples:
(cons /a /b) =) (a .b)
(cons /a (cons /b (cons /e nil») =) ~a b c)
(cons /a /(b c d e f» =) (a bed e f)

SUBR 1 arg

neons

(neons x) = (cons x nil) = (1 i ~t x)

o
Page 2-16

!2-3.1

July 27, 1978

c

Manipul3:ting List Structure

xcons

SUBR 2 args
xcons ("exchange cons") is .like cons except that the order of arguments is
reversed.
Example:
(xcons /a /b) => (b • a)

o

July 27, 1978

12-3.1

Page 2-17

&C&ilAMMilJ9I&GMiiIM'iMfi!Al&WAMWM&WII1QW:;;!MIiJ& fHA-It i4

,;#4r .,.,..,

~
I
I

,I
I

!

o

. Maclisp Reference Manual

3.2

Lists
SUBR 1 arg

last

last returns the last cons of the list which is its argument.
Example: .
(setq x '(a bed»
(last x) => (d)
(rplacd (last x) '(e f»
x => (a b c d e f)

last could have been defined by:
(defun last (x)
(cond «null x) x)
«null (cdr x» x)
«last (cdr x») »
In some implementations, the null check above may be replaced by an atom check,
which will catch dotted lists. Code' which depends on this fact should not be
written though, because an implementations are subject to .change on this point.

0

1

SUBR 1 arg

length

1ength returns the length of its argument, which must be a list. The length of a
list is the number of top-level conses in it.

Examples:
(length nil) => 0
(length '(a bed» => 4
(length '(a (b c) d» => 3
length could have been defined by:

o
Page 2-18

l2-3.2

July 27, 1978

o

Manipulatin.g List Structure

(defun length (x)
(cond «null x) ~)
«1+ (length (cdr x»»
or by:

»

(defun length (x)
(do «n 0 (1+ n»
(y x (cdr y»)
( (nu 11 y). n) »
The warning about dotted lists given under last applies also to length.
1 1st.

lSUBR 0 or more args
1 is t constructs and returns a list of its arguments.

c

Example:
(list 3 4 ~a (car ~(b • c»

(+ 6 -2»

=)

(3 4 a b 4)

1 i st could have been defined by:

(defun list nargs
(do «n nargs (1- n»
(s nil (cons (arg n) s»)
( (zerop n) s) »
(This depends on parallel assignment to the control variables of do.)
append

lSUBR 0 or more args

The arguments to append are lists. The result is a list which is the concatenation
or the arguments. The arguments are not changed (cr. nconc). For example,
,

(append ~(a b c) ~(d e f) nil ~(g»

=)

(a bed e fg)

To make a copy of the top level of a list, that is, to copy the list but not its
elements, use (append x nil).

o

July 27, 1978

. 12-3.2

P.age 2-19

~I
,I
I
I

il

o

III

Mac1isp Reference Manual

II
'I
I

A version of append which only accepts two arguments could have been defined by:

I

(defun append2 (x y)
(cond «null x) y)
«co'ns (car x) (append2 (cdr x)y»

»)

The generalization to any number of arguments could then be made using a lexpr:
(defun append argcount
(do «1 (1- argcount) (1- 1»
(val (arg argcount) (append2 (arg i) val»)
«zerop 1) val) »

SUBR 1 arg

reverse

Given a list as argument, reverse creates a new list whose elements are the
e1ements of ~ts argument taken in reverse order. reverse does not modify its
argument, unlike nreverse which is faster but does modify its argument.
Example:
(reverse /(a b (c d) e»

o

=> (e (c d) b a)

reverse could have been defined by:
(defun reverse (x)
(do «1 x (cdr 1»
'(r nil
(cons (car 1) r»)
«null 1) r»)

; scan down argument,
; putting each ~Iement
; into list, until
; no more elements.

lSUBR 0 or more args

nconc

nconc takes lists as arguments. It returns a list which is the arguments
concatenated together. The arguments are changed, rather than copied. (cf.
append)
Example:
(nconc /(a b c) /(d e f»" => (a bed e f)
Note that the constant (a be) has now been changed to (a bed e f). If

Page 2-20

l2-3.2

July 27, 1978

o

0 ',

Manipulating List Structure

"

this form is evaluated again, it will yield (a bed e' f d e fl. This is a
danger you always have to watch out for when using ncone.
nconc could have been defined by:
(defun ncone (x y)
;for simplicity, this definition
(cond « nu 11 x) y) ;only works for 2 arguments.
(t (rp1acd (last x) y) ;hook y onto x
x)))
. ; and return the modified x.
nreverse

SUBR 1 arg

nreverse reverses its argument, which should be a list. The argument is '
destroyed by rp 1acd's all through the list (cr. reverse).
Example:
(nreverse '(a be»

=> (c 'b a)

nreverse could have been defined by:

o

(defu~ nreverse

(x)
(cond «null x) nil)
«nreversel x nil»»

(defun nreversel (x y)
;auxiliary function
(cond «(null (cdr x» (rp1acd x y»
«nr'eversel (cdr x) (rp1acd x
; ; this last call depends on order of argument evaluation.

y»»)

nreconc

SUBR 2 args

(nreconc x '1) is exactly the same as (ncone (nreverse x) ,) except' that it
is more efficient.
nreconc could have been defined by:
(defun nreconc (x y)
(cond «null x) y)
«nreversel x

y»

»

using the same nrever se 1 as above.
July 27, 1978

12-3.2

Page 2-21

o

Maclisp Reference Manual

3.3

Alteration- of List Struoture

The functions rplaca and rplacd are used to make alterations in already-existing
list structure. The structure is not copied but physically altered; hence ~ution should be
exercised when using these functions as strange side-effects can occur if portions of list
structure become shared unbeknownst to the programmer. The nconc, nreverse, and
nreconc functions already described have the same property. However, they are
normally not used for this Side-effect; rather, the list-structure modification is purely for
efficiency and compatible non-modifying functions are provided.

SUBR 2 args

rplaca

( rp 1aca x,) changes the car of x to , and returns (the modified) x. Example:
(setq g '(a be»
(~placa

(cdr g) 'd) => (d c)

o

Now g => (a d c)

SUBR 2 args

rplacd

(rp 1acd x,) changes the cdr of x to , and returns (the modified) x. Example:
(setq x '(a be»
(rplacd x'd) => (a • d)
N ow x => (a • d)
S~e also setpl 1st (page 2-55).

SUBR 3 args

subst

( subs t x , %) substitutes x for all occurrences of, in %, and returns the modified
copy of %. The original % _is unchanged, as subst recursively copies all of %
replacing elements eq to , as it goes. If x and , are nil, % is just copied, which
is a convenient way to copy arbitrary list structure~

-

o
12-3.3

- Page 2-22

-

----------_.. ----_.----_._-

---~~~----

July 27, 1978

----~---.------.-----------------

I

o

Manipulat,ing List Structure

Example:
(subst 'Tempest 'Hurricane
'(Shakespeare wrote (The Hurricane»)
=> (Shakespeare wrote (The Tempest»
subst could have been defined by:
(defun subst (x y z)
(cond « eq z y) x)
;Af item eq to y, replace.
( (atom z) z)
-, ;if no substructure, return argo
«cons (subst x y (car z»
;otherwiserecurse.
(subst x y (cdr z»»»

SUBR 2 args

sublis

o

sub 1 is makes substitutions for atomic symbols in an S-expression. The first
argument to sub 1 isis an association list (see the next section). The second
argument is the S-expression in which substitutions are to be made. sub 11 s looks
at ~ 11 atomic symbols in the S-expression; it an atomic symbol appears in the
association 'list occurrences of it are replaced by the object it is associated with.
The argument is not modified; 'new conses are created where necessary and only
where necessary, so the newly created structure shares as much. of its substructure
as possible with the old. For example, if no substitutions are made, the result is
eq to the old S-expression.
Example:
(sublis

'«x. 100) (z .• zprime»

'(plus x (minus g z x p) 4»
=> (plus 100 (minusg zprime 100 p) 4)

In some implementations subl is works by putting temporary sub11s properties
on the atomic symbols in the dotted pairs, so beware.

o
July 27, 1978

l2-3.3

Page 2-23

o

Maclisp Reference Manual

3.4

Tables

M aclisp includes several functions which .simplify the maintenance of tabular data
structures of several varieties. The simplest is a pla.in list of items, which models
(approximately) the concept of a set. There are functions to add (cons), remove
(delete, delq), and search for (member, memq) items ina list.

Association li$ts are very commonly used. An association list is a list or dotted pairs.
The car of each pair is a "key" and the cdr is "data". The functions assoc and assq.
ma y be used to retrieve the data, given the key.
Structured records can be stored as association lists or as stereotyped S-expressions
where each element of the structure has a certain car-cdr path associated with it. There
are no built-in functions for these but it easy to define macros to implement them (see
part 6.2).
.
. Simple list-structure is very convenient, but may not be efficient enough for large
data bases because it takes a long time to search a long list. MacUsp includes some
hashing functions (sxhash, maknum) which aid in the construction of more efficient,
hairier structures.

member

o

SUBR Z args

(member x ,) returns nil if x is not a member of the list ,. Otherwise, it
returns the portion of , beginning with the first occurrence of x. The comparison
is made by equa 1. ,is searched on the top level only.
Example:

(member /x /(1 Z 3 4» => nil
(member /x /(a (x y) c x d e x f»

=> (x d e x f)

Note that the value returned by member is eq to the portion of the list beginning
with x. Thus rp 1aca on the result of member may be used, if you first check to
make sure member did not return n1 l.
Example:
(catch (rp1aca (or (member x z)
(throw nil lose»
y)

lose)
Page 2-24

July 27, 1978

l2-3.4

........- - - -...- . - . -•.........- . - .............

-~

..

~-.--------

o

Manipulating List Structu,re

o

member could have been defined by:
(defun member (x y)
(cond «null y) nil)
«equal x (car y» y)
. «member x (cdr y») »

SUBR 2 args

memq

memq is like member, except eq is used for the comparison, instead of equal.
me~q could have been defined by:
(defun memq (x y)
(cond «null y) nil)
«eq x (car y» y)
«memq x (cdr y») »

lSUBR 2 or 3 args

delete

( de 1ete x ,,) returns the list , with all top-level occurrences of x removed.
equal is used for the comparison, The argument , Is actually modified
(rplacd'ed) when instances of x .are spliced out. delete should be used for
value. not for effect. That is, use
(setq a (del~te 'b a)
rather than
(delete 'b a»

The latter is not equivalent when the first element of the value of a is b.
( de 1ete x , n) is like (delete x ,) ~xcept only the first n instances of x are
deleted. n is allowed to be zero. If n is greater than the number of occurrences or
x in the list, all occurrences of x in the list will be deleted.
Example:
(delete 'a '(b a c (a b) d a e»

July 27, 1978

'12-3.4

=> (b c (ab) d e)
Page 2-25

o

Mac1isp Reference Manual

delete could have been defined by:
(defun delete nargs
; lexpr for 2 or S args
(dele~el (arg I)
; pass along arguments...
(arg Z)
(cond «= nargs 3) (arg 3»
( 123456789. » » ; infinity
(defun'deletel (x y n)
;auxiliary function
(cond «or (null y)' (zerop n» y)
,
«equal x (car
(deletel x
(cdr y)

y»

(1- n»)

«rplacd y (deletel x (cdr y) n»»)

lSUBR 2 or 3 args

delq

de 1q is the same as de 1ete except that eq is used for the comparison instead of
equal.
.

sxhash

0,

SUBR 1 arg

sxhash computes a hash code of an S-expression, and returns it as a fixnum,
which may be positive or negative. A property of sxhash is that (equal x y)
implies (= (sxhash x) (sxhash
The number returned by sxhash is some
possibly large number in the range allowed by fixnums. It is guaranteed that:

y».

I) sxhash for an atomic symbol will always be positive.

2) sxhash of any particular expression win be constant in a particular

implementation for all time, probably.
3) Two different implementations may hash the same expression into different

values.
4) sxhash of any object of type random will be zero.
5) sxhash of a fixnum will = that fixnum.

o
Page 2-26

12-3.4

july 27, 1978

Manipulating List Structure

o

Here is an example of how to use sxhash in maintaining
hash tables of S'-~xpressions:
(defun knownp (x)
;look up x in the table
(prog (1 bkt)
(setq i (plus 76 (remainder (sxhash x) 77»)
;The remainder should be reasonably randomized between
~-76 and 76, thus ta~le size must be ) 175 octal.
(setq bkt (table i»
. ;bkt is thus a list of all those expressions that hash
;into the same number as does x.
(return (member x bkt»»
To write an "intern" for S-expressions, one could
(defun sintern (x) .
(prog (bkt item)
(setq bkt (table (setq i (+ 2n-2 (\ (s~hash x) 2n-l»»)
;2n-l and 2n-l stand for a power of 2 minus one and
;minus two respectively. This is a good choice to
;randomize the result of the remainder operation.
(return (cond «setq tem (member x bkt»
(car tem»
(t (s~ore (table 1) (cons x bkt»
x»»)

o
assoc

SUBR 2 args

(assoc x '1) looks up x in the association 'list (list of dotted pairs) ,. The value
is ttae first dotte~ pair whose car is equal to x, or n11 if there is none such.
Examples:
(assoc ~r ~«a • b) (c • d) (r • x) (s • y) (r • z»)
=)

( r . x)

(assoc ~fooo ~«foo • bar) (zoo. goo») =) nil
It is okay to rplacd the result of assoc as long as it is not nil, if your intention
is to "update" the "table" that was assoc's second argument

o

July 27, 1978

1,2-3.4

Page 2-27

o

Maclisp Reference Manual

Example:
(setq values "«x. 100) (y • 200) (z. 50»)
(assoc "y values) => (y • 200)
(rplacd (assoc 'y values) 201)
(assoc "y values) => (y • 201) now
(One should always be careful about using rplacd however)
A typical trick is to say (cdr (assoc x y». Since the cdr of nil is
guaranteed to be n 11. this yields n 11 if no pair is found (or jf a pair Is found
whose cdr is n 11.)

assoc could have been defined by:
(defun assoc ·(x y)
(cond «null y) nil)
«equal x (caar y» (car y»
«assoc x (cdr y»).» .

o

SUBR 2 args

assq

assq is like assoc except that the comparison uses eq Instead of equal. assq
could have been defined by:
(defun assq (x y)
(cond «nu)l y) n11)
«eq x (caar y» (car y»
«assq x (cdr y») »

sassoc

SUBR 3 args

(sassoc x 'J z) is like (assoc x 'J) except that' if x Is not found In " Instead of
returning n 11 sassoc calis the function % with no arguments. sassoc could
ha ve been defined by:
(defun sassoc (x y z)
(or (assoc x y)
,(apply z'ni1»)
sassoc and sassq (see below) are of limited use. These are primarily leftovers
from Lisp 1.5.
Page 2-28

12-3.4

July 27, 1978

o

Manipulating List Structure

sassq

SUBR 3 args
(sassq x , z) is like (assq x 'j) except that if x is not found in 'j, instead of
returning nil sassq calls the function % with no arguments. sassq could have
been defined by:
.
(defun sassq (x y z)
(or (assq x y)

(apply z nil»)
maknum

SUBR 1 arg

(maknum x) returns a positive fixnum which is unique to the object X; that is,
(maknum x) and (maknum y) are numerically equal if and only if (eq x y).

This can be used in hashing.
In the pdp-IOimplementations, maknum returns the memory address of its
argument. In the M ultics implementation, an interna1 hash table is employed.

o

Note that unlike sxhash, maknum win not return the same value on an expression
which has been printed out and read back in again.

munkam

SUBR 1 arg

mun kam is the opposite of maknum. Given a number, it returns the object which
was given to maknum to get that number. It is inadvisable to apply munkam to a
number which did not come from maknum.

o

July 27, 1978

12-3.4.

Page 2-29

f

•

o

Maclisp Reference Manual·

3.5

Sorting

Several functions are proyided for sorting arrays and lists. These functions use
algorithms which always terminate no matter what sorting predicate is used, provided
only that the predicate always terminates. The array sort is not necessarily stable, that
is equal items may not stay in their original order. However the list sort ts stable.
After sorting. the argument (be it list or array) is rearranged internally so as to be
completely ordered. In the case of an array argument. this is accomplished by permuting
the elements of the array, while in the list case, the list is reordered by rplacd's in the
same manner as nreverse. Thus if the argument should not be clobbered, the user must
sort a copy of the argument, obtainable by f1 llarray or append, as appropriate.
Should the comparison predicate cause an error, such as a wrong type argument
error, the state of the list or array being sorted is undefined. However, if the error is
corrected the sort Will, of course, proceed correctly.
Both sort and sortcar handle the case in which their second argument is the
function alpha 1~ssp .in a more efficient manner than usual. This efficiency is primarily
due to elimination of argument checks. at comparison time.

sort

o

SUBR Z args

The first argument to sort is an array (or list), the second a predicate of two
arguments. Note that a "number array" cannot be sorted. The .predicate must be
applicable to all the objects in the 'array or list. The predicate should take two
arguments, and return non-nil if and only if the first argument is strictly less
than the second (in some appropriate sense).
The sort function proceeds to sort the contents 'of the array or list under the
ordering imposed by the predicate, and return's the array or list modified into
sorted order, i.e. its modified first argument. Note that since sorting reqUires
many comparisons, and thus many caUs to the predicate, sorting win be much
faster if the predicate is a compiled function rather than interpreted.

o
Page 2-30

12-3.5

July 27, 1978

o

Manipulating List Structure

Example:
(defun mostcar (x)
(cond «atom x) x)
«mostcar (car x»»))
(sort·'fooarray
·(function (lambda (x y)
(alphalessp (mostcar x) (mostcar y»»)
If fooarray contained these items before the sort:

(Tokens (The lion sleeps tonight»
(Carpenters (Close to you»
«Rolling Stones) (Brown sugar»
«Beach Boys) (1 get around»
(Beatles (1 want to hold your hand»

c

then aft~r the sort fooarray would contain:
( (Beach Boys) (1 ge.t around»
(Beatles (I want to hold your hand»
(Carpenters (Close to you»
«Rolling Stones) (Brown sugar»
(Tokens (The lion ·sleeps tonight»
sortcar

SUBR Z args

sortcar is exactly like sort, bu~ the items in. the array or list being sOrted
should aU be non-atomic. sortcar takes the car of ~ch item before handing two
items to the predicate. Thus sortcar Is. to sort as mapcar is to map 11 st.

c

July 27, 1978

. 12-3.5

Page 2-31

'0

Maclisp Reference Manual

8.8

Hunks

This section applies only to the pdplO implementation.
Hunks are a generalization of conses, useful in constructing more efficient data
structures. A hunk is like a cons but it has more components; hunks come in several
convenient sizes. The advantage of an n-element hunk over an n-element list is that the
hunk occupies less space (half as much if n is a power of 2). The elements of a hunk
can be referenced more efficiently than the elements of a list, since the compiler knows the
relative Iqcations of the components and addresses them directly.
.The ad vantage of lists over hunks is flexibility; lists can be any length. can vary in
length, can be altered by rp 1acd, and can be manipulated with a library of useful
searching, sorting, and combining operations, previously described in this chapter.
. Another feature of hunks is that at times one may treat a hunk as a cons, Ignore the
extra components. This allows the construction of list structure which has extra ·frobs·
stuck on at certain points. The atom' function does not consider hunks to be atomiC; it
returns nil if given a hunk.
print represents hunks using an extended form of dot-notation; read however does
not yet understand this notation. See the writeup on print.

o

lSUBR 0 or more args

hunk

hunk takes any number of arguments, and ,returns a hunk whose components are
the arguments. The first argument is the car, and the last is the cdr; that is, the,
, arguments are in the order I, 2, 3, ..., N-J, O. This is the same order as print
and makhunk use.
The maximum size of a hunk is 128 components.
implementation to implementation.

This may vary from

With no arguments, hunk returns n1 1. With one or two arguments, hunk returns
a cons.

o
Page 2-32 '

12-3.6

July 27. 1978

o

Manipulating List Structure

SUBR 2 args

cxr

(cxr n ") returns then'th component of the hunk Ia. car of a hunk returns the
1st component, and cdr of a hunk. returns the Oth component.

rplacx

SUBR 3 args

(rplacx n h z) replaces the n'th component of the hunk A with z. The value of
rp 1acx is its (modified) second argument. rp 1aca of a hunk replaces its 1st
component, and rp 1acd of a hunk replaces its Oth component..

makhunk

SUBR 1 arg

(makhunk n), where n is a fixnum, creates and returns an n-element hunk, filled
(makhunk I), where I ,is a list, creates and returns a hunk of the
appropriate length, initialized from t. This like (app ly 'hunk I).
with nils.

is

Like hunk, makhunk win return nil or a cons if you ask for a hunk of 0, 1, or 2
elements.

hunks1ze

SUBR 1 arg

hunksize returns the number of components in its argument. hunks1ze of nil
is 0 and hunks 1ze of a cons is 2.

VARIABLE

hunkp

If the value of hunkp is ni 1, the functions print, equal, and purcopy treat
hunks as conses, as most other system functions do. The extra elements are simply
ignored. If the value of hunkp is non-n i 1, which is the default, these three
functions deal with aU the elements. sxhash always deals with all the elements.

July 27, 1978

12-3.6

Page 2-33

o

Maclisp Reference Manual

o
Page 2-34

l2-3.6

July 27, 1978

Flow of Control

4. . Flow of Control
M ac1isp provides a variety of structures for How of control.
Functional application is the basic method for construction of programs. An
operations are written as the application of a function to arguments. Maclispprograms
are often written as a large collection of small fUnctions which implement simple .
operations. Some of the functions work' by calling others of the functions, thus defining
some operations in terms of others.
Recursion exists when a function calls itself. This is analogous to mathematical
induction.
Iteration is a control structure present in most languages. It is simi1ar to recursion
but sometimes less useful and sometimes more useful. M aclisp contains a generalized
iteration facility.' The iteration facility also permits those who like "gotos" to use them.

C"
,

'

Conditionals allow control to branch depending on the value of a predicate. and and
or are basically one-arm conditionals, while cond is a generalized multi-armed
conditional.
Nonlocal exits are similar to a return, except that the return is from several levels of
function caning rather than just one~ and is determined at run time. These are mostly
used for applications such as escaping from the middle of a function' when it is
discovered that the algorithm is not applicable.
Errors are a type of non-local exit us~ by the Lisp interpreter when it· discovers a
condition that .it does not like. Errors have the additional feature of correctability. which
anows a user-specified function (most often a break IQOp), to get a chance to come in and
correct the error or at least inspect what was happening and ,determine what caused it,
before the non local exit occurs. This is explained in detail on part 3.4.

Madisp does not directly provide "hairy control structure" such as multiple processes,
backtracking, or continuations.

o

july 27. 19;8

12-4.

Page 2-35'

XLiii1iWiEWAN_ntMlAM&iIMdIb=;;;MYW-JlYPLmLWAlttillitIM, M"' ffi4A\f1P,

4, ;,; '\fI!Gff¥4Pi/AifTh, mnf2¥ qz;;:; •. " "

o

Mac1isp Reference Manual
I
'II
I

. 4.1

Conditionals
FSUBR

and

(and form! form2 ••. ) evaluates the forms one at a time, from left to right. If
any form evaluates to ni 1, and immediately returns nil without evaluating the
remaining forms. If an the forms evaluate non-n il, and returns the value of the
last one. and can be used both for logical operations, where ni 1 stands for False
and t stands for True, and asa conditional expression.
Examples:
(and x y)
(and (setq temp (assq x y»
(rp1aed temp z»
(and (nu11.(errset (something»)
(prine "There was an error."»
Note: (and) => t, which is the identity for this operation.

FSUBR

or

(or form! form2 ••• ) evaluates the forms one by one from left to right. If a form
evaluates to nil, or proceeds to evaluate the next form. If there are no more
forms, or returns n1l. But if a form evaluates non-nil, or immediately returns
that value without evaluating any remaining forms. or can' be used both for
logical operations, where n 11 'stands for False and t for TrUe, and as a
conditional expression.
Note: (or) => nil, the identity for this operation.

FSUBR

cond

The cond special form consists of' the word eond fonowed by several clauses.
Each clause consists of a predicate followed by lero or more forms. Sometimes the
predicate is called the antecedent and the forms are called the consequents.

o
Page 2-36

l2-4.1

~~---------~-------------

July 27, 1978

Flow of Control

o

(.cond (antecedent consequent consequent . •• )

(antecedent .... )

. :. )

The idea is that each clause represents a case which is selected if its predicate is
satisfied and the predicates of aU' preceding clauses are not satisfied. When a
case is selected, its consequent forms are evaluated.
cond processes its clauses in order from left to right. First the predicate of the
current clause is evaluated .. If the result is nil, cond advances to the next
clause. Otherwise, the cdr of the clause is treated as a list of forms, or
consequents, which are evaluated in order from left to right. After evaluating the
consequents, cond returns without inspecting any remaining c1auses. The value •
of the cond special form is the value of the last consequent evaluated, or the value
of the antecedent if there were no consequents in the clause. If cond runs out of
clauses, that is, if every antecedent is nil, that is, if no case is selected, the value
of the cond is n i 1.

o

Example:
(cond «zerop x)
(+ y

3»

«null y)
(setq x 4)
(cons x z»
(z)
)

;Flrst clause:
; (zerop x)is antecedent.
; (+ y 3) is consequent.
;A clause with Z consequents:
; this
; and this.
;A'clause with no consequents:
; the antecedent is just z.
;This is the end of the condo

This is like the traditional Lisp 1.5 cond excep~ that' it is not necessary to have
exactly one consequent in each clause, and it is permissible to run out of clauses.

o

July. 27, 1~78

12-4.1

Page 2-!47

&IIIliiVOMAANW:;;;;;44PiM UtA

#.

RfMI

A ~,,~'

'!

tII
I

o

Mac1isp Re~erence Manual

4.2

Iteration

prog

FSUBR

prog is the "program" special form. It provides temporary variables, sequential
evaluation' of statements, and the ability to do "gotos."A prog looks something
like:
.
(prog (varl var2 • •• )
tagl
statementl
statement2
tag2
statement]
)

varl, var2, ... are temporary variables. When the prog is entered the values of
these. variables are saved. When the prog is exited they are restored. The
variables are initialized ton 11 when the prog is entered, thus they are said to be
"bound to nil" by the prog. However, variables which have been declared .fixnum
or flonurn will be initialized to 0 or 0.0 instead, but only in compiled programs.
You should be careful about relying on the initial va·lue of prog-variables.

o

The part of a prog aft~r the temporary variable list is the body. An item in the
bod y rna y be an atomic symbol or a number, which is a tag, or a 'non-atomic form,
which is a statement.
prog, after binding the temporary· variables, processes its body sequentially. tags
are skipped over; statements are evaluated but the values are ignored. If the end
of the body is reached, prog returns n i 1. If (return x) is evaluated, prog
stops processing its body and returns the value x. If (go tag) is evaluated, prog
jumps .to the part of the body labelled with the tag. The argument to go is not
evaluated unless it is non-atomic.
It should be noted that the Mac1isp prog is an extension of the Lisp 1.5 prog, in
that go's and r·eturn's may occur in more places than Lisp 1.5 allowed. However,
the Lisp compilers implemented on ITS, Multics, and the DECsystem 10 forMaclisp reqUire that go's and return's be lexically within the scope of the prog.
This makes a function which does not contain a prog, but which does contain a go
or return ~ncompilable.

12-4.2

Page 2-38

-

------~

'---

..

~~--

...

~~-

July 27, 1978

._-------

---.~---

..

~~----

o

. Flow of Control

0'

See also the do special form, which uses a body similar to prog. The do, catch,
and. throw special forms are included in Mac1isp as an attempt to encourage
goto-Iess programming style, which leads to more readable, more easily maintained
code. The programmer is recommended to use these functions instead of prog
wherever reasonable.
Example:
(prog (x y z) ; x, y, z are prog variables - temporaries.
(setq y (car w) z (cdr. w»
;W is a free variable.
loop
(cond «null y) (return x»
«null z) (go err»)
rejoin
(setq x (cons (cons (car y) (car z»
x) )

(setq y (cdr y)
z (cdr z»
(go loop~
err
(break are-you-sure? t)
(setq z y)
(go rejoin»

do

FSUBR

The do special form provides a generalized' "do loop" facility, with ail arbitrary
. number of "index variables" whose values are saved when the do is entered and
restored when it is left, i.e. they are bound by the do. The index variables are
used in the iteration performed by do. At the beginning they are initialized to
specified values, and then at the end of each trip around the loop the values of the
index variables are changed according to specified rules. do allows the
programmer to specify a predicate which determines when the iteration will
terminate. The value to be returned as the result of the form may optionally be
speCified.
do comes in two varieties.

o

July 27, 1978

12-4.2

Page 2-39

o

Maclisp Reference Manual

The newer variety of do looks like:
(do « var tnit repeat) ••• )
(end-test exit·form • •• )
bod, • •• )
The first item in the form is a list of zero or more index variable specifiers. Each
index variable specifier is a list of the name of a variablevar, an initial value tnU,
which defaults to nil (or possibly zero, as mentioned under prog) if it is omitted,
and a repeat value repeat. If repeat is omitted, the var· is not changed between
loops.
All assignment to the index variables is done in parallel. At the beginning of the
first iteration, all the inits are evaluated, then the vars are saved, then the vars
are setq'ed to the values of the intts. To put it another way, the vars are
1ambda-bound to the values of the ~ntts. Note that the inits are evaluated befort
the varsare bound. At the beginning of each succeeding iteration those vars that
ha ve repeats get setq'ed to the values of their respective repeats. Note that all
the repeats are evaluated before any of the vaTS is changed.
The second element of the do-form is a list of an end testing predicate end·test
and zero or more forms, the exit·forms. At the beginning. of each iteration, after
processing of the repeats, the end-test is evaluated. If the result is nil, execution
proceeds with the body of the do. If the result is not nil, the extt-foTWU are
evaluated from left to right and then do returns. The value of . the do is the
value of the last exit-form, or n11 if there were no extt-forms~ Note that the
second element of the do-form resembles a cond clause.
If the second element of the form is nil, there is no end-test ,nor exit-forms, and
the bod, of the do is executed only once. In this type of do it is an error to have
repeats. This type of do is a "prog with initial values."
If the second element of the form is the S-expression (n i 1 ), there is no end-test or
exit-forms, and the bod" of the do is executed over and over. This is a "do
forever." The infinite loop can be terminated by use of return or throw.
The remainder of the do-form constitutes a prog-body. When the end of the body
is reached, the next iteration of the do begins. If return is used, do returns the
indicated value and no more iterations occur.

o
Page 2-40

12-4.2

July 27, 1978

c

Flow of Control

The older variety of 'do is:
(do var init repeat end-test bod" • •• )
The first time through the loop var gets the value of tnit; the remaining times
through the loop it gets the value of 'repeat, which is re-evaluated each time~ Note
that init' is evaluated before the value of var is saved. After var is set, end-test is
evaluated. If it is non-n i 1, the do finishes and returns n11. If the end-test is
nil, the bod, of the loop is executed. The
is like a prog body. go may be
used. If return is used, its argument is the value of the do. If the end of the '
prog body is reached, another loop begins.

bod,

Examples of the older variety of do:
(setq n (cadr (arraydims x»)
(do i 0 (1+ i) (= i n)

(store (x i) 0»

;zeroes out the array x

(do zz x (cdr zz) (or (null zz) (zerop (f'(car zz»»)
this applies f to each element of x
; continuously until f returns zero.
Examples of the new form of do:
(do «n (cadr (arraydims x»)
. (1 0 (1+ i»)
«= 1 n)
(store (x i) 0»
;this is like the example above,
. ;except n is local to the do
(do « x) ( y ) (z »

( n 11) bod,)

is like
(prog (x y z) bod,,)
except that when it runs off the end of the bod" do loops but prog returns n 11.
On the other hand,
(do « x ) ( y ) (z » nil bod,)
is identical to the prog above (it does not loop.)'

o

July 27, 1978

12-4.2

Page 2-41

o

Mac1isp Reference Manual

(do « x y (f x») « p x»

bod,)

is like
(do x y (f x) (p x) bod,)
The construction
(do' « x e (cdr x»

(01 dx x x»

« nu 11 x»

bod,)

exploits parallel assignment to index variables. On the first
iteration, the value of oldx is whatever value x had before the do was
entered. On succeeding iterations, oldx contains the value that x had on the
previous iteration .
. In either form of do, the bod" may contain no forms at aU. Very often an iterative
algorithm can be most clearly expressed entirely in the rtptats and extt-forms of a
new-style do, and the bod" is empty.
(do «xx (cdr x»
(y y (cdr y»
(z nil (cons (f x y) z») ;exploits parallel
«or (null x) (null y»
; assignment.
;typical use of nreverse.
(nreverse z»
)
;no do-body reqUired.
is like (maplist ~f x y).

go

FSUBR

The (go tag) special form is used to do a "go-to" within the body of a do or a
prog. If the ta.g is an atom, it is not evaluated. Otherwise it is evaluated and
should yield an atom. Then go transfers control to the point in the body labelled
by a tag eq or = to the one given. (Tags may be either atomic symbols or
numbers). If there is no. such tag in the body, it is an unseen-go-tag error.

I

I

I,

"Computed" go's should be avoided in compiled code or altogether.
t

o
12-4.2

Page 2-42

.

__

._._--_._-.......

----.~-.--------.--.-----------------

July 27, 1978

.---~~-~-~--

c

Flow of Control

EKample:
(prog (x y z)
(setQ x some frob)
loop

do something
(and some predicate (go loop»
do something more
(go (cond «minusp x) /loop)
(t /endtag»)
endtag
(return z»

return

;regular go

;"computed go"

SUBR 1 arg

return is used to return from a prog or a do. The value of return's argument
is returned by prog or do as its value. In addition, break recognizes the typedin S-expression (return value) specially. If this form is typed at a break,
value will be evaluated and returned as the value of break. If not at the top
level of a form typed at a break, and not inside a prog or do, return will cause
a fa i 1-act error.
Example:
(do «x x (cdr x»
(n 0 (* n 2»)
( (nu 11 x) n)
(cond «atom (car x»
(setQ n (1+ n»)
«memQ (caar x) /(sys boom bleah»
(return n»»

o

July 27, 1978

12-4.2'

Page 2-43

o

Maclisp Reference Manual

4.3

Non-Iooal Exits

catch

FSUBR

catch is the Maclisp function for doing structured non-local exits. (catch x)
evaluates x and returns its value, except that if during the evaluation of x
(throw y) should be evaluated, catch immediately returns , without further
evaluating x.
catch may also be used with a second argument, not evaluated, which is used as
a tag to distinguish between nested catches. (catch x b) will catch a (throw"
b) but not a (throw" %). throw with only one argument always throws to the
innermost catch. catch with only one argument catches any throw. It is an
error if throw is done when there is no suitable catch.
Example:
( ca tch' (rna'pcar (funct i on (1 ambda (x)
(cond «minusp x)
(throw x negative»
(t (f

x» »)

y)

o

negative)
which returns a list of f of each element of y if Y is all positive, 'otherwise the first
negati ve member of y.
The user of catch and throw is advised to stick to the 2 argument versions,
which are no less effiCient, and tend to reduce the likelihood of bugs. The one
argument versions exist primarily as an easy way to fix old Lisp programs which
use err set and err for non-local exits.. This latter practice is rather confusing,
because err and errset are supposed to be used for error handling, not general
program control.,
The catch-tag break is used by the break function.

Page 2-44

12-4.3

July 27, 1978

o

o

Flow of Control
throw

FSUBR

throw is used with catch as a structured nor:--Iocal exit mechanism.
(throw x) evaluates x and throws the value back to the most recent catch.
( throw x tag) throws the value of x back to the most recent catch labelled with
tag or unlabelled. catch'es with tags not eq, to tag are skipped over. x is
evaluated but tag is not.
See the description of catch for further details.

o

o

July 27. 1978

12-4.3

Page 2-45

o

Maclisp Reference Manual

4.4

Causing and Controlling Errors

See the complete description of the Mac1isp error system (part 3.4) for more
information about how these· functions work.

lSUBR 0 to 3 args

error

This is a function which allows user functions to signal their own errors using
the Mac1isp error system.
( error) is the same as (err).
(error message) signals a simple error; no datum is printed and no user
interrupt is signalled. The error message typed out is message..
(error message datum) signals an error with message as the message to be
typed out and datum as the Lisp object to be printed in the ·~rror message. No
user interrupt is Signalled.
(error message datum uint-clm) signals an error but first signals a user
interrupt on channel uint-clzn, provided that there is such a channel, and it has a
non-n i 1 service function, and the special conditions concerning err set (see page
3-16) are satisfied. uint-clzn is the name ·of the user-interrupt channel to be used
(an atomic symbol); see part 3.4.2. If the service function returns an atom, error
goes ahead and signals a regular erro(. If the service function returns a list,
error returns as its value the car of that list. In this case· it was a ·correctable·
. error. This is the only case in which error will return; in an other cases control
is thrown back to top level, or to the nearest enclosing errset.

err set

o

FSUBR

The special form (errset form flag) is used to trap an expected error. err set
eva luates the form. If an error occurs during the evaluation of the form, the error
is prevented from escaping from inside the errset and errset returns nil. If
no errors occur, a list of one element, the result of the evaluation, is returned. The
result is listified so that there will no ambiguity if it is "11. errset may also be
made to return any arbitrary value by use of the err function.
The flag is optional. If present,·it is evaluated before the form. If it is nil, no
error ,message win be printed if an error occurs during the evaluation of the form.
If it is not "1 1, or if it is omitted, any error messages generated will be printed.
Page 2-46

l2-4.4

July 27, 1978

o

Flow of Control

Examples:
If you are not sure x is a number:

(errset (setq x (addl xl»
This example may not work in compiled code if the compiler chooses to open-code
the addl rather than calling the addl subroutine. In genera1, one must be
extremely foolhardy to depend on error checking in compiled code. _
To suppress the error message if the value of a is not an atomic symbo1:

(errset (set a b) nil)
To do the same but generate one's own message:

(or (errset (set a b) nil)
(error '(not a variable) a»

. FSUBR

err

(err) causes an error which is handled the same as a Lisp error except that there
is no preliminary user int~rrupt, and no message is typed out.
(err x) is like (err) except that if control returns to an errset, the value of
the errset win be the result of evaluating x, instead of nil.
(err x nil) is the same as (err x).
(err x t) is like (err x) except that x is not evaluated until just before the
err set returns it. That is, x is evaluated afttr unwinding the pdl and restoring
the bindings.
Note: some people use err and errset where catch and throw are indicated.
This is a very poor programming practice. See writeups of catch and throw for
details.
.

o

july 27, 1978

12-4.4

Page 2-47

o

Mac1isp Reference Manual

o

Page 2-48

12-4.4

July 27, 1978

o

o

Atomic Symbols

5.

Atomic Symbols

5.1

The Value Cell

Each atomic sy'mbol has associated with it a value cell, which is a piece of storage'
that can refer to one Lisp object. This object is caned the symbol's value, since it is what'
is returned if the symbol, is evaluated. The binding of atomic symbols to values allows
them to be used in programming the way "variables" ar~ used in other languages.
The value cell can also be empty, in whiCh ca~e the symbol has no value and is said
to be unbound or undefined. This is the initial state of a newly-created atomic symbol.
Attempting to eV,aluate an unbound symbol causes an error to be Signalled.

o

An object can be placed into a symbol's value cell bylambda-btndtng or by
assignment. (See page I-II.) The difference is in ho.w dosely the value-changing is
associated with control structure and in whether it is considered a stde-effect.

setq
The setq special form is used to assign, values to variables (atomic symbols.) setq
processes the elements of its form in pairs, sequentia1ly from left to right. The
first member of each pair is a variable, the second is a form which evaluates to a
value. The form is evaluated, but the variable is not. The value-bindin~ of the
variable'is made to be the value' specified .. You must not setq the special atomicsymbel constants t and n 11. The value returned by setq is the last value
assigned, i.e. the result of the evaluation of the last element of the setq-form.
Example: (setq x (+ 12 3) y (cons x nil»
This returns (6) and gives x a value of 6 and y a value of (6).
Note that the first assignment is completed before the second assignment is
started, resulting in the second use of x getting the value assigned in the first
pair of the setq.

o

July 27, 1978

12-5.

Page 2-49

o

Maclisp Reference Manual

, SUBR 2 args

set

set is like setq except that the first argument is evaluated; also set only takes
one pair of arguments. The first argument must, evaluate to an atomic symbol,
whose value is changed to the value of the second' argument. set returns the
value of its second argument. Example:
.

(set (cond «predicate) /atoml) (t /atom2»
/stba)
evaluates to stba and gives either atoml or atom2 a value of stba.

set could have been defined by:
(defun set (x y)
(eval (list /setq x (list /quote y»»
Altern~tively, setq could have been defined by:

'(defun setq fexpr (x)
. «lambda (var val rest)
(set var val)
(cond «null rest) val)
«apply (function setq) rest»
(car x)
(eva 1 (cadr x»
(cddr x»)
symeval

,0
»

jir more, recurse

SUBR· 1 arg

( symeva 1 a) returns the value of a, which must be an atomic symbol. T.he.
compiler produces highly optimal code for symeval, making it much better than
eva 1 when the value of a symbol needs to be taken and the particular symbol to be
used varies.

Page 2-50

12-5.1

July 27, 1978

o

o

Atomic Symbols

boundp

SUBR 1 arg

The argument to boundp must be an atomic symbol. If it has a value, t is
returned. Otherwise nil is returned.

SUBR 1 arg

makunbound

The argument to makunbound must be an atomic symbol. Its value Is removed, i.e.
it becomes un~ound.
Example: .

(setq a 1)
a => 1 .
(makunbound /a)
a => unbnd-vrb1 error •
•makunbound returns its argument.

o

o

!2-5.1

July 27, 1978

· ,:1."",4$#4;;;;;:;";;,"'.1;:##4; 4 UUM4 ;;'#M'.A .# J;$,tA4;X;~$1

An ,,4 1 ijHliM4HiiiiIGiiil,Iii;.uWVW.,

, A

L

A«

lfi'i.lf.f!W4Mf¥M4!f

Page 2-51

" Wif¥lIfII\$';;

Q

$4\/4f4f1fi\(#.¥,\Ti!ifP4fA ¥44TfI#Ii!M\M!i811TTIIfT4¥4 %#4T1 ¥ A\?#¥ATIW

A4##. 444 M#¢##$4q?A T#4#iFwm

M

t.

4 An"

-"

o

Maclisp Reference Manual

.5.2

The Property List

A property-list is a list with an even number of elements. Each pair of elements
constitutes a property; the first element is called the "indicator" and the second is caned
the "value" or, loosely, the "property." The indicator is generally an atomic symbol which'
serves as the name of the property. The value is any Lisp object.
For example, one type of functional property uses the atom expr as its indicator. In
the case of an expr-proper~y, the value is a list beginning with lambda.
An example of a property list with two properties on it is:
(expr (lambda (x) (plus 14 x»

foobar t)

The first property has indicator e~pr and value (lambda (x) (plus 14 x», the
second property has indicator foobar and value t.
Each atomic symbol has associated with it a property-list, which can be retrieved with
the p 1 i st function. It is also possible to have "disembodied" property lists which are not
associated with any symbol. These keep the property list on their cdr, so the form of a
disembodied property list is «anything) • plist). The way to create a disembodied
property list is (ncons nil). Atomic symbols also (usually) keep their property list on
their cdr, but you. aren't allowed to know that. Use the p11st function to get the
property list of a symbol.

o

Property lists are useful for associa.ting "attributes" with symbols. .Maclisp 'uses
properties to remember function definitions. The compiler uses properties internally to
keep track of some of what it knows about the program it is ·compiling.
The user familiar with Lisp 1.5 will want to note that the property list "flags" which
are a110wed on Lisp 1.5 property lists do not exist in Maclisp. However, the same effect
can be achieved by ~sing properties with a value of t or n 11.
Some property names a're used internally by Maclisp, and should therefore be
avoided in user code. These include args, array, autoload, expr, fexpr,
fsubr, lsubr, macro, pname, sub1is, subr, value, used by the Lisp system
proper; arith, *array, atomindex, *expr, .fexpr, .lexpr, numfun,
number, . numvar, ohome, special, sym, used by the compiler; grindfn,'
grindmacro, used by'the grinder.

. Page 2-52

12-5.2

July 27, 1978

0

1

o

Atomic Symbols
get

SUBR 2 args
(get x ,) gets x's ,~property. x can be an atomic symbol or a disembodied
property list. The value of x's ,-property is returned, unless x has no ,-property
in which case nil is returned. It is not an error for x to be a number, but nil
wi 11 a Iwa ys be returned since numbers do not have property lists.
Ex~mple:

(get . . foo . . bar)
=> nil
;initial1y foo has no bar property
(putprop . . foo . . zoo . . bar) ;give foo a bar property
=> zoo
(get . . foo . . bar)
;retrieve that property
=> zoo
(pl1st . . foo)
;look at foo's property list
=> (bar zoo ... other properties ••• )
get could have been defined by:
(defun get (x y)
(do «z (cond «numberp x) nil)
«atom x) (plist x»
(t (cdr x»)
(cddr z»)
«or (null z) (eq y (car z»)
(cadr z»»

c

This relies on the fact that the car and the cdr of nil are nil, and therefore
(cadr z) is nil if z is n 11.

get1

SUBR 2 args
(get 1 x ,) is like get except that" is a list of indicators rather than just a
single indicator. get 1 searches x's property list until a property whose indicator
appears in the list" is found.
'
The portion of x's property list beginning with the first such property is returned.
The car of this is the indicator (property name) and the cadris the property
value. get 1 returns nil if none' of t~e indicators in , appear on the property list
of x. .
.

o

July 27, 1978

12-5.2

Page 2-5S

o

Maclisp Reference Manual

get 1 could have been defined by:
(defun getl (x pl)
(do, «q (plist x) (cddr q») ; scan doWn P-list of x
«or (null q) (memq (car q) pl»
q»)

This definition is simplified and doesn't take numbers and disembodied property
lists into account.

SUBR 3 args

putprop

(putprop x '1 z) gives x a z-property of '1 and returns ,. x may be an atomic
symbol or a disembodied property list. After so~ebody does (putpropx , %),
(get x z) win return ,.
Example:
(putprop'N1xon 'not 'crook)
If the symbol already has a property with the same name that property is removed
first. This ensures that get 1 will always find the property which was put on most
recently. For instance, if you were to redefine an expr as a subr, and then
redefine it as an expr again, this effect of putprop causes the evaluator to find the
latest definition always.
A lisp definition of the basic putprop without the complications of numbers and
disembodied property lists might be:

(defun putprop (x y z)
(remprop x z)
(setpl1st x (cons z (cons y (p11st x»»
y)

defprop

FSUBR

defprop is a version of putprop with no argument-evaluatlon, which is
sometimes more convenient for typing. For instance,

Page 2-54

12-5.2

July 27, 1978

0

,Atomic Symbols

(defprop foo bar oftenw1 th')
is equivalent to
(putprop "foo "bar "oftenw1th)
remprop

SUBR Z args

(remprop x ,) removes x's ,-property, by splicing it out of x's property list. The
va lue is nil if x had n~ ,-property. If x did have a ,-property, the value is a list
whose car is the property, and whose cdr is part of x's property'Ust, similar to
(cdr (getl x "(,»).
x rna y be an atomic symbol or a disembodied property list. Example:
(remprop "foo "expr)
undefines the function' foo, assuming it was defined by
(defun foo (x) .•• )
pl1st

SUBR 1 arg
(p 1 i st x) returns the property Jist of the atomic symbol x.

setpl1st

SUBR Z args

( se tp 1 is t x I) sets the property list of the atomic symbol x to l. This is to be
used with caution, since in some implementations property lists contain internal
system properties which are essential to the workings of the Lisp system.

o

July 27, 1978

12-5.2

Page 2-55

o

Maclisp Reference Manual

5.3

The Print-Name

Each atomic symbol has an associated character stringcalJed its "print-name; or
"pname" for short. This character string is used as the external representation of the
symbol. If the string is typed in, it is read as a reference to the symbol. If the symbol is
to be pr 'I nt'ed, the string is typed out. "
See also page 2-83 for some ot~er functions which have to do with pnames.

samepnamep

SUBR 2 args

. The arguments to samepnamep must evaluate to atomic symbols or to character
strings. The result is t if they have the same pname, nil otherwise. The pname
of a character string is considered to be the string itself. Examples:
(samepnamep 'xyz (maknam '(x yz») => t
(samepnamep 'xyz (maknam '(w x y») => nil

alphalessp

o

SUBR 2 args

(alphal,essp x 1), where x and 1 evaluate to atomic symbols or character strings,
returns t if the pname of x occurs earlier in alphabetical order than the pname of
,. The pname of a character string is considered, to be the string itself.
Examples:
.
(alphalessp 'x 'xl) => t
(alphalessp 'z 'q) => nil
(alphalessp "x" 'y) => t
Note that the "alphabetical order" used by alphalessp is actually the ASCII
collating sequence. Consequently an upper case letters come before all lower case
letters.

Page 2-56

i2-S.3

July 27, 1978

o

0

Atomic Symbols
' ',1
"

SUBR 2 args

pnget

(pnget symbol n) returns the pname of the symbol as a list of fixnums
containing packed n-bit bytes. The legal. values of n depend on the
implementation; in the pdp-IO implementation, 6 (SIX BIT) and 7 (ASCI are
allowed. If this seems obscure, that's because it is. Example:

n

(pnget

/MUMBlERATOR 7) =>
(-311246236550 -351327625542 -270_33)
SUBR 2 args

pnput

This is a sort of inverse of pnget. (pnput (pnget (00 7) jlag) returns a
symbol with the same pname as (00. The symbol is interned if flag is non-n 11.

o

o

July 27, 1978

. 12-5.3

Page 2-57

Mac1isp Reference Manual

5.4

Interning' of Symbols

One normally wants to refer to the same (eq) atomic symbol every time the same
pname is typed. Maclisp implements this through what is caned theobarra,. The
obarra y is a hash-table of atomic symbols. These symbols are said to be tnterned, or
registered in the obarray. Whenever a pname is read in Lisp input, the obarray is
searched for a symbol with the same pname. If one is found, the pname is considered to
refer to that symbol., If not, a new symbol is created and added to the obarray.
The representation of an obarray is a Lisp array. The first 510. (or thereabouts)
elements of the· arra y contain lists which are buckets of a hash table. The last 128.
elements of the array contain the "character objects," symbols with I-character pnames.
(These entries contain nil if the corresponding symbol has not yet been interned.) The
character 'objects ,are treated specially for efficiency. There are usually one or two unused
array elements between these two areas.
In order to allow for multiple name spaces, Maclisp allows multiple obarrays. An
obarray can be made "current" by binding the symbol obarray to the appropriate array. pointer. See page 2-89 for details on how to manipulate obarrays and arrays in general.

It is possible to have a symbol interned on several obarrays at the same time. It is

o

a Iso possible to have two different (non-eq) symbols with the same pname interned on
different obarrays. Furthermore it is possible to have a symbol which is not interned on
any obarray, which is called an uninterned symbol. These are useful for purely-internal
functions, but can cause difficulty in debugging since t,hey can't be accessed directly.
Such a symbol can be accessed via some data struct~re that contains it, set up by the
program that created it.
Normany symbols are never removed from obarrays. It is possible for the user to
explicitly remove a symbol from the current obarray. There is also a feature by which
"truly worthless" symbols may be removed automatically (see page 3-60).
intern

. SUBR 1 arg

(intern x), where x is an atomic symbol, returns the unique atomic symbol which
is "interned on the ob~rra y" and has the same pname as x. If no symbol on the
current obarray has the same pname as x, then intern will place x itself on the
obarray, and return it as the value.

Page 2-58

12-5.4

July 27, 1978

'0

Atomic Symbols

0··"
"

SUBR 1 arg

remob

The argument to remob must be an atomic symbol. It is removed from the current
obarray if it is interned on that obarray. This makes the atomic symbol
inaccessible to any S-expressions that may be read in or loaded in the future.
remob returns n i 1.
.

copysymbol

SUBR 2 args

A subr of two arguments. The first argument must be a symbol, and the second
should be t or nil. The result is a new, uninterned symbol, with the same pname
as the argument. "Uninterned" means that the symbol has not been placed on any
obarray. If the second argument is t, the new symbol win be given the same value
as the original and will have a ~opy of its property list. Thus the new win start
out with the same value and properties as the old, but if it is setq'ed or
putprop'ed, the value or property of the old wilt not be changed. If the second
argument is nil, the new symbol has no value and no properties (except pOSSibly
internal system properties.)

c

gensym

lSUB~

0 or 1 args

gen sym creates and returns a new atomic symbol, which is not interned on an
obarray (and therefore is not recognized by read.) The atomic symbol's pna~e is of
the fOfm prefix number, e.g. gOOO 1., The number is incremented each time.
If gensym is given an argument, a numeric argument is used to set the number.
The pname of an atomic-symbol argument is used to set the prefix. For example:

if
(gensym) => g0007
then (gensym "foo) => f0008
(gensym 40) => f0032
and (gensym) => f0033
Note that the number is in decimal and always four digits, and the prefix is
always one character.

o

July 27, 1978

12-5.4

'Page 2-59

o

Maclisp Reference Manual

5.5

Defining Atomio Symbols as Functions

Atomic symbols maybe used as names for functions. This is done by putting the
actual function (a subr-object or a lambda-expression) on the property list of the atomic
symbol as a "functional property," i.e. under one of the indicators expr, fexpr,
rna'cro, subr, 1subr, or fsubr.
Arra y properties (see page 2-89) are also considered to be functional properties, so
an atomic symbol which is the name of an array is also the name of a function, the
accessing function of that array.
When an atomic symbol which is the name of a function is applied, the function
which it names is substituted.

FSUBR

defun

defun is used for defining functions. The general form is:

o

(defun name t1Pe (lambda-variable ••• )

bod" • •• )
However, name and type may be interchanged. t1Pe, which Is optional, may be
expr, fexpr, or macro. If it is omitted, expr is assumed. Examples:
(def'un addone (x) (1+ x»

;defines an expr

(defun quat fexpr' (x) (car x»

;defines a fexpr

(defun fexpr quat (x) (car x»

;is the same

(defun zzz expr x
(faa (arg 1)(arg 2»)

;this is how you
;' define a lexpr.

The first example above is really just defining a synonym. Another way to do this
is:
(defprop ,addone 1+ expr)
That' is, an atomic functional property indicates sY,nonyming. This can be
particularly useful to define a macro by an expr or fexpr, or even by a subr.
The functions defprop and putprop may also be used for defining functions.
Page 2-60

12-5.5

July 27, 1978

o

Atomic Symbols

There is a feature by which, when a file of functions has been compiled and loaded
into .the lisp environment, the file may be edited and then only those functions
which were changed may be loaded for interpretive execution. This is done by
compiling with the "E" switch, and then reading in the source file with the
variable defun bound non-ni 1. Each function will have an expr-hash property
maintained, which contains the sxhash of the interpreted definition of the
function. defun will only redefine the function if this hash-code has changed.
This feature is rather dangerous since reasonable alterations to the function
definition may not change the sxhash and consequently may not take effect.
Because of its general losingness,. ~his feature is only available in the pdp-l0
implementation and sometimes not even there.
de fun could have been defined by:
(defun defun fexpr (x) ;circular, but you get the idea
(prog (name type body)
; first, analyze the form, get arguments •.
(cond «memq (car x) /(expr fexpr macro»
(setq type (car x)
name (cadr x)
body (cddr x»)
«memq (cadr x) /(expr fexpr macro»
(setq name.(car x)
. type (cadr x)
body (cddr x»)
«setq name (car x)
type /expr
body (cdr x»»

o

(setq body (cons /lambda body»
; now, check for expr-hash hair.
(cond «and defun
(get name /expr-hash)
(= (get name /expr-hash)
(sxhash body»)
)

actually make the definition.
«putprop name body type»)
(return name»)

o

July 27, 1978

12-5.5

Page 2..61

MdMilGiM14b&1AUM8iG&;;G Q.,_LI " ",.

o

Maclisp Reference Manual

lSUBR 1 or 2 args

args

(args f) tells you the number 'of arguments expected by the function f. If f
wants. n .arguments, args returns (n i 1 • n). If f can take from m to n
arguments, args returns (WI • n). If f is an fsubr or a ·Iexpr. expr. or fexpr. the
results are meaningless.
(args f x), where x is (n i 1 • n) or (m . n), sets the number of arguments
desired by the function f. This only works for compiled. non-system functions.
sysp

SUBR 1 arg
The sysp predicate takes an atomic symbol as an argument. If the atomic symbol
is the name of a system function (and has not been redefined), sysp returns the
type of function (subr, lsubr, orfsubr). Otherwise sysp returns nil.
Examples:
(sysp "foo) => ni 1 (presumably).

o

(sysp "car).=> subr
(sysp "cond) => fsubr

Page 2-62 .

12-5.5

July 27, 1978

o

Numbers

8.

Numbers

For a description of the various types or'numbers used in Maclisp, see part 1.2.

8.1

Number Predicates
SUBR 1 arg

zerop

. The zerop predicate returns t if its argument is fixnum zero or flonum zero.
(There is 'no bignum zero.) Otherwise it returns nil. It is an error jf the
argument is not a number. If that is possible s1gnp should be used.

SUBR 1 arg

plusp

The p 1usp predicate, returns .t ,if its argument is strictly greater than zero, n t 1 if
it is zero or negative. It is an error if the argument is not a number.

o

minusp

SUBR 1 arg

The minusp predicate returns t if its argument is a negative number, nil if it is
a non.-negative number. It is an error if the argument is not a number.

SUBR 1 arg

oddp

The oddp predicate returns t if its argument is an odd number, otherwise nil.
The argument must be ~ fixnum or a bignu~.

signp

FSUBR

The s 1gnp predicate is used to test the sign of a number. (5 ignp ex) returns t
if x's sign satisfies the test c, n 11 jf it does not. x is evaluated but c is not. The
result is always n1 1 jf x is not a number. C can be one of the fonowing:

o

July 27, 1978

l2-6.

Page 2-63

Maclisp Reference Manual

1
le
e
n
ge
g

means

"
"
"

x(O
xiO
x=O·
x~O

x~O

"
"

x>O

Examples:
(s1gnp 1e -1) => t
(s1gnp n 0) =>·n11
(signpg '(foo • bar»

=> nil

hau10ng

o

SUB.R 1 arg

(hau long x) returns the number of significant bits in x. x can be a ftxnum or a
bignum. The result is the least integer not less than the base-2 logarithm of

Ix I+1.

o

Examples:
(hau1ong 0) => 0
(haulong 3) => 2
(hau1ong -7) => 3
(haulong 12345671234567) => 40.

fage 2-64

'2-6.1

Jul, 27, 1978

o

Numbers

8.2

Comparison

=

SUBR 2 args
(= x "j) is t if x and "j are numerically equal. x and , must be both fixnums or
both flonums. Use equal to compare bignums.

greaterp

lSUBR 2 or more args

greaterp compares its arguments, which must be numbers, from left to right. If
any argument is not greater than the next, greaterp returns nil. But if the
arg'uments to gr'eater~ are strictly decreasing, the result is t. Examples:
(greaterp 4 3) => t
(greaterp 1 1) =>n11
(greaterp 4.0 3.6 -2) => t
(greaterp 4 3 1 2 0) => n11

>

SUBR Z args
(> x "j) is t if x is strictly greater ,than " and n 11 otherwise. x and , must be
both fixnums or both flonums.

lessp

LSUBR Zor more args

1essp compares its arguments, which must be numbers, from left to right. If any
argument is not less than the next, 1essp returns n 11. But if the arguments to
1essp are strictly increasing, the result is t. Examples:
(lessp 3 4) => t
(lessp 1 1) => n11
(lessp ·2 3.6 4) => t
(lessp 0 Z 1 3 4) => nil

o

July 27, 1978

l2-6.2

Page 2-65

o

Mac1isp Reference Manuai

<

SUBR Z args

« x ,) is t if x is strictly less than " and nil otherwise. x and, must be both
fixnums or both ftonums.
lSUBR 1 or more args

max

max returns the largest of its arguments, which must be numbers. If any
argument is a ftonum, the result will be a ftonum. Otherwise, it will be a fixnum
or a bignum depending on its magnitude.
lSUBR 1 or more args

min

min returns the smallest 'of its arguments, which must be numbers. If any
argument is a ftonum, the result will be a ftonum. Otherwise, it will be a fixnum
or' a bignum depending on its magnitude.

July.?;1, 1978

Page 2..66

............

--.-------~

.. - ... ---........ --.--

---~

--_ ..... _._....... _.. _---_._-_.

__ .._-_.... _.. _.__

... - ... -..

._-,--

--.--~-----

.. - . - - -..

-

.

o

o

Numbers

8.3

Conversion
SUBR 1 arg

fix

(fix x) converts x to a fixnum or a bignum depending on its magnitude.
Examples:
(fix 7.3) => 7
(fix -1.2) => -2
(fix 104) => 104

SUBR 1 arg

1f1x

( i fix x) converts x from a flonum to a fixnum. ifix will never return a
bignum, unlike fix. This a11ows' it to be efficiently open-coded. This is not the.
same function as IFIX in Fortran; rounding is down rather than towards zero.
It is like ENTlER in Algol.
i fix does not exist in the Multics implementation~

SUBR 1 arg

floa't

(float x) converts x to a flonum. Example:
(float 4) => 4.0 '
(float 3.27) => 3.27

SUBR 1 arg

abs

(abs x) => I x I, the absolute value. of the number x. abs could have been defined
by:

(defun abs (x) (cond «minusp x) (minus x»
(t x) »

o

July 27, 1978

'2-6.3

Page 2-67

o

Maclisp Reference Manual

SUBR 1 arg

minus

minus returns the negative of its argument, which can be any kind of number.

Examples:

(minus 1)=> -1
(minus -3.6) =) 3.6
haipart

SUBR 2 args

(ha i part x n) extracts n leading or trailing bits from the internal
representation of x. x may be a fixnum or a bignum. n must be a fixnum. The
value is returned as a fixnum or· a bignum. If· n is positive, the result contains
the n high-order significant bits of Ix I.. If n is negative, the result. contains the
I n I low-order bits of Ix I. If I n I is bigger than the number of significant bits in
x, I x I is returned.
Examples:
(haipart 34567 7) =) 162

o

(hatpart 34567 -5) => 27
(haipart -34567 -5) => 27

Page 2-68

12-6.3

July 27.1978

o

i

Numbers

8.4

Arithmetio
General Arithmetio

These functions will perform arithmetic on any kind of numbers, and always yield
an exact result, except when used with flonums. (Flonums have limited precision and
.range.) Conversions to flonum or bignum representation are done as needed. Flonum
representation will, be used if any of the arguments are ftonums; otherwise fixnum
representation wi11 be used if the result can fit in fixnum form, or bignum representation
if it cannot.
The two sections after this one describe other arithmetic functions which are more
efficient but less powerful.
plus

lSUBR 0 or more args
p 1us returns the sum of its arguments, which may be any kind of numbers.

c

difference

lSUBR 1 or more args

d iff eren ce returns its first argument minus the rest of its arguments. It works
for, any kind of numbers.

times

lSUBR 0 or more args
times returns the product of its arguments. It works for any kind of numbers.

lSUBR 1 or more args

quotient

quot i ent returns its first argument divided by the rest of its arguments. The
arguments may any kind of number.
Examples:
(quotient 3 Z)

=> 1

(quotient 3 Z.O) =>
(quotient 6.0 1.5

0

July 27, 1978

;fixnum division truncates.

1.5

jbut flonum div1sjon does not.

Z.O) => Z.O
12-6.4

Page 2-69

o

Maclisp Reference Manual

SUBR 1 arg

add 1

( add 1 x) => x+ 1. x may be any kind of number.

SUBR 1 arg

subi

( sub 1 x) -> x-I. x may be any kind of number..

SUBR 2 args

remainder

( rema i nde'r x ,) ~> the remainder of the division of x by,. The sign of the

remainder is the same as the sign of. the dividend. The arguments must be
fixnums orbignums.

SUBR 2 args

gcd

(gcd x ,) => the greatest common divisor of x and 'J. The arguments must be
fixnumsor bignums.

. expt

0

SUBR 2 args
(expt x %) = x%
The exponent % may be a bignum if the base x is 0, I, or -I; otherwise % should be a
fixnum. x may be any kind of number.
As a special feature, expt allows its second argument to be a ftonum, in which
case ,the first argument is converted to a ftonum and the exponentiation. is
performed
ftoating point, using logarithms. The result is a ftonum In this case.

in

SUBR 2 args
*dif is a subr form of difference. It is documented here because some people
use it. There is no reason to lise it, since the compiler automatically converts
difference into *dif as required.

12-6.4

Page 2-70

.........

---~---

_ ........ " " " . _ . - ...,,-_.._ . . . . .

--_ ...

.." ...- .........--..---..

July 27, 1978

-----~-.---."

..

-.~--.--.-.--.------.~~-

o

o

Numbers

SUBR 2 args

*quo is a subr form of quotient. It is documented here because some people use
it. There is no reason to use it, since the compiler automatically converts
quot i ent into *quo as required.

o

july 27, 1978

f2-6.4

Page 2-7.

o

Mac1isp Reference Manual

Fixnum Arithmetio
These functions require their arguments to be fixnums and produce only fixnum
results. If the true result, which would be returned by the more general functions
described previously, is too large to be represented as a fixnum, the result actually
returned will be truncated to an implementation-dependent number of bits, which is 36.
(including the sign) in the M"ultics and pdp-IO implementations. The compiler produces
highly-optimized code for these operations.

lSUBR 0 or more args

+

+ returns the sum of its arguments. The arguments must be ftxnums, and the

result is always a fixnum. Examples:
(+ 2 6 -1) => 7
(+ 3) => 3
;trivial case
(+) => 0
; identity element

o

lSUBR 0 or more args
This is the fixnum-only subtraction function. With one argument, it returns the
number's negation. With more than one argument, it returns the first argument
minus the rest of the arguments.

(-) => 0, the identity element
(·"3) =>-3
(- 5 3) => 2
(- Z 6 -1) => -3
etc.

lSUBR 0 or more args

*

* returns the product of its arguments. Examples:
(* 4 5 -6) => -120.
(* 3) =) 3
(*) =) 1

Page 2-72

;trivial case
; identity element

12-6.4

" July 27, 1978

o

Numbers

c

lSUBR 0 or more args

I

This is the fixnum-only division function. The arguments must be fixnums and
the result of the division is truncated to an integer and returned as a ftxnum.
Note that the name of this function must be typed in as 1/, since Lisp uses I as an
escape character..
If used with more than one argument, it divides the first argument by the rest of
the arguments. If used with only one argument, it returns the fixnum reciprocal
of that number, which is -1,0, I, or undefined depending on whether the niJmber Is .
-I, large, I, or O.

( II) =>I, the identity element.
(II 20. 5) => 4·
(II 100. 3 Z) => 16.
etc.

SUBR 1 arg

1+

(1+ x) => x+l. x must be a fixnum. The result is always a fixnum.

0

SUBR 1 arg

1-

(1- x) => x-I. x must be a fixnum. The result is always a fixnum.

SUBR 2 args

\

(\ x "j) returns the remainder of x divided by" with the sign of x. x and ,
must be fixnums. Examples:
.
(\ 5 2) => 1
(\ 65. -9.) => 2
. (\ '-65. 9.) => -2

SUBR 2 args

\\

This subr of two arguments is like ged, but only accepts fixnums. This makes it
faster than ged.

o

july 27, 1978

Page 2-73

o

Mac1isp Reference Manual

SUBR 2 args

,.. is the fixnum only exponentiation function. It is somewhat faster than expt,
but requires its arguments to be fixnums, uses fixnum arithmetic, and always
returns a fixnum result, which will be incorrect if the true result is too large to be
represented as a fixnum.

o

Page 2-74

f2-6.4

~ ..• ~--.---.--.---------.------~------.--

July 27, 1978

-----.-_.-------_.- --.----.-.--.. ---~--.-.------.----~~..- - - . - - - - - - -

o

o

Numbers

Flonu", Arithmetio
These functions require their arguments to be ftontims, and always produce flonum
, results,' If the true result is too large or too small to be represented as a flonum, an
arithmetic underflow or overflow error will occur. (In the pdp-tO implementation these
errors are not detected in compiled programs.) The compiler' produces highly-optimized
.
code for these operations.

LSUBR 0 or more args

+1

+1 returns the s~m of its arguments.
Examples:
(+1 4.1 3.14) => 7.24
(+1 2.0 1.5 -3.6) => -0.1
(+1 2.6) => Z. 6
;trivial case
( +1 ) => O. 0
; identity element

LSUBR 0 or more args

-I

This is the flonum-only subtraction function. When used with only one argument,
it returns the number's negation. Otherwise, it returns the first argument minus
the rest of the arguments.
( -I) => 0.0, the identity element
(-I x) => the negation of x.
(-I 6.0 2.5) => 4.5
(-I 2.0 1.5 -3.6) => 3.1
etc.

LSUBR 0 or more args

*1 returns the product of its arguments. Examples:

(*, 3.0 2.0 4.0) => ~4.0

(*, => =>
6. 1)

(*1)

july 27, 1978

; trivial' case
; identity element

6. 1

1.0

l2-6.4

Page 2-75

o

Maclisp Reference Manual

lSUBR 0 or ~ore args

II

This is the Aonum-only division function. Note that the name of this function
must be typed in as III, since Lisp uses l as an escape character. This function
computes the reciprocal if given only one argument. If given more than one
argument, it divides the first by the rest.

( III) => i. 0, the identity element
(III 5.0) => o. Z
(III 6.28 3.14) => Z.O
(III 100.0 3.0 Z.O) -> 16.5
etc.

1+1

SUBR 1 arg
( 1+1 x) => x +,1.0. x must be a flonum. The result is always a flonum.

1-1

SUBR 1 arg
(1-1 x) => x-l.O.

AI

x must be a flonurn. The result is always a ftonum.

0

SUBR 2 args
AI is the flonum-only exponentiation function. The first argument must be a
Aonum, the second must be a fixnum (repeat, a jixnum), and the result is a flonum.
To raise a Aonum to a flonurn power,use (expt x y) or (exp (*1 y (log

x» ).

Page 2-76

f2-6.4

July 27, 1978

o

o

Numbers

8.5

Exponentiation and Logarithm Funotions
SUBR 1 arg

sqrt

(sQrt x) => a flonum whiCh is the square root of the number x. This is more
accurate than (expt x 0.5). ,The fonowing code, which is due to Gosper, should
be written jf the square root of a bignum is desired. It is essentia11y a Newton
iteration, with appropriate precautions for integer truncation.
(defun bSQrt (n)
(bsqrtl(abs n)
(expt Z (II (1+ (haulong n»

Z»»

(defun bSQrtl (n guess)
«lambda (next)
(c,ond « 1essp next guess)
(bsqrtl nnext»
(t guess»)
(quotient (plus guess (quotient n guess»

Z» )

o

SUBR 1 arg

exp
(exp x) => eX

SUBR 1 arg

log

( log x) -> the natural logarithm of x.

o

July 27, 1978

12-6.5

Page 2-71

o

Maclisp Reference Manual

8.8

Trigonometric Funotions
SUBR 1 arg

sin

( sin x) gives the trigonometric sine of x. x is in radians. x may be a ftxnum or
a flonum.

SUBR 1 arg

cos

(cos x) returns the cosine of x. x is in radians. x may be a fixnum or a flonum.

SUBR 2 args

atan

(atan x ,) returns the arctangent of xl" in radians. x and 'J may be fixnums or
ftonums. ,may be 0 as long as x is not also o.

o

Page 2-78

12-6.6

July 27, 1978

Numbers

o
8.7

Random Funotions
lSUBR 0 to 2 args

random

(random) returns a random fixnum.
(random n 11) restarts the random sequence at its beginning.
(random x), where x is a fixnum, returns a random fixnum between 0 and x-I
inclusive. A useful function is:
(defun fr~ndom ()
(III (float (random 10000.»

10000.0»)

which returns a random flonum between 0.0 and 1. o.
(random nl n2) sets the random number seed from the pair of integers nI, n2.

zunderflow

SWITCH

If an intermediate or final flonum result in the interpretive arithmetic functions
(t 1mes, *1, expt, etc.) is too small in magnitude to be represented by the machine,
corrective action will be taken according to the zunderflow switch.
If the value of zunderflow is non-n11, the offending result win be set to 0.0
and computation will proceed. If the value of zunderflow is nil, an error will
be signalled. nil is the initial value.
In the pdp-lO implementation compiled code is not affected by zunderflow if the
arithmetic in question was open-coded by the compiler. Instead, computation
proceeds using a res~lt with a binary exponent 256 higher than the correct
exponent. ,In the Multics implementation zunderflow works the same for
compiled code as for interpreted code.
See, (sstatus divov), which controls division by zero (part S.7).

o

July 27, 1978

, 12-6.7

Page 2-79

Maclisp Reference Manual

8.8

Logical Operations on Nuinbers

These functions may be used freely for bit manipulation; the compiler recognizes
them and produces efficient code.

lSUBR 3 or more args

boole

( boo 1e k x ,) computes a bit by bit Boolean function of the fixnums x and ,
under the contro,1 of k. k must be a ftxnumbetween 0 and 17 (octal). If the binary
representation of k is abed, then the truth table for the Boolean operation is:
y

I 0

1

01 a
x I
11 b

c
d

If boo 1e has' more than three arguments, it goes from left to right; thus
(boole k x y z) = (boole k (boole k x y) z)
The most common values for k are I (and), 7 (or), ,6 (x or). You can get the
complement, or logical negation, of x bY,(boole 6 x-I).

o

The fo11owing macros are often convenient:
(defun lQgand macro (x)
(subst (cdr x) /f /(boole 1 • f»)
(defun logor macro (x)
(subst (cdr x) /f /(boole 7 • f»)
, (de fun log,xor macro (x)
(subst (cdr x) /f /(boole 6 . f»)

I

I

I

Page 2-80

12-6.8

July 27. 1978

o

Numbers

o

Alternatively, these could be defined with macrodef (see part 6.2):
(macrodef logand x (boole 1 • x»
(macrodef logor x (boole 7 . x»
(macrodef logxor x (boole 6 . x»

SUBR 2 args

lsh

( 1sh x ,,), where x and" are fixnums, returns x shifted left" bits if , is positive,
or x sh if ted right I" I bits jf , is negative. Zero-bits are shifted in to fill unused
positions. The result is undefined if 1,1 > 36. The number 36 is
implementation dependent, but this is the number used in both the MulUes and
pdp-IO implementations. Examples:

(lsh 4 1) => 10 (~ctal)
(lsh 14 -2) => 3
(lsh -1 1) => -2

o

SUBR 2args

rot

(rot x ,,) returns as a fixnum the 36-bit representation of x, rotated left" bits if
, is positive, or rotated right I" I bits if , is negative. x and , must be fixnums.
The results are undefined if 1,,1 > 36. As with lsh, the number gs depends on
the implementation. .Examples:
(rot 1 2) => 4
(rot -1 7) => -1
(rot 601234 36.) => 601234
(rot. 1 -2) => 200000000~00
(rot -6 6) => -501 .

The following feature only exists in the pdp-10 implementation.
The internal representation of flonums may be hacked using these functions. 1sh
or rot applied to a flonum operates on the internal representation of the ftonum
and returns a fixnum result. For example, (lsh 0.5 0) =) 200400000000
(octal). The following function also exists:

· july 27, 1978

12-6.8

Page 2';'81

Maclisp Reference Manual

o

SUBR Z args

fsc

( f sc x ,,) performs a FSC instruction on the two numbers x and " and returns
the result as a flonum. Consult the pdp-IO processor manual if you want to use
this.
x and" may be fixnums or flonums; fsc just uses the machine representations of
the numbers. If" is greater than 7m77 octal, the FSC instruction is omitted and

the possibly-unnormalized flonum with the same machine representation as x is
returned.

o

Page 2-82

12-6.8

July 27, 1978

o
):

o

Character Manipulation

7. Character Manipulation
7.1

Character ObJe.ots

An atomic symbol with a one-character pname is often called a cAaracter object and
used to represent the ascii character which is its pname. In addition the atomic symbol .
with a zero-length pname represents the ascii null character. Functions which take a
character object as an argument usually also accept a string one character long or a
fixnum equal to the ascii-code value for the character. Character objects are always
interned on the obarray (see page 2-58), so they may be compared with the function eq.

ascii

SUBR 1 arg
(asc i i x), where x is a number, returns the character object for the ascii code x.

o

Examples:

(ascii 101) =) A
(ascii 56) =) I.
getchar

SUBR 2 args

(getchar x n), where x is an atomic symbol and n is a ftxnum, returns the n'th
character of x's pname; n = I selects the leftmost character. The character is
returned as a character object. "11 is returned if n is out of bounds.
getcharn

SUBR 2 args

getcharn is the same as getchar except that the character is returned as a
fix num instead of a character object.

o

July 27, 1978

l2-7.

.

Page 2-83

o

Mac1isp Reference Manual

SUBR 1 arg

maknam

maknam takes as its argument a list of characters and returns an uninterned
atomic symbol whose pname is constructed from the list of characters. The
characters may be' represented either as fixnums (ascii codes) or as character .
objects. Example:
(maknam '(a b 60 d»'=) abOd

SUBR 1 arg

implode

implode is the same asmaknam except that' the resulting atomic symbol is
interned. It is more efficient than doing (1 ntern (maknam
although it is
less efficient than plain maknam which should be used when interning is not
required.

x»,

SUBR 1 arg

readlist

The argument to readl ist is a list of characters. The charactets may be
represented either as fixnums (ascii codes) or as character objects. The characters
in th~ list are assembled into an S-expression as if they had been typed into read
(see part 5.1.) If macro characters are used, any usage in the macro character
function of read, readch, tyi, or tyipeek not explicitly specifying an input
file takes input from readl ists's argument rather than from an I/O device or a
file. This causes macro characters to work as you would expect.

o

Examples:
,
(readlist '(a b c» => abc
(read11st '( I( p r 151 n t I l ' f 0 0 I) »
=> (print (quote fool) ;asc11 151 = -1Note the use of the slashified special characters left parenthesis, space, quote, right
parenthesis in the argument to read11st.

Page 2-84

l2-7.1

July 27, 1978

o

II

II

1'1

Character Manipulation

o

SUBR 1 arg

explode

( exp lode x) returns a list of characters, which are the characters that would be
typed out if (pr i nIx) were done, including slashes for special characters but
not including extra newlines inserted to prevent characters from running off the
right margin. Each character is represented by a character object. Example:
(explode '(+ 112 3» => ( I( + I II 11 12 1 13 I) )
;Note the presence of slashified spaces in this list.

SUBR 1 arg

explodee

( exp 1odee x) returns a list of characters which are the characters that would be
typed out if ( pr i ne x) were done, not including extra newlines inserted to
prevent characters from running off the right margin. Special characters are not
slashified. Each character is represented by a character object. Example:
(explodee '(+ 112 3»

=> ( I( + 1 11 12 I 13 I) )

SUBR 1 arg

exploden

( exp 1oden x) returns a list of characters which are the characters that would be
typed out if (pr i ne x) were done, not including extra newlines inserted to
prevent characters from running off the right margin. Special characters are not
slashified. Each character is represented by a number which is the ascii code for
that character. cf. exp 1odee. Example:'
(exploden '(+ 112 3»

flatsize

=> (50 53 40 61 62 40 63 51)

SUBR 1 arg

( f 1a ts i ze x) returns the numberof characters pr 1n 1 would use to print x out.

SUBR 1 arg

flate

( f 1a te x) returns the number of characters pr 1nc would use to print x out,

without slashifying special characters.

o

'July 27, 1978

.12-7.1

Page 2-85

Mac1isp Reference Manual

7.2

o

Character -Strings

These character string functions only exist at present in the Multics implementation
of M ac1isp. A predicate to test if your implementation has these functions is
(status feature strings)
These functions all accept atomic symbols in place of strings as arguments; in this
case the pname of the atomic symbol is used as the string. When the value of one of
these functions is described as a string, it is always a string and never an atomic
symbol. Also see the functions on page 2-56.

lSUBR 0 or more args

catenate

The arguments are character strings. The result is a string which is an the
arguments concatenated together. E~ample: '
.
(catenate "roo" "-" "bar") => "foo-bar·

.0

SUBR 2 args

index

index is like the PL/I builtin function index. The arguments are character
strings. The posjti~n of the first occurrence of the second .argument in the first is
returned, or 0 if there is none. Examples:
(index "roobar" "ban) => 4
(inde~ "foobar" "baz") => 0
(index ~goobababa" ·bab·) => 4

- stringlength

SUBR 1 arg

The argument to stringlength must be a character string. The number of
characters in it is returned. Examples:
(stringlength "foo") => 3
(stringlength •• ) => 0

Page 2-86

12-7.2

July 27, 1978

o

10

Character Manipulation
LSUBR Z or 3 args.

substr

This is like the PL/I substr builtin. (substr x m n) returns a string n
characters long, which is a portion of the string x beginning with its m'th
character and proceeding for n characters. m and n must be fixnums, x must be a
string.
( subs tr x m) returns the portion of the string x beginning with its m'th
character and' continuing until the end of the string. Examples:
.(substr "foobar" 3 2) => nob"
(substr "resultmunger" 6) => "tmunger"

SUBR 1 arg
(get_pname x) returns. the pname of x as a character string. x must be an
atomic symbol.

SUBR 1 arg
make_atom returns an atomic symbol whose pname is given as a character string
argument. Contrary to previous editions of this manual, this atomic symbol Is
interned. Example:
(make_atom "foo") => foo

July 27, 1978

l2-7.2

Page 2-87

o

Maclisp Reference Manual

o

July 27, 1978

12-7.2

Page 2-88

-

------------------~-----------

-------- --

-~--~-----~~~-----~----

-~-

o

. 8.

Arrays

As explained in part 1.2, an array is a group of cens which may contain Lisp objects.
The individual cells are selected by numerical subscripts.
An array is deSignated by a special atomic object caned an array-pointer. Arraypointers can be returned by the array-creation functions array and *array. An arraypointer may either be used directly to refer to the array, or, for convenience in referring
to the array throughinput/output media, it may be placed on the property list of an
atomic symbol under the indicator array, and then that symbol can be used as the name
of the array.
There are several types of arrays. The main types are ordinary arrays, whose cens
can hold any type of object, and number arrays, whose cells can only hold numbers.
Number arrays permit more efficient code to be compiled for numerical applications, and
take less space than an ordinary array which contains the same number of numbers. See
the array* declaration (part '4.2) and the arrayca 11 function (page 2-14).
When an array is created its type must be declared by giving a "type code." The type
code for ordinary arrays is t. For number arrays, the type code is either fixnum or
flonum.A particular number array can only hold one type of numbers because its cens '
contain the machine representation of the number, not the Lisp-object representation.
Some other types of arrays are: un-garbage-collected arrays, with a type-code of nil,
which are the same as ordinary arrays except that they are not protected by the garbage
collector and therefore can be used for certain esoteric hacks; obarrays, with a type-code
of obarray, which are used to maintain tables of known atomic symbols so that the same
atomic symbol will be referenced when the same pname is typed in; and readtables, with
a type-:code of readtable, which areused to remember the syntax specifications for the
Lisp input reader. Normally, there is only one read table and one obarray, supplied by
the system, but the user may create additional read tables and oba:rrays in order to
provide special non-Lisp environments or to gain additional control over the Lisp
environment. Lisp functions such as read can be made to use an additional read table
or obarray by re-binding the variable readtable or obarray, respectively.
An array-pointer may'also be dead, in which case it does not point to any array. One
of the functions array, *array, or *rearray may be used to revivify a dead arraypointer.

o

July 27, 1978

l2-S.

Page 2-89

o

Mac1isp Reference Manual

The functions array and *array are used to create arrays. The first argument
may bean atomic symbol, which makes that atomic symbol the name of an array, putting
an array-pointer on its property list, or redefining an array-pointer that was already on
the property list to point to the new array. Alternatively the first argument may be an
array pointer, whic,h causes that array pointer to be redefined to point to a new array, or
it may be nil, which causes a new array pointer to be created and returned. Except In
the latter case, array returns its first argument. *array always returns the array
pointer, never the atomic symbol.
A readtable or an obarray may not be created with user-specified dimensions. The
dimensions are always determined by Lisp. Other types of arrays allow any reasonable
number (at least 3, anyway) of dimensions to be specified when they are created. The
subscripts range from 0 up to J less 'than the dimension specified.
Ordinary and un-garbage-collected arrays are initialized ton11. Fixnum arrays are
initialized to o. Flonum arrays are initialized to O. O.
Obarrays are initialized according to the third argument given to array or *array.
nil' causes a completely empty obarray to be created. Not even nil will be interned on
this obar~ay. t causes the current obarray (value of the symbol obarray) to be copied.
An array-pointer' whi'ch is an obarray, or an atomic symbol which names an obarray,
causes that obarray to be copied. If no third argument is given, the current obarray is
copied.

0

Readtables are initialized in a similar fashion. If the third argument of array or
*array is nil, then the current readtable is copied. If it is t, then the readtable being
created is initialized to the initia I standard .Lisp read table, including the macro
characters" and ;. (Note that this is the ppposite of the t-n11 convention for obarrays.
This.is. for compatibility with the makreadtab 1e function, which no longer exists.) An
array-pOinter or symbol of a readtable to be copied may also be given. If no third
argument is given, the current readtable is copied.
An array-pOinter may be redefined to an entirely.different type and size of array,
using the *array function. It remains the same array-pointer, eq to itself. If a
variable was setq'ed to the array-pOinter, that variable will now indicate the new array.
If a symbol has that array-pOinter on its property list, it will now, be the name of the new
array.
The *rearray function can be used to redefine the size or arrangement of
dimensions of an array without losing its contents, or to make an array-pOinter not point
to any array (become dead). If there is only one argument, the array-pOinter is killed,
the array's contents are discarded, ,and the array-pOinter becomes a ·dead array· as
described above. *array may now be used to redefine it as a new array.
Page 2-90

12-8.

July 27, 1978

o

Arrays

o

If more than one argument is given to *rearray, they are the same arguments as to
*array. *rearray with more than one argument cannot be used to change the type of
an array, and cannot operate on a readtable Qr an obarray, but it can be used to change
the dimensions of an array. The modified array will be initialized from its old contents
rather than nil, 0, or O. O. The elements are taken in row-major order for
initialization purposes, and if there are not enoug~, nil, 0, or 0.0 will be used to fill
the remaining elements of the modified array, according to the type.

The Multics implementation also has a type of arrays called external arrays.
External arrays reside in a Multics segment rather than within the Lisp environment.
They behave much like fixnumarrays, and should be declared as such to the compiler.
To create an external array, use a form. such as
(array foo external potnter length)

o

The pointer is a packed pointer to the beginning of the array, i.e. a fixnum whose first
six octal digits are the segment number and whose second six octal digits are the word
address. The length is the\ number of words in the array. External arrays can only
ha ve one dimension, can only contain fixnums, and are not initialized when they are
created. They cannot useful1y be saved by ·the save function. This type of array. can be
used for communication between Lisp programs and Multics programs or SUbsystems
written in other languages, when large amounts of numerical data or machine words
must be. passed back and forth. See also defpll (part 4.6).
If you want the range of subscripts on arrays to be checked, it is necessary to set the
*rset flag non-nil (i.e. run in (*rset t) mode) and to avoid the use of in-line array
accessing (i.e. the array* declaration) in compiled programs. The amount of checking
performed when *rset is· nil and/or compiled code is used depends on the
implementation.

o

July 27, 1978

. 12-8.

Page 2-91

Mac1isp Reference Manual

. Here is an example of a use of arrays:
(defun matrix-multiply (arrl arrZ result)
(and (eq (typep arrl) ~symbol)
;convert arguments
(setq arrl (get arrl ~array») ito array-pointers
(and (eq (typep arrZ) ~symbol)
(setq arr2 (get arrZ ~array»)
(and (eq (typep result) ~symbol)
(setq result (get result ~array»)
(do «i1 (cadr (arrayd1ms result») jget relevant
(jj (caddr (arraydims result») jd1mens1ons
(kk (cadr (arrayd1ms arrZ»»
()

(do i 0 (1+ 1) (= 1 11)
jresult := arrl x arr2
(do j 0 (1+ j) (= j jj)
(do «k 0 (1+ k»
(r 0.0»
«= k kk)
(store (arraycall flonum result 1 j) r»
(setq r (+1 r (*1 (arraycall flonum'arrl i k)
(arraycall flonum arrZ'k j)
»»»)
result)

o

lSUBR 3 or more args
(*array x '1 bl b2 ... bn) defines x to be an n-dimensional array. The first
subscript may range from 0 tobl minus I, the second from 0 to 62 minus I, etc. ,
, is the type of array, as explained above. It may be chosen from among: t, nil,
fixnum, f.lonum, readtable, obarray.
array

FSUBR

(array x '1 bl b2 ... bn) has the same effect as (*array (quote x) (quote ,)
bl b2 ... bn). This special form,is provided for your typing convenience.
,II

Page 2-92 .

l2-S.

July 27, 1978

o

Arrays

lSUBR 1 or more args

*rearray

*rearray is used to redefine the dimensions of an array.
(*rearray x) kills the array-pointer x, or the array-pointer which is the array
property of the atomic symbol x. The storage used by the associated array is
reclaimed. The value returned is t if x was an array, nil if it was not.
(*rearray' x t;pe diml dim2 ... dimn) is like (*array x t'!PI dtml dtm2
dimn) except that the contents of the previously existing array named x are copied
into the new array named x. If it is a multi-dimensional array, row-major order is
used. This means the last subscript varies the most rapidly as the array is
traversed.

FSUBR

store

o

The special form (store array-re.f value) is used to store an object into a
particular cell of an array. The first element of the form, arra,-ref, must be a
subscripted reference to an array, or an invocation' of· arraycall. By coincidence,
certain other forms work as array-ref, for instante (app ly f I) where f turns out
to be an array. The second element, value, is evaluated and stored into the
speC:;ified cell of the array. store evaluates its second "argument" before itsftrst
"argument".
Examples:
(store (data i j) (plus 1 j»
(store (sine-values (fix (*1 x 100.0»)
(sin x»"
(store (arraycall fixnum az 1 j) 43)

ar'raydims

SUBR 1 arg

(arraydims x), where x is an array-pOinter or an atomic symbol with an array
property, returns a list of the type and bounds of the array. Thus if A was
defined by (array A t 10 20),
(arraydims /A) => (t 10 20)

o

July 27, 1978

12:'8.

Page 2-93

o

Maclisp Reference Manual

SUBR Z args

f111array

(fill arrayal) fills the array a with consecutive items from the list t. If the
arra y is too short to contain all the items in the list, the extra items are ignored.
If the list is too short to fin up the ~rray, the last element of the list is used to fill
each of the remaining cells in the array.

If,

(f1 llarray x ,) fills the array ~ from the contents of the array,. If, is bigger
than x, the extra elements are ignored.
is smaller than x, the rest -of x is
unchanged. x and, must be -atomic symbols which have array properties, or arraypointers. The two arrays must be of the same type, and' they may not be readtables
or obarra ys.
The list-into-array case of f1 llarray could have been defined by:
(defun fillarray'(a x)
(do «x x (or (cdr x) x»

(n 0(1+ n»
(hbound (cadr (arrayd1ms a»»

«= n hbound»

o

(store (a n) (car x»
)
a)

An extension to the above definition is that f111array will work with arrays of
more than one dimension, filling the array in row-major order. f111array
returns its first ,argumeht.

listarray

lSUBR 1 or Z args

(l1starray array-name) takes the elements of the array speCified by arra,..name
and returns them as the elements of a list. The length of the list is the size of the
arra y and the elements are present in the list in the same order as they are stored
in the array. starting with the zero'th element. If the array -has more than one
dimension row-major order is used.

I

I

-

(11 starray arra,-name n) is the same, except that at most th-: first n elements
win be listed.

arra,-name may be an array-pointer.or an atomic symbol with an array-property.

l2-S. -

~age 2..94

----~-

-------~--~-----

..-------..- - .

_. _. - -- .--------_.. _.- -- _.

July 27. 1978

-~-- . . . .

--------------.-------

..

I

Arrays

c'

Number arrays may be efficiently saved in the file system and restored by using the
functions loadarrays and dumparrays.

loadarrays

SUBR 1 arg

( 1oadarrays file-spec) reloads the arrays in the file, and returns a list of 3-lists,

of the form:

'

( (newname old name size) ••• )
newname is a gensym'ed atom, which is the name of the reloaded array.
(newname ought to be an array-pointer. but this function was defined before arraypointers were invented.) oldname is the name the array had when it was dumped.
size is the number of elements in the' array.
dumparrays

SUBR 2 args

(dumparrays (arra"Jl arra"J2 ••• ) file-spec) dumps the listed arrays into the
specified file. The arrays must be fixnum or flonum arrays. '
In both of the above, the file-spec argument is dependent on the system. In ITS or
DEC-tO Lisp, the file-spec is a list of zero to four items, as in uread, and the
same defaults apply. In MulticsLisp. the file-spec is an atomic symb01 or a string
which gives the paihname of, the segment to be used. The defaults and other
features of the Lisp 110 system are not applied. Only a segment may be specified,
not a stream.
As a special compatibility feature, in Multics Lisp loadarrays win recognize a
pdp-tO dumparrays file. (One can' be moved to Multics through the ARP'A
Network File Transfer Protocol if the "type image" and "bytesize 36" commands
are employed.) The pnames will be converted to lower case and ftonums wi1l be
converted to the H6880 machine representation. dumparrays can create a file
which pdp-to loadarrays can read, including upper-case pnames and pdp-IO
format flonums, jf it is invoked as follows:
(dumparrays (arra"Jl arra"J2 • •• ) , (pdp 10 file-spec»

o

july 27, 1978

l2-S. '

Page 2-95

o

Mac1isp Reference Manual

I

!
Page 2-96

1-2-8.

july 27, 1978

o

o

,M apping Functions

9.

Mapping Functions

Mapping is a type of iteration in which a function is successively applied to pieces
of a list. There are several options for the way in which the pieces of the list are' chosen
and for what is done with the results returned by the applications of the function.
For example, mapcar operates on successive elements of the list. As it goes down the
list, it calls the function giving it a,n element of the list as its one argument: first the
car, then the cadr, then the caddr, etc., continuing until the end of the list is reached.
The value returned, by mapcar is a list of the results of the successive caUs to the
function. An example of the use of mapcar would be mapcar"ing the function abs over
the list (1 -2 -4.5 6.0e15 -4.2). The result is (I 2 4.5 6.0e15 4.2).
The form of a can to mapcar is
(mapcar f x)

c

where f is the function to be mapped and x is the list over which it is to be mapped.
Thus the example given above would be written as
(mapcar /abs
/(1 -2 -4.5 6.0e15 -4.2»

This has been generalized to anow a form'such as
(mapcar (xl x2 ... xn)

In th i sease f must be a function of n arguments. inapcar will proceed down the
lists xl, x2, ..., xn in parallel. The first argument to f will come from xl, the second from
x2, etc. The iteration stops as soon as any of the lists is exhausted.
There are five other mapping functions besides mapcar. ntapl1st is like mapcar
except that the function is applied to the list and successive cdr's of that list rather than
to successive elements of the list. map and mapc are like mapl1st and mapcar
respectively except that the return value is the first list being mapped over and the
results of the function are ignored. mapcan and mapcon are like mapcar and mapl1st
respectively except that they combine the results of the function using ncone instead of
1 i st. That is,

o

July 27, 1978

12-9.

Page 2-97

o

Maclisp Reference Manual

(defun mapcon (f x y)
(apply /nconc (mapl1st f x y»)
Of course. this definition is far less general than the real one.
Sometimes a ·do or a straight recursion is preferable to a map; however. the mapping
functions should 'be used, wherever they naturally apply because this increases the clarity
of the code.
Often f will be a lambda-type functional form rather than the atomic-symbol name of
a function. For example.
(mapcar /(lambda (x) '(cons x something»

some-list)

,The functional argument to a mapping function must be acceptable to app ly - it
cannot be a macro. A fexpr or an fsubr may be acceptable however the results win be
bizarre. For instance, mapping set work~ better than mapping setq, and mapping
cond is unlike~y to be useful.
It is permissible (and often useful) to break out of a map by use of a go, return,
or throw in a lambda-type function being mapped. This is' a relaxation ·of the usual
prohibition against "non-local" go's and return's. If go or return is used the program
rna y have to be compiled with the (mapex t) declaration, depending on the
implementation, so watch out! Consider this function which is similar to and, except that
.it works on a list, instead of on separate arguments.
(defun andl (x)
(catch
(progn
(mapc (function (lambda (y)
(or y (throw nil the-answer»

o

»

x)
t)

the-answer»
Admittedly this could be better expressed as a do:
(defun andl (x)
(do «y x (cdr y»)
«null y) t)
. (or (car y) (return nil»

»
Page 2-98

12-9.

July 27, 1978

o

Mapping Functions

Here is a table showing the relations between the six map functions.
applies function to
successive
sublists

I
I

successive
elements

---------------+--------------+---------------+
its own
second
argument

mapc

map

---------------+--------------+---------------+
returns

list of the
function
results

I

maplist.1

mapcar

I

---------------+--------------+-----~---------+
nconc of the ·1
function
I
mapcon
mapcan
results
I

o

---------------+--------------+--------------~+

mapa toms

LSUBR 1 or Z args

(mapatoms fn obarra.,) applies the function fn to all the symbols on the specified
obarray. If the second argument is omitted, the current obarray is used. Note that the
obarra., argument must be an array-pointer, not a symbol which names an array. The
symbol obarray is bound to the obarray being mapped over during the execution of
mapatoms.
This function exists because some of the cells in an obarray contain lists of symbols
and others contain single symbols, and user programs shouldn't have to know this.
Example:
(mapatoms
(function
(lambda (x)
(and (sysp x)
(print (list x (sysp x) (args x»)

July 27, 1978

14MiC&iAdllll6&JWlQllMiWWIi..4aMiiQ,&mMURWilUMi&i&IiWW&i&ii& _ _

l2-9.

»»

Page 2-99

I

II

0'

o

o

The System

Part 3 - The System
Table ()f Contents

I.

I

C

o

1.1
1.2
1.3
1.4
1.4.1
1.4.2
1.4.3
1.4.4
1.5
1.5.1
1.5.2
1.5.3
1.5.4
1.5.5
1.6
1.6.1
1.6.2
1.6.3
1.6.4
1.6.5
1.7
1.7.1
1.7.2
1.7.3
1.7.4
1.8
1.8.1
1.8.2
1.8.3
1.8.4 '

The System ................... " ............................. 3-1
The Top Level Function ...................................... 3-1
Breakpoints ................................................. 3-5
Control Charactets ...............................
3-9
Exceptional Condition Handling ........ ,....................... 3-15
The LISP Error System ...................................... 3-15
User Interrupts ........................................... ,3-16
Catalogue of User Interrupt Channels..............
3-19
Autoload : . . . . . . . . . . . . . . . . . . ... . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 3- 2 6
3-28
Debugging ............... '...............................
Binding. Pdl Pointers, and the Evaluator ..................
3-28
Functions for Debugging ...................... '............. o. 3-28
The Trace Package ......................................... 3-35
The Stepper .................. ~ ............................ 3-40
The MAR Break Feature ............................
3-55
Storage Management ........................................ 3-59
Garbage Collection.,. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 3-5 9
Spaces ...............................................' ..... 3-60
Storage Control Functions ..................................... 3-63
Dynamic Space and Pdl Expansion .....................
3-64
Initial Allocation ....................................
3-65
Implementing Subsystems with Maclisp .......................... 3-67
Entering LISP ............................................. 3-67
Saving an Environment ...................................... 3-68
Gaining and Keeping Control ............................
o. 3-71
Purity .......................................
3-71
M iscellaneous Functions ..................................... 3-77
The Status Functions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 3-77
Time .. ~ .........................................
3-99
Escaping from LISP ................................
3-99
Additional Functions........................................ 3-101

. August 3, 1978

0

0

0

•••••••••••

••••••

0

0

•

0

0

•••

0

•

•

0

0

0

••

•••••

•••••••

0

•

0

••••••

0

•

0

•••••••

0

0

0

0

•

0

•

0

0

••

0

0

0

••

0

•••

0

0

0

•••

Page 3-1

o

o

0

The System
1

1. The System
1.1 The Top Level Function
The following function is an approximation to what Maclisp does when it is at its

..top Ieve.1..

August 3, 1978

l3-1.

Page 3-1

o

Maclisp Reference Manual

(defun standard-top-1eve1 nil
(prog (~q ~w ~r evalhook base ibase ••• )
'errors
;errors, uncaught throws, etc. come here
;ctrl/G quits come here
(reset~bound-vars-and-restore-pdls)

(setq ~q nil)
(setq ~w nil)
(setq eva1hook nil)
(nointerrupt nil)
,
(do-de1ayed-tty .. and-alarmc1ock-interrupts)
;Recall that errors do (setq II err1ist) so lambda-binding
err11st will work properly. See errl 1st.
(mapc (function eva1) II)
(or (status linmode)(terpri»
(do « eof (1 i st nil»
;interna-I variables
(prt "* *»
;do forever (until ~g or error)
(nil)
«
(setq * (cond stat.us top leve 1 )
(eva1 (status toplevel»)
(t (terpri)
(cond (prinl (funcall prinl prt»
(t (prinl prt»))
(typ 40)
(setq (do «form»(nil)
(setq form
(cond (read
(funcall read
eof»
(t (read eof»»
(or (eq form eof)
(return form»
(terpri»)
(and (null read)
(atom -)
(is-a-space (tyipeek»(tyi»
«lambda (+) (eval··»
(prog2 ni1+ (setq + .»»»»)

o

which causes a "read-eval-print loop," i.e. each S-expression that· is typed in gets
evaluated and the value is printed, then the next S-expression is read. Errors and Ag
quit to top level. That is they reinitialiie and then re-enter this loop, printing a (but

*

Page 3-2

i3-.1.1·

AugustS, 1978

o

The System

o

not destroying the value of the variable *). Notice that there· is a place in the middle
where th~ user can insert his own special form to be evaluated, using (sstatus
top 1eve 1). It is a Iso possible to change just the reader or just the printer by setq'ing
read or pr i n 1. See the sstatus function (page 3-77).
Variables used by the top-level read-eva I-print loop:

VARIABLE

*

Contains the last S-expression printed out by the read-eval-print loop, that is, the.
value of the. last form typed in. This is true even after an error return. to top
level, allowing one to refer to the value printed out before the aborted computation.

VARIABLE

+

Contains the last S-expression typed in. This can be used to edit it or to do it
over again. (Notice how + is bound in the read-eval-print loop. This causes + to
receive the correct va lue even if the evaluation aborts, since an error or Ag quit
will undo the binding.)

VARIABLE
Contains the current S-expression typed in. This can be used by user-written
error handlers. It can't be usefully accessed by expressions typed in, since it is set

before the expression is evaluated.
.

*,

.

By special arrang·ement the values of +,
and - are preserved across a break.
When the break is first entered these have the values for the last top-level operation,
during the break they behave the same as at top level, and after the break returns they
are restored to the values for the top level loop. (See break, page 3-5).

VARIABLE

I

I is used to temporarily hold the vctlue of errl1st when an error returns to top
level. This is so that 1ambda-binding err 1 is t wi11 have an effect (assuming no
one 1ambda-binds I). Note that I must be typed in as II since the. slash
character is special to the LISP reader.

o

August 3, 1978

~3-1.1

Page 3-3

Mac1isp Reference Manual

errlist

Oi

VARIABLE

The va lue of err 1 is t is a list of forms which are evaluated when control returns
to top level either because of an error or when an environment is initially started.
It doesn't apply if the environment started up was saved using (suspend). This
feature is used to provide special error handling for subsystems written in LISP.
The symbol err 1 i st is evaluated to get the list of forms in the binding context in
which the error occurred, but the forms themselves are evaluated in the top-level
binding context.
Example:

«lambda (errlist)
(putprop 'foo 'bar 'baz)
(hack)
(remprop 'foo 'baz»
(cons '(remprop 'foo 'baz)
errlist»

The property list of foo will be properly restored even if the computation (hack)
is aborted.

Page 3-4

~3-1.1

August S, 1978

o

o
I~

I

o

The System

1.2

Breakpoints

Breakpoints are a mechanism to allow the user to gain control at any point in a
program. Use of the function break causes a read-eval-print loop, similar to the one at
top level, to be entered. (This is also caned a break loop.) The user may evaluate any Sexpressions, inspect the bindings of variables, and exit from the break in several ways.
Normal execution then proceeds. (See page 2-43 and page 3-31)
This mechanism can be used to permit human intervention when an unexpected .
condition occurs. It is used in this way by the Mac1isp error system. See the section on
Exceptional Condition Handling, page 3-15. A break loop makes the fun power of the
LIS P interpreter available for debugging.
.

break

FSUBR

(break tag pred) evaluates pred, but not tag. If the value of pred is not nil,
the state of the I/O system is saved, ";bkpt tag" is typed out, and control returns
to the terminal. We say that a "break loop" has been entered. tag may be any
object. It is used only as a message typed out (using prine) to identify the break.
It is not evaluated. If pred is omitted, t is assumed. Thus (break tag) is
equivalent to (break tag t). (break tag nil) returns nil, and produces no
action whatsoever.
A break loop is a read-eval-print loop similar to top level. break does' an err set
so that errors cannot cause an abnormal return from the break. A AX quit, which
causes an ordinary error, wi11 thus return to the break loop if used to interrupt a
computation started in the break I.Oop. A "'g qUit, however, returns back to LISP
top level, resetting the environment using the errl 1st, as described above.
Two forms, IP and (return x), rnay be typed in a break loop. If IP is typed in,
break returns ni 1 and execution continues. This "SP" is <dollar> P in the
Multics implementation, but <altmode> P in 'the POP-tO implementations,
followed of course in either case by a. <space> or <newline> as appropriate (see
(status linmode». (An atom other than SP can be used to perform this
function by changing the value of IP to another (non-n i 1) atom. The initial
value of IP is always IP).
If (return x) is typed in, break evaluates x and returns that value. If as a
result of the evaluation of a typed-in form, (throw x break) is evaluated,
break returns x as its value. (Notice the distinction - executing a form (return

iO. · ·
I

August 3, 1978

l3-1.2

Page'S-5

usaW'&JliMIAik&AM

~acltsp Reference Manual

o

x) does not return from break unless it was typed directly ·at the break loop.)
~ee return, page 2-43.
.

When break returns, the state of thel/O system is restored.
An approximate LISP defini~ionof what break does follows. Note that the user
program can modify this by using (sstatus breaklevel).

o

Page 3-6

13-1.2

August S, 1978

·0

The System

o
(defun br~ak fexpr (x)
(*break (eva 1 (cadr x»

(car x»

;note argument reversal

(declare (special Aq AW evalhook * + -»
(defun *break (breakp breakid)
(and breakp
(do «Aq nil) ("w nil) (evalhook nil) (terpri t) (* *) (+ +) (()
; bind key variables
. (terpri msgfiles)
;msgfiles arguments
(pr i nc "I; bkpt I msgfi les)
used for.
(princ breakid msgfiles)
; ~ewioonly
(terpri ~sgfiles)
(setq + -)
; last form typed
(return
(prog2 nil
(catch
(do () (n ; 1 )
;~o forever (until throw)
(errset
(do «eof (list nil» (form»
(nil)
(cond «status breaklevel)
(eval (status breaklevel»)
(t (setq form (c~nd (read (funca11 read eof»
(t (read eof»» .
(and (null read)
(atom form)
(is-a-space (tyipeek})
(tyi »
(cond «eq form eof) (terpri»
«and IP (eq form "IP» (throw n11 break»
«eq (car form) "return)
(throw (eval (cadr form» break»
(t (setq - form)
(print
(setq * «lambda (+) (eval form»
(progZ n11 + (setq + -»»)
(terpri»»»»
break)
(terpri)

-»

o

))))

o

August 3~ 1978

Page 3-7

Maclisp Reference Manual

The arguments to' break are a breakpoint identification and (optionally) a break
switch.. If the break switch evaluates to nil, then nil is returned. Otherwise, the
variables "'q, "'w, evalhook and terpr1 are bound to nil, the variables., +, and - are
bound to their current values, and the message"; bkpt <breaktd>" is printed. A readeval~print loop similar to the top level loop is then entered. This break loop is
,surrounded by an err set. Errors or typing "'x merely cause the break loop to be reentered. The value of (status breaklevel) serves a function similar to that of
(s tatus top 1eve 1) in the top level loop.
As each form is read in the default break loop, there are four cases:
l. End of file. For console input this merely indicates rubout beyond the number
of input characters. Whether input is from console or elsewhere, the (terpr 1 )
is done and the reader is entered.

2. The form is the atom IP or eq to the non-n i 1 value of ap. nil is returned
from the break.
3. The form is (return value). The form value is evaluated and returned from
the break.
i. Otherwise the form is evaluated and the result printed out in a manner
analogous to the top level read-eval-print loop. The variables +; -. and
are updated appropriately. (Recall, however, that they. were bound· on entry to
*break, and so will be restored eventually.)

*

o

The way to return from a break is. to do a throw with a t~g of break; this will
return from the catch which surrounds the break loop. This is how cases 2 and 3
return their values; case 4 may also cause a return from the break.

!3-1.2

August 3,.1978

o

o

The System

1.3 Control Chara'cters
LISP can be directed to take certain actions by entering "control characters" from the
termina 1. The difference between control characters and normal input is that control
characters take effect as soon as they are entered, while normal input only takes effect
when LISP asks for it, by use of functions such as read, or by being in the top level
read-eval-print loop or in a break loop.
Control characters can be typed in from the terminal according to some procedure.
that depends on the implementation. A program can mimic the effects of the various
control characters by directly ca11ing the function associated with the particular control
key (see below).
Although control characters are usua11y processed as soon as they are typed, they may
be delayed if there is a garbage collection in progress or LISP is in (no 1n terrupt
tty) mode - see the nointerrupt function (page 3-18).

Entering Cont'rol Characters in ITS LISP

c

In the ITS implementation of Mac1isp, control characters are entered by means of the
"CTR L" key on the terminal. For example, CTRL/g is entered by holding down
"CTRL" and striking the "G" key. Control characters normally echo as an uparrow or
circumflex followed by the character.
.
In Newio, any character at all may be made an interrupt character. See (sstatus
tty) and (sstatus ttyint) .
. Interrupt characters are also read as part of the terminal input stream. Normally
they are marked in the readtab 1e as "worthless" characters.

Entering Control Characters in TOPS-10 LISP
Most control characters may be entered in the same way as in ITS LISP if LISP is
currently read'ing from the ,terminal. If a LISP program is actively running, it is
necessary to first gain its attention by typing the CTRL/c character one or two times,
thereby returning to the monitor. The monitor command REENTER may then be used
to re-enter the LISP. LISP will print "?""" and read a character, which may be a control
cha racter or a character whose "control" meaning is to be used. Thus typing either A g or
"c" will cause the ""g interrupt to occur.· If LISP is not ready to take an interrupt,
there may be a delay before the "?""" is printed.

o

Entering Control Characters in Multlos LISP
August 3, 1978

~3-1.3

Page 3-9

Maclisp Reference Manual

In the Multics implementation of Maclisp, one signals one's desire to enter a
"contrql" character by hitting the "attention" key on the terminal. (This is called "break,"
"interrupt," . "attn," "quit," etc. on different terminals. If MulUcs is being accessed
through the AR PA network, an "interrupt process" (@S S or @S I P from a TIP) signal
should be transmitted.) LISP responds by typing out "CTRLf". Now you may type one
letter from the list later in this section, which will be interpreted to have its "control"
meaning. This control character must be followed by a newline.
It is a Iso possible to enter ~'control" characters from an input character stream, which
may have its source at the terminal or in an exec_com, without the use of the "attention"
key. The desired control character is prefixed by a \036 character. If two of these prefix
cha racters occur together, one \036 character is read and no "control" action is
performed. OtherWise, the character following the \036 is processed as a control
character, then reading continues.
Control characters will be accepted in upper or lower case. All characters other than
those with defined meanings are .rejected with an error message. Only one control
character maybe enteted at a time.
Example for Multics LISP:
(lines containing user input are preceded by"»>")

»>
>>>
>>>
>>>
>>>

»>

o

(defun loop (x) (loop (addl x»)
loop
,( loop 0)
function runs for a long time,
(ATTN> then user hits attention button.
CTRL/B LISP types "CTRl/", user types "B"
; bkpt "'b
system enters break loop
x
user looks at value of x
4067

»>
>>>.

(ATTN>
CTRL/G
Quit

user hits attention button again
and returns to fop level

*

When a "user interrupt" is caused, if the interrupt is not enabled nothing happens. If
the interrupt is enabled, then a user-specified function is called. The interrupt may be
enabled by binding the appropriate symbol to the function to handle it, or by using the
(sstatus ttyint) function (page 3-78).

In the following descriptions of control characters, those which can always be

Page 3-10

!J-1.J

August 3, 1978

The System

o

processed immediately, even during it garbage collection or in (nointerrupt 'tty)
mode. will .be indicated by an "!" for the ITS and TOPS-IO implementations, and an "fl."
for the Multics Implemention. When appropriate, equivalent LISP code is given for
producing the same result from a user program.
Control Characters that have initially defined meanings in all implementations:
B !~::

runs a break loop with breakid "Ab" (see break, page 3-5). (In the PDP10 Oldio implementation Ah is used instead of Ab.) (break Ab).

C !::~

sets the value of the atom Ad to n1 1, turning off garbage collector messages.
Because AC is trapped by DEC-tO monitors, this control character can only
be typed using the REENTER mechanism and typing He". (setq Ad
nil ).

D !::~

sets the va lue of the atom Ad to t, turning on garbage collector messages.
(setq Ad t)

G

quits back to the top level of LISP, rebinding all variables to their global
values, resetting various system variables, and evaluating the errl i st
forms. This is used to stop a running program when there is no intention
of restarting it again. (Prints out a *; see the "top level" function and the
Ag function.) H is used instead of Ab in some implementations (see above).

Q!

sets the value of the atom. Aq to t, enabling input from the source selected
by the value of infi 1e, or selected by.use of the function uread. In the
. PDP-IO Newio implementation, this is not an int~rrupt character; instead
it is a macro character, and takes effect only "if processed by read. (setq

o

AQ t).

o

.

R!

sets the va 1ue of the atom Ar to t, enabling output to the destinations
selected by the value of outfi1es, or selected by use of the uwrite
function. (setq ~r t).

S!

turns off typeout until input is read. This is used to suppress the rest of
the typeout from the current. request, without affecting typeout from the next
request that is typed in. It is implemented by setting AW to t, then putting
a macro character in the input stream which sets AW to nil and does a
( terpr i ) when it is read.

T !

sets the value of the atom Ar to nil, disabling output to the destinations
that CTR L/r enables. (setq Ar nil).

August 3, 1978

~3-1.3

Page 3-11

o

Maclisp Reference Manual

U

causes the current call to read to be restarted from the beginning. (Not
available in PDP-IO implementations).

V !

sets the value of the atom "w to ni 1, enabling output to the terminal.
(setq "wn i 1 ).

W !

sets the value of the atom "w to t, disabling output to the terminal. (setq
"w t) (and possible also (c 1ear-output tyo».

X

causes an error which can be caught by errset. This is a less drastic
"quit" than CTRL/g. If it is typed within a break loop, it win return no
further than the break loop, since break uses errset. (error / qu it).

Z !:~

On ITS returns to ITS command level, i.e. DDT. On Multics returns to

Multics command level. (start re-enters LISP.) On TOPS-IO goes to DDT
if a DDT has been loaded with LISP.
The following control characters only exist in the Multics implementation.
. !:::

does nothing, and is used merely to speed up a slow process by causing an
interaction.

? !::I

asks the LISP subsystem what it is doing: running, waiting for input,
collecting garbage, or running with tty-interrupts masked off.

o

The following control characters only exist in PDP-IO implementations with the
"moby 1/0" capability. (For now, this means only at the MIT AI Laboratory.) (see
(sstatus ttyscan ),' page 3-81).

F

Cause graphics display slave to seize a display.

N

Turn on display for character output.

o

Turn off display for character output. .

Y

Cause display slave to release display.

The following control characters only work in the PDP-IO implementation. They are
not really interrupts, but occur only when processed by the terminal input prescanner (see
(sstatus ttyscan), page 3-81).

K

Page 3-12

redisplay the <;urrent input. This allows you to get a clean copy of your

f3-1.3

August S, 1978

o

The System

o

input after rubouts have been used. (On a display console, LISP win
. attempt to ma ke rubbed-out characters actually disappear from the screen .
.... k is still useful if a timing error disrupts this process.)
L

erases the screen if the terminal is a display, then does a CTRL/k.

Control-Character Functions
SUBR 0 args
Produces a.quit to top level just as if a CTRL/g had been typed.

These functions exist only in the PDP-IO Oldio and the Multics implementations.
They are being phased out, so using them in new programs is not recommended.

FSUBR

10c

C

The a rgument to 10e is processed as if it were a "control character" that had been
typed in. Numbers are taken as a· whole, atomic symbols' pnames are processed
c~aracter by character, except that nil is ignored .. Examples:
causes user interrupt 1.
(ioe vt) switches output to the terminal.
(ioe Q) . switches input to a file.
(ioe g) quits back to the top level of LISP.
(ioe 1)

If i oe returns, its value is t.

FSUBR

log

log first saves the values of the I/O switches A Q , A r , and ....w. Then it processes
its first argument the same as ioc. Next the remaining arguments to 10g are
eva 1uated, from left to right. The values of the variables .... q, "r, and Aware
restored, and the value of the last argument is returned. Example:

(iog vt (prine "A Message."»

o

August 3, 1978

~3-1.3

Page 3-13'

o

Mac1isp Referen(:e M~nual

I

1-

g"ets a message to the console no matter what the 110 system is doing. It evaluates
to "A Message. n

(1og a xl xl ... xn)
ca n a Iso be written
«lambda (Aq Ar AW)
(ioc a)

xl
xl
xn)
nil nil nil)

o

Page 3-'14:

l3-1.3

August 3, 1978

o

The System

0

"1.11
"

1.4

Exceptional Condition Handling

The LISP Error System
The errors detected by the LISP system are divided into two types: correctable and
uncorrectable. The uncorrectable errors will be explained first since they are simpler.
An uncorrectable error is an error that causes the evaluation in which it occurs to be
aborted. When an uncorrectable error occurs, the first thing that happens is the printing
of an error message. In Oldio, the error message goes to the terminal and nowhere else
(unless suppressed, see errset, page 3-20), no matter how the I/O switches and
variables are set. In Newio, the variable msgf11es is a list of the files to which error
messages should be routed; this initially is just the terminal. The error message consists
of some explanatory text and (usually). the object or form that caused the error.
After the error message has been printed, control is returned to the most recent errorcatcher. There is an error-catcher at top level, and error-catchers are set up by the
function err set (and break, which uses er'7set). All variable bindings between the
error-catcher and the point where the error occurred are restored. Thus all variables are
restored to the values they had at top level or at the time the errset was done, unless
they were setQ'ed free (without being bound).
What happens next depends on how the error-catcher was set up. At top level, the
forms on the err 1 is t are evaluated and the top level loop (or a user specified top level
form) is re-entered. (The symbol errlist is evaluated prior to the above restoration of
bindings, and saved in the variable /. In this way the err1 1st used is the one current
at the time of the error, despite the restoration of bindings.) If an error returns to
break, it simply re-enters its read-eval-print loop. In the Multics implementation the
fact that break has caught an error is signalled by ringing the bell on the terminal. If
an error returns to errset, err set returns nil and evaluation proceeds. If an error
returns to top level, the state of the world is reset and * is typed.
The above description is slightly simplified. The user can request an interrupt to
occur betwe,en the typing of the message, and the unwinding of bindings and return of
control to an error-catcher. If the error is going to return to ,top level, the *rset-trap
user interrupt is Signalled. This user interrupt is initially a system-supplied break loop
which allows the user to examine the values of variables before the bindings are restored,
in hope of finding the cause of the error. In (*rset t) mode a break loop is entered,
but in, (*rset n 11) mode the user interrupt is ignored. If the error is going to return

o

August 3, 1978

l3-1.4

Page 3-15

Ei11iIMW1iWIia_=====A8&WM44 A,g\1$##U 1¢#l444 4, 4J q;

aM

#¥AM A

W41ITMI, W4

Mac1ispReference Manual

o

to a break or an errset, and *rset is non-nil, the· errset user interrupt is
signal'ed. The initial environment contains a null handler for this interrupt, but the
user may supply a break loop or other handler.
Correctable errors are errors which may be corrected by user intervention. If such an
error is properly corrected, evaluation will proceed as if no error had occurred. If the
option to correct the error is not exercised, this type of error will be h~ndled as if it were
an uncorrectable error.
When a correctable error occurs, a user interrupt is signalled. See page 3-19 for
user interrupt channel assignments for these errors.' The initial environment contains
handlers for these errors which print an error message simi1ar to the message printed for
an uncorrectable error and then enter a break loop.
The a rgument passed to the user interrupt handler is an S-expressjon describing the
error. See section 1.4.2 for details. If the user interrupt handler is nil, or jf it returns
a non-list, the error i-s treated as an uncorrectable error. But if the handler returns a
list, the first element of that list is used to correct the error in a way which depends on
the particular error which occurred.
I f the most recent error-catcher is not top-level, correctable errors will be treated as
uncorrectable errors unless there is a non-null handler for the err set interrupt. This
is to prevent confusing "multiply nested" error breaks unless the user indicates tflat he
is sophisticated by setting up a handler for the errset jn.te.tr.~pt:.,.(T'~',errset,handler
itself is Olilly'jnv6ked, if *rset is non-nil, however.)' . "',: ,,:' :: .~" :: , .',
'

o

See the functions error, err, and errset.

1.4.2

User Interrupts

LISP provides a number of "user interrupts," which are a mechanism by which a user
procedure may temporarily gain control when an exceptional condition happens. The
exceptional conditions that use the' user interrupt system include certain control
characters, the alarmc10ck timers, asynchronous I/O conditions, the garbage collector, and
many of the errors that are detected by the interpreter or by the system functions. Errors
detected by user functions can use this mechanism also.

II
I

The user interrupts are divided up into several channels. Each channel has
associated with it a service function. If the service function is nil, interrupts on that
channel will be ignored. If the service function is not nil, it is a function which is

Page 3-16

~3-1.4.1

- - - - _._-------

August 3, 1978

II
I

o

The System

o

ca ned with one argument when the user-interrupt occurs. (A few interrupt handlers
take more t.han one argument. See the specific descriptions.) The nature of the argument
depends on which channel the interrupt is on; usually it is an S-expression which can be
used to localize the cause of the interrupt. Some user interrupts use the value returned
by the service function to decide what to do about the cause of the interrupt.
Interrupts can be either synchronous (e.g. errors and garbage collector interrupts) or
asynchronous (col1trol chara'cters, a larmclock, etc.). To prevent timing errors,
asynchronous interrupts are always run in (no interrupt t) mode. A handler for an
asynchronous interrupt must explicitly do (nointerrupt n 11) to permit other
asynchronous errors to interrupt it. (For example, the system-supplied "b' handler does
this so that control character interrupts can be used within the "b break loop.)
The service functions for most user interrupts are kept as the values of symbols with
mnemonic names. A list of these symbols begins on page 3-19. There are also user
interrupts for control characters. The service functions for these are declared using
(sstatus ttyint). See page 3-78.

C.

I

The initial values for the service functions of the various interrupts are prOVided by
the system as break loops for some interrupts and nil for others (except for some
control characters).

)

Ther~ are some special considerations for user interrupts signalled by correctable
error conditions.' The argument to the service function is a description of the error
whose exact form is described in the catalogue at the end of this section. If the service
function returns n i 1 (or any other atom), the normal error procedure occurs ~-control
returns to the most recent errset, or to top level if there was no errset. If the service
function returns a list, the first element of the list is used to attempt recovery from the
. error: The exact way that it is used is described in the catalogue. If recovery is
successful execution proceeds from the point where the error occurred. If recovery is
unsuccessful another error is Signalled.
'

'Here is an example ,of a user interrupt service function. This is the one· supplied by
the system for unbound variable errors when the user does not specify one. Note that .the
system-supplied error service functions consistently bind ergs to the argument supplied.
The user can check the value of this variable to see .what is wrong. Note too that the
system-supplied error handlers restore readtab 1e and obarray before breaking.

o

August 3, 1978

~3-1.4.2

Page 3-11

Mac1isp Reference Manual

. (defun +internal-ubv-break (args)
(declare (special args»
(errprint nil msgfi1es)
; print· error message
«lambda (readtab1e obarray)
(nointerrupt nil)
(break unbnd-vrbl»
(get ~readtable~array)
(get ~obarray ~array»).
(setQ unbnd-vrbl ~+internal-ubv-break)

alarmclock

SUBR 2 args

a 1armc lock is a function for controlling timers. It can start and stop two
separate timers; one is a real-time timer (which counts seconds of elapsed time)
and the other is a cpu-time timer (which counts microseconds of machine run time).
·The first argument to alarmclock indicates which timer is being referred to: It
may be the atom time to indicate the real-time timer or the atom runt tme to
indicate the cpu-time timer.
The second argument to alarmclock controls what is done to the selected
timer. If it isa non-negative number (fixnum or flonum) the timer is started.
Thus if' n is a positive fixnum' or flonum, evaluating (alarmclock "time n)
sets the real-time timer to go off in n seconds,'and (alarmclock "runtime n)
sets the cpu-time timer to' go off in n microseconds. .If the timer was already
running the old setting is lost. Thus at any given time each timer can only be
running for one alarm, but the two timers can run Simultaneously.

o

If the second argument to a 1armc lock is not a positive number, the timer is
shut off, so (a 1armcl ock x nil) or (a 1armcl ock x -1) shuts off the x timer.

a 1armc lock returns t if it starts a timer, nil if it shuts it off.
When a timer goes off, the a 1armc lock user interrupt occurs. The service
function is run in (no interrupt t) mode so that >it will not be interrupted
while it is performing its service. If it wants to allow interrupts, other timers, etc.
it can evaluate (no interrupt nil). In any case the status of the no1 nterrupt
flag will be restored when the service function returns. The argument passed to
the user interrupt service function is the atom time or the atom runt 1me, .
depending on which timer went off. See also the function nointerrupt.

Page 3-18

13-1.4:2

August S, 1978

o

o

The System

SUBR 1 arg

nointerrupt

( no interrupt t) shuts off LISP interrupts. This prevents alarmc10ck
timers from goin'g off and prevents the use of control characters such as CTR Ltg
and CTR LIb. Any of these interrupts that occur are simply sa ved.
(no interrupt t) mode is used to protect critical code in large subsystems
written in LISP. A similar deferral technique is used by the LISP system itself
to protect against interrupts in the garbage col1ector.
( no interrupt ' tty) prevents control characters (typed on the terminal, or
"tty") from causing 'interrupts; however, alarmclock interrupts (and other
asynchronous interrupts) are still allowed. Any non-tty asynchronous interrupts
which were saved will now go off.
(no interrupt nil) turns interrupts back on. Any interrupts which were
sa ved will now get processed. This is the normal, initial state.
The result returned from no 1nterrupt is the previous interrupt status - nil,
t, or tty.

o

Example:
«lambda (oldstatus)
<protected code>
(nointerrupt oldstatus»
(nointerrupt t»

1.4.3

Catalogue of User Interrupt Channels

Each user interrupt channel (except some associated with files) has a variable whose
value is a functional form, the service function for that channel. The name of the
interrupt channel is the same as the name of the variable. The following lists the user
interrupt channels in alphabetical order. The argument to which' the service function is
applied and the value which it should return are described. By convention, almost a11
serv'ice functions receive one argument. Some user interrupts are initially set to a
system-supplied handler which binds, the variable args to this argument and enters a
brea k loop. The name of the interrupt is used as the break identifer.
Some user interrupts ignore the value returned by the service function, while others.

August 3, 1978

~3-1.4.2

Page 3-19

o

Mac1isp Reference Manual

distinguish two cases. If the value is atomic, the service function was not able to recover
from ~he condition that caused the interrupt. LISP will take its default action, such as
returning control to the most recent errset. If the value is a list, the car of that list is
used to recover from the condition that caused the interrupt. It is usually a new piece of
data to be used in place of the one that was being complained about, or a new form to be
evaluated in place of the form that erred.
If the' value of the service-function variable is nil instead of a functional form, the
user interrupt is considered to be turned off. The system behaves as if the function had
run and returned ni 1.

Some user "interrupts are asynchronous in nature, and are executed in
(nointerrupt t) mode to prevent timing errors. The interrupt handler may choose to
run in (nointerrupt nil) mode, however, as the initial Ab handler does. The
no interrupt mode is restored after the handler is run. Such interrupts are themselves
deferred by (nointerrupt t) mode.
alarmclock

VARIABLE

The value of alarmclock is the service function for the user interrupt signal1ed when a
timer set up by the a 1armc lock function goes off. The argument is the name of the
timer which went off, time or runtime. The returned value is ignored. The service
function is executed in (no interrupt t) mode. This in"terrupt is initial1y turned off.

autoload

o

VARIABLE

The value of autoload is the service function for the user interrupt which provides
automatic loading of program packages into the environment. The argument is
(function-name. autoload-propert,,). The returned value is ignored. See page 3-26 for
details. This interrupt is initially set to a function which simply loads a file.

eli-message

VARIABLE

The value of cl i -message service handler for the user interrupt signalled when
another job has interrupted the LISP job via the eLI device. The argument is nil and
the returned value is ignored. A user handler is expected to open a file on the CLA
d.e·vice and read the message from the other job. The service function is run in
(no interrupt t) mode. This interrupt is initially turned off. Currently, it exists only
in the ITS Newio implementation.

l3-1.4.3

Page 3-20

._-------_....-....----_.. _-_..... --_ .. --

.---

.•

__

._--

~~~

----..

--~--.--------

August 3, 1978

o

o

The System

err set

VARIABLE

The va lue of err set is the service function for the user interrupt which is signalled
when an error is caught by an err set and *rset is non-n i 1. The argument is nil
and the returned value is ,ignored. This user interrupt is initially off. Turning it on
a ffects the behavior of the error system (see page 3-16).

fail-act

VARIABLE

The value of ~a ; l-act is the service function for the user interrupt which is signa11ed
when any of a large variety of miscellaneous error conditions occurs. The argument is a
list whose first element is generally a symbol which describes the type of error condition.
The rest of the list contains various objects related to the error. The returned value
depends on the error. These are not standardized and will not be described here. This
interrupt is initially set to a break loop.

gc-daemon

()

VARIABLE

The value of gc-daemon is the service function for the user interrupt which is signalled
after each g-arbage collection. The argument is a list of items; in the POP-to
implementation each item is of the form (space-name free-before free-after size-before
size-after) and in the Multics implementation, each item is of the form (space-name
• free-before. free-after). The returned value is ignored. This interrupt is initially
turned off.

gc-lossage

VARIABLE

The value of gc-lossage is the service function for the user interrupt which is
signalled when there is no more available address space or when the Time Sharing
Monitor rejects a request for more memory. In the Multics implementation, there is
a 1wa ys e,nough memory, so this user interrupt never occurs. In the PDP-IO
implementation the ar'gument is the name of the space that lost, and the returned value
is ignored. This interrupt is initially set to a break loop.

gc-overf1ow

VARIABLE

The value ofgc-overf1ow is the service function for the user interrupt which is
signa lied when a space overflows its gcmax. (see all oc and (status gcmax ).) The

o

August 3, 1978

Page 3-21

· Maclisp Reference Manual

0

argument is the name of the space. The returned value is ignored. This interrupt is
initially s~t to a break loop.

io-lossage

VARIABLE

The value of i o-lossage is the service function for the user interrupt which is
signa tled when the 110 system encounters an error (for example, a file which was being
opened was not found). The argument is a list of the name of the function which erred
and its arguments, which may have been standardized or otherwise partially digested.
The returned value is a Jist of a new form to be evaluated in place of the can to the
function which erred. This interrupt is initially set to a break loop.

machine-error

VARIABLE

The value of machine-error is the service handler for the user interrupt signalled
when some difficulty is experienced by the host machine. The service function receives
four arguments instead of one. The first is an atomic symbol indicating the type of
error:

eva 1
illegal machine operation
exami ne
attempt to reference non-existent memory
depos it
attempt to write into read-only memory
oddp
parity error
The other three arguments are fixnums which are addresses of memory locations. The
second is the location of the error; the third is the program counter when the error
occurred; and the fourth is the jPC (the program counter as of the l~lSt jump
instruction before the error occurred). The machine-error handler may signal a
different kind of error or a "'g quit (see the "'g function) if desired, or enter a break
loop. The subr function (see page 3-101) may be useful in decoding the three fixnum
a rgunlents. If the handler returns, the value is ignored and the erroneous operation is
retried. If the user provides no mach ine-error handler (the interrupt is jnitia1ly
turned off), the error is handled in th~ default manner for the host machine. On ITS,
this puts the· user in DDT. This currently exists only in the PDP-IO Newio
implementation.
Example:

Page 3-22

13-1.4.3

August S, 1978

o

o

1

C"

The System

"

(defun maehine-error-handler (type loe pe jpc)
«lambda (args terpri)
(deelare (special args terpri»
(terpri msgfiles)
(cond «eq type 'examine)
(prine 't;REFERENCE TO NON-EXISTENT
MEMORYI msgf1les»
«eq type"deposit)
(prine 'I;WRITE INTO ,READ-ONLY MEMORYI
msgfiles»
«eq type 'eval)
(prine 'I;ILLEGAL MACHINE OPERATION I
msgfiles»
«eq type 'oddp)
(prine 'I;MEMORY PARITY ERROR I
msgfiles»
(t (prine 'I;UNKNOWN MACHINE ERROR I
msgfiles»)
(prine 'I FROM LOCATION I msgfiles)
(prirte pc)
(prine 'I IN FUNCTION I msgfiles)
(prinl (subr pc»
(break machine-error»
(list type loc pc jpc)
t) )

mar-break

VARIABLE

The value of mar-break is the service handler for the user interrupt signalled when the
memory location specified by (sstatus mar) (see page 3-95) has been accessed in the
specified manner. The argument is nil and the returned value is ignored. The service
function is run in (noi nterrupt t) mode. Also, LISP implicitly performs (sstatus
mar 0 nil) before running the user interrupt; this helps to prevent infinite loops. This
interrupt is initially turned off. It currently exists only in the ITS Newio
implementation. See page 3-55 for mo~e information on using this interrupt.

August 3, 1978

l3-1.4.3

Page S-2S

Mac1isp Refer:ence Manual

pdl-overflow

- VARIABLE

The value of pdl-overflow is the service function for the user interrupt which is
signalled when a pushdown list exceeds its pdlmax. (see alloc and (status.
pd lmax ).) The argument is the spacename of the pushdown list. The returned value is
tgnored. This interrupt is jnit.ially set to a break loop.

VARIABLE

sys-death

The va lue of sys-death is the service handler for the user interrupt signalled when the
time-sharing system is about to go down, has been revived from that state, or is being
debugged. The argument is nil and the returned value is ignored. A user handler
may wish to examine the result of. (status its) to determine the state of the system.
The service function is run in (nointerrupt t) mode. This interrupt is initially
turned off. This currently exists only in the ITS Newio implementation.

tty-return·

VARIABLE

The value of tty-return is the service handler for the user interrupt signalled when
control of the ter~ina.1 is returned to the LISP job by its superior. This allows LISP to
determine that the display screen may .have been changed by other jobs. The argument is
nil a nd the returned value is ignored. The service function' is run in (no 1nterrupt
t) mode. This interrupt is initially turned off. This currently exists only in the ITS
Newio implementation.

o

VARIABLE

unbnd-vrbl

The value of unbnd-vrb 1 is the service function for the user interrupt which is
signa lied when an attempt is made to evaluate an atomic symbol which does not have a
value (an unbound variable.) The argument is a list of. the symbol which could not be
evaluated. The returned value is a list of a new symbol to be evaluated in its place.
This interrupt is initially set to a break loop.
.

VARIABLE

undf-fnctn

The value of undf -fnctn is the service function for the user interrupt which is
signa lied when an attempt is made to apply an undefined function. The argument is a
list of the functional form which could not be applied. The returned value is a list of a
new functional form to take its place. This interrupt is initially set to a break loop.
13-1.4.3

. Page 3-24

-.-~~~~~--

--~---~~--~-----

- - -

August 3, 1978

o

The System

unseen-go-tag

VARIABLE

The value of unseen-go-tag is the service function for the user interrupt which is
signa lled when go or throw is used with a tag which does not exist in the current prog
body or in any catch, respectively. The argument is a list of the erroneous tag. The
returned value is a list of a new tag to replace it. This interrupt is initially set to a
break loop.

wrng-no-args

VARIABLE

The value of wrng-no-args is the service function for the user interrupt which is
signa11ed when a function is called with the wrong number of arguments. The
argument is a list of two items: First, a list of the function and the arguments that were
passed. Second, the 1ambda-list if the function was interpreted, or the same dotted pair
as args returns if the function was compiled, or the atom ? if this information could not
be determined. The returned value is a list of a new form to be evaluated in place of the
losing one. This interrupt is initially set to a break loop.

o

wrng-type-arg

VARIABLE

The va lue of wrng-type-arg is the service function for the user interrupt which is
signalled when an argument is passed to a system function Which is not acceptable to
that function. The argument is a Hstof the argument which was not accepted. The
returned value is a. list of a new argument to replace it. That is, directly an argument,
not a form to be. evaluated to get an argument. This interrupt is initia1ly set to a
break loop.

*rset-trap

VARIABLE

The value of *rset-trap is the service function for the user interrupt which is
signa lied when an error returns control to top level, just before the bindings are restored.
By convention, the handler for this interrupt should not do anything unless the variable
*r set is non-n i 1. This is so that the user will not be bothered unless he has put LISP
in debugging mode. The argument is nil and the returned value is ignored. This
interrupt is initially set to a function which enters a break loop if *rset is non-n 11.
There are other interrupt handlers which are associated with I/O files or inferior
jobs. See eoffn, endpagefn, (sstatus ttyint), and create-job.

o

August 3,.1978

~3-1.4.3

Page 3-25

Maclisp Reference Manual'

1.4.4

o

Autoload

The auto load feature provides the ability for a function not present in the
environment to be automatically loaded in from a file the first time it is caned. When
eval', appiy, funcal1, or the version of apply used by compiled LISP searches the
p~operty list of an atom looking for a functional property, and fails to find one, it looks
for a property under the indicator autoload, and it it finds one, automatic loading will
occur_
Automatic loading is performed by means of the autoload user interrupt; thus the
user may assert any desired degree of control over it. When the autoload property is
encountered, the user interrupt handler is called with one argument, which is a dotted
pa-ir whose car is the atomic symbol which is the function being autoload'ed, and whose
cdr is the value of the auto load property. The system-supplied handler for this user
interrupt could have been defined by:
(setQ autoload
(function (lambda (x) (load (cdr x»

»)

From this one can see that the value of the autoload property should be the,name of the
file which contains the definition of the function. Note: in the TOPS-tO
implementations the system autoload handler presently uses fasload rather than load
beca.use the load function requires the Newio feature. This affects the form of an
auto load property.

o

When the interrupt handler returns, it should have put a functional property on the
property list of the function being autoloaded. If not, an undf -fnctn error win occur
with a message such as "function undefined after autoload."
Examples of setting up functions to be autoloaded:
In the Multics implementation:
(putprop 'foo ")udd)AutoProg>l1brary>foo-funct10n" 'autoload)
In the PDP-tO Oldio implementation:
(putprop 'foo '(f~o fasl dsk me) 'autoload)
In the PDP-tO Newio implementation:'
(putprop 'foo '«dsk me) fool 'autoload)
Page 3-26

13-1.4.4

August 3, 1978

o

The System

o

or (putprop /foo /Idsk:me;foo fasll /autoload) or the Oidia version also
works.

o

o

August 3, 1978

~3-1.4.4

Page 3-27

I'

I

!

o

Mac1isp Reference Manual

1.5

Debugging'

1.5.1

Binding, Pdl Pointers, and the Evaluator

The Mac1isp evaluator is based on a push down list (pdl), or stack, which holds
bindings, evaluation frames, and sundry internal data. Bindings are values of atomic
symbols which are saved when the symbols are used as lambda variables, progvariables,
or do variables. Evaluation frames are constructed when a non-atomic form is evaluated
or when app 1y is used. They correspond to function calls.
As the evaluator recursively evaluates a form, information is pushed onto the pdl
and later popped off. When the *rset and nouuo flags are t this information is
sufficiently detailed to be of use in debugging. (See the variables *rset and nouuo'in
the nex t section.)
A position within the pdl may be named by means of a "pd1 pointer", which is a
negative fixnum whose value has meaning to the evaluator. ni lis also accepted as a
pd 1 pointer; it means the top of the stack, Le. the most recent evaluation. Note that this
is different from nil as a binding context pointer, which means the bottom of the stack
or the outermost evaluation. 0 is also accepted as a pd 1 pointer; it designates the frame
at the bottom of the stack. Pdl pointers may be used as arguments to several debugging
functions described in the next section. Since the fixnum value of a pd1 pointer has only
internal meaning, generally a pdl pointer cannot be obtained from user input, except by
the user typing in a pd 1 pOinter chosen from a list of pd 1 pointers typed out at him.
The "frame" functions described in the next section may be used to obtain pd1 pointers.

o

An important thing to note about pd 1 pointers is their limited scope of validity. If
the 'information on the pdl which is named by a pdl pointer has been popped off since
the pdl pointer was created, the pdl pointer no longer has valid meaning.

1.5.2

*rset

Functions for Debugging

SUBR 1 arg

(*rset x) sets the *rset switch to nil if x is nil, or to t if x is non-nil,
and returns the value it set it to. (See below). This function exists primarily for
user typing convenience.
Page 3-28

!3-1.5

August 3, 1978

o

o

The System

SWITCH
If the *rset switch is non-n i 1, extra information is kept by the interpreter to
a How the debugging functions, such as baktrace and eva 1 frame, to work. In
addition, the interpreter will make extra checks such as checking the number of
arguments passed to a subr or Isubr and checking that array subscripts lie within
the declared bounds. Generally, the *rset switch being. on means "I am
debugging"; this is known as "*rset mode". The initial state of the switch is
ni1.

SUBR 1 arg

nouuo

(nouuo t) sets the nouuo switch.
(nouuo nil) turns off the nouuo switch. (This is the initial state.)
nouuo returns t or nil according to. whether it turned the nouuo switch on or
off. (See below.) This function exists primarily for user typing convenience.

SWITCH

nouuo

If the nouuo switch is on, functi~n calls' made by compiled functions· to
compiled functions or system functions are forced to go through the interpreter
each time. This aids in debugging. If the nouuo switch is off, which is the
normal case, compiled calls can be made to go directly, which is much faster.

The nouuo switch may be turned off at any time. Each compiled function can
will only go through the interpreter once more, at which time it will be linked
directly. If the compiled code has been reloaded into the system with the PURE
option (see page 3-71) then this direct. link may be unsnapped and the Interpreter
route re.,established by (sstatus uuolinks). Because the PURE option·requires
an a~ount of extra space and time, it is not normally on; thus links snapped in
code loaded as non-PURE cannot be unlinked.
The trace package turns this switch on when a function is traced, in order to
ensure that tracing will work even for compiled functions. Compiled function
calls which have been "snapped" to go directly do not push debugging information
in *rset mode and canlJot be traced. See also (status uuolinks).

"· ·
0·
.\

August 3, 1978

~3-1.5.2

Page 3-29

o

Maclisp Reference Manual

baktrace

lSUBR 0 to 2 args

baktrace displays the stack of pending function calls. It gives detai1~
information only in (*rset t) mode. The first argument is ~ pd1 pointer, as
with eva 1frame. If it is omitted, n 1·1 is assumed, which means start from the top
of the pd 1. The second argument is the maximum number of lines to be typed; if
it is omitted the entire stack is displayed. (The second argument is currently
permitted only in the Multics implementation.) The information printed by
baktrace is not the same as that obtained with eva1frame; both should be used
to get the maximum amount of debugging information.

bak1ist

. lSUBR 0 to 1 arg

bak11st returns a list containing the information which baktrace would
print. (This is available only on the PDP-IO implementations.)

err frame

SUBR 1 arg

errframe returns a list describing an error which has been stacked up
because of a user interrupt. The list has the form (err pdlptr message bcP),
where pdlptr is a number which describes the location in. the pdl of the error,
message is a list of from one to three things which, given to the error function,
could have caused this same error, and bcp (binding context pointer) is a number
which can be used as a second argument to eva 1 or a third argument to apply to
cause evaluation using the bindings in effect just before the error occurred.
The argument to err frame can be nil, which means to find the error at the'
top of the stack; i.e. the most recent error. It can also be a pd1 pointer, in which
case the stack is searched downward from the indicated position. Thus if there
are recursive calls to the error handler, the second error back down the stack may
be found by:
(errframe (cadr (errframe n11»)
The argument to errframe may also be a positive number, which is the
negative of a pdl pointer. This means start from the position in the stack marked
by' the pd 1 pointer and search upwar:ds.·
If no error is found, errframe returns ni 1.

Page 3-30

13-1.5.2

August S, 1978

o

The System

lSUBR 1 to 2 args

errprint

errpr 1nt treats its argument the same as errframe. The second argument,
in Newio implementation only, is the file(s) into which to print the information
(see print)., The message portion of the error frame is pr1nc'ed. errpr1nt
returns t if a message was typed out and nil if no error frame was found.

evalframe

SUBR 1 arg

The argument to evalframe is a pdl pointer, as with errframe. The pdl is
searched for an evaluation of a function call, using the same rules about starting
point and direction as err frame uses. eva 1frame always skips over any calls to
itself that it finds in the pd 1.

c

. The value is a list (type pdiptr form bep), where type is eva 1 or app ly,
pdlptr is a pdl pointer to the evaluation in the stack, suitable for use as an
argument to eva 1frame or errframe or baktrace, form is the form being
. eva luated or a list of the name of the function being applied and the arguments it
wa~ applied to, and bel' is a binding context pointer which can be used with eva 1
to evaluate' something in the binding context just before the evaluation found by
evalframe.
evalframe returns nil jf no evaluation can be found.
eva 1frame only works in (*rset t) mode, since no extra frame information
is saved otherwise.

freturn

SUBR 2 args

(freturn I' x) returns control to the evaluation deSignated by the pdl
pointer p. and forces it to return x. This "non-Iocal-goto" function can be used to
do fancy recovery from errors.

evalhook

VARIABLE

If the value of eva 1hook is non-null, then special things happen in the
evaluator. When a form (even an atom) is to be evaluated, evalhook is bound to
nil and the functional form which was its value is applied to one argument - the
form that was trying to be evaluated. The value it returns is then returned from

August 3, 1978

~3-1.5.2

Page 3-31

MacUsp Reference M an~al

0;

the evaluator. This feature is used by the Stepper package described later in this
~ection.

evalhook is bound to nil by break, and setq'ed to nil by errors that go
back to top level and print *. This provides the ability to escape from this mode if
something bad happens.
In orqer not to impair the efficiency of the LISP interpreter, several
restrictions are imposed on eva lhook., It only applies to evaluation - whether in a
read-eva I-print loop, internally in evaluating arguments in forms, or by explicit
use of the function eva 1. It does not have any effect on compiled function
references, on use of the function app ly, or on the "mapping" functions. Also. as
a special case, the array reference which is the first argument to store is never
seen by the eva 1hook function; however, the subexpressions of the array reference
(the indices) will be seen. (This special treatment avoids a problem with the way
store works.) Normally the evaluator does not check the value of evalhook, in
order to save time. To make it check, you must both be in (*rset t) - debugging
- mode, and have done (sstatus evalhook t). Not an implementations need
both of those, but you should always do both to be sure. If you use the Stepper
package, you need not worry; it does this automatical1y.

o

LSUBR Z or 3 args

eva1hook

(evalhook form hook) is a function which helps exploit the evalhook
feature. The form is evaluated with eva 1hook 1ambda-bound to the functional
form hook. The checking of evalhook is bypassed in the evaluation of form
itself, but not jn any subsidiary evaluations, for instance of arguments in the
form. This is like a "one-instruction proceed" in a machine-language debugger.
If all three arguments are present, the second is a binding context pointer and is
used as the second argument to eva 1, and the third argument is the hook.
Example:

Page 3-32

, 13-1.5.2

August 3, 1978

o

The System

0)

" (defun hook fexpr (x)
;called as (hook <form»
«lambda (*rset)
(prog2 (sstatus evalhook t)
;magic sstatus
(evalhook (car x) 'hook-function)
;evaluate form
(sstatus evalhook nil»)
;more magic
t) )

c

(defun hook-function (f)
«lambda (terpri)
(declare (special terpr1»
(princ 'Iform: I msgfiles)
(prinl f msgfiles)
«lambda (v)
(terpri msgfiles)
(princ 'Ivalue: I msgfiles)
(prinl v msgfiles)
v)

(evalhook f 'hook-function»)
t»
;this is how to eva 1 the
form so as to hook
; sub-forms
The following output might be seen from (hook (cons (car ' (a •
'c):

b»

form: (cons (car (quote (a • b») (quote c»
form: (car (quote (a •. b»)
form: (quote (a • b»
va 1ue: (a • b)
value: a
form: (quote c)
value:" c
va 1ue: (a • c)
(a • c)

o

The following functions only exist in the Multics implementation.
August 3, 1978

i3-1.S.2

Page S-S3

Mac1isp Reference Manual

o

. lSUBR 0 to Z args

baktracel
.'

baktracel is the same as baktrace except that binding context pointers
suitable for use with eval and app ly are displayed along with the function
names.

lSUBR 0 to Z args

baktraceZ

baktrace2 is the same as baktracel except that pdl pointers. suitable for'
use with baktrace and eva 1frame, are displayed along with the function names
and binding context pointers.
.

Page 3-34 .

.._--_ . . . . .__ . - .............

l3-1.S.2

-

..

-.--~.-.--

....--.--

~~~

.August S, 1978 .

o

o

The System

1.5.3

The Traoe Package

The LISP trace package provides the abi1ity to perform various actions at the time a
function is called and at the time it returns. This can be used for traditional tracing or
for more sophisticated debugging actions.
The trace package is not part of the initial environment; however, it is automatically
loaded in on the first reference to the function trace. (See autoload.)
The LISP trace package consists of three main functions, trace, untrace, and
remtrace, all of which are fexprs.

A call to trace has the following form:
(trace traceJpecs)
A trace. spec in turn is either an atom (the name of the function to be traced) or a Jist:

(function-name option 1 option2 ... )

c

o

where the options are as follows:
break pred

causes a break after printing the entry trace (if any) but before
applying the traced function to its arguments, if and only jf pred
evaluates to non-n i 1.

cond pred

causes trace information to be printed for function entry and/or exit
if and only if pred evaluates to non-n 11.

wherein fn

causes the function to be traced only when caned from the specified
function fn. The user. can give several trace specs to trace, all
specifying the same function but with different wherein options, so
that the function is traced in different ways when caned from
different functions'. Note that if fn is already being traced itself,
the where i n option probably will not work as desired. (Then again,
it might.) Note that fn may not be a compiled function.

. argpdl pdl

specifies an atom pdl whose value trace initially sets to nil. A list
of the current recursion level for the function, th~ function's name,
and a list of the arguments is cons'ed onto the pdl when the
function is entered, and cdr'ed back off when the function is exited.
The pdl can be inspected from a breakpoint, for example, and used
to determine the very recent history of the function. This option can

August 3, 1978

~3-1.S.3

Page 3-35

o

Maclisp Reference Manual

be .used with or without printed trace output. Each function can be
given its own pdt, or one pdt may serve several functions.
entry list

specifies a list of arbitrary S-expressions whose values are to be
printed along with the usual entry-trace. The list of resultant
values, when printed, is preceded by a \ \ to separate it from the
other information.'

exit list

similar. to entry, but specifies expressions whose values are printed
with the exit-trace. Again, the list of values printed is preceded. by

\ \.
arg
value
both
nil

specify that the function's arguments, resultant value, both, or
neither are to be traced. If not specified, the default is both. Any
"options" following one of these fou.r are assumed to be arbitrary Sexpressions whose values are to be printed on both entry and exit to
the function. However, if arg is specified, the values are printed
only' on entry, andjf value, only on exit. Note that since arg,
va 1ue, both, and nil swal10w an ronowing expressions for this
purpose, whichever one is used should be the last option specified.
Any .such' values printed will be preceded by a II and will follow
any values specified by entry or exit options.

o

If the variable arg 1 is t is used in any of the expressions given for the cond,
brea k , en try, or eX'i t ,options, or after the arg, va 1ue, both, or nil option,
when those expressions are evaluated the value of argllst will effectively be a list of
the arguments given to the traced function. Thus

(trace (foo break (null (riar argltst»»
would cause a ,break in foo if and only if the first argument to foo is n i 1.
Similarly, the variable fnva lue will effectively- be the resulting value of the traced
function. For obvious reasons, this should only be used with the exit option.
The trace specifications may be "factored." For example,
(trace «foo bar) wherein baz value»
is equivalent to
(trace (foo wherein baz value) (bar wherein baz value»

Page 3-36

l3-1.S~3

August 3, 1978

o

The System

0·"

,I

All output printed by tr'ace can be ground into an indented, readable format, by
simply settiflg the variable sprinter to t. Setting sprinter to nil changes the
output back to use the ordinary print function, which is faster and uses less storage but
is less readable for large list structures.
.
.

Examples of the use of trace:
(I) To trace function faa, printing both arguments on entry and result on exit:

(trace foo)
or (trace (fo'o»

or (trace (foo both».

(2) To trace function faa only when called from function bar, and then only if
(cdr x)isni1:
(trace (faa wherein bar cond (null (cdr x»»
or (trace (faa cond (null (cdr x»

wherein bar»

As this example shows, the order of the options makes no difference, except for arg,
va 1 ue, both, or nil, which must be last.
'(3) To trace function quux, printing the resultant value on exiting but no
arguments on entry, printing the value of (car x) on entry, of fool, fo02, and
(fo03 bar) on exit, and of zxcvbnm and (qwerty shrd1u) on both entry and
exit:

(trace (quux entry «car x» exit (fool fo02 (fo03 bar»
both zxcvbnm (qwerty shrd1u»)
(4) To trace function foo only when called by functions bar and baz, printing
args on entry and result on exit, printing the value of (quux barf barph) on exit
from foo when called by bazonly, and conditionally breaking when caned by bar if
a equals b:

(trace (foo wherein bar break (equal a b»
(faa wherein ba~ exit «quux barf barph»»
(5) To trace functions phoo and fu, never printing anything for either, but
saving all arguments for both on a common p~l cal1ed foopdl, and breaking inside
phoo if x is ni 1:

o

August 3,1978

l3-1.5.3

Page 3-37

!GiYiJAUlJ&mMWliMWMMM.h41

,;;

4 "

14f¥¥i#

o

Mac1isp Reference Manual

(trace (phoo argpdl foopd1 break (null x) cond nil nil)
(f~ argpd1 foopd1 cond nil nil»
The "cond nil" prevents anything at all from being printed. The second nil
in each trace spec specifies that no args or value are to be printed; although the cond
nil would prevent the printout anyway, specifying this too prevents trace from
even setting up the mechanisms to do this.
trace returns as its value a list of names of all functions traced; for any
functions traced with the wherein option, say (trace (foo wherein bar»,
instead of returning just foo it returns a 3-list (foo wherein bar). If trace
finds a trace spec it doesn't like, instead of the function's name it returns a list
whose car is ? and whose cdr is an error message. The error messages are:
(? where i n foo)

trace couldn't find an expr, fexpr, or macro property for the
function specified by the wherein option.

(? argpd 1 foo). The item fol1owing the argpd1 option was not a non-n 11 atomic

symbol.
(? foo not function)

Indicates that the function specified to be traced was nonatomic, or had no functional property. (Valid functional properties
are expr,fexpr, subr, fsubr, lsubr, and macro.)

(? foo)

o

foo is not a valid option.

Thus a use of trace such as
(trace (foo wherein (nl1»

(bar a~gpd1 n11»

would return, without setting up any traces,

«? wherein (nl1»

(1 argpd1 n11»

If you attempt to specify to trace a function already being traced, trace calls
un trace before setting up the new trace. If an error occurs, causing (? someth 1ng) to
_ be returned, the function for which the error occurred mayor may not have been
untraced. Beware!

I

!

\1

It is possible to call trace with - no arguments. (trace) evaluates to a list of all
. the functions currently being' traced.

i3-1.S.3

Page 3-38

-------_._-----

~~-

- - - - - - - ---- -

- - - --

- --------------- - - - - - - - - - - - - - - - -

August 3, 1978

I

01,

The System

untrace is used to undo the effects of trace and restore functions to their normal.
untraced s~ate. The argu"ment to un trace for a given function should be what trace
returned for it; i.e. if trace returned foo, use (untrace foo); if trace returned
(foo where i n bar) use (untrace (foo wherein bar». untrace will take
multiple specifications, e.g. (untrace foo" quux (bar wherein baz) fuphoo).
Ca lling untrace with no arguments wilt untrace a11 functions currently being traced."
remtrace, oddly enough, expunges the entire trace package. It takes no arguments.

o

August 3, 1978

~3-1.5.3

Page 3-39

Mac1isp Reference Manual

1.5.4

The Stepper

The LISP "stepping" package is intended to give the LISP programmer a facility
ana logous to the Instruction Step mode of running a machine language program.

The Rioh Stepper
The Rich stepper package provides a simple, small debugging capability. It is'
a va Hable ,as a library program in the ITS implementation.
How to Use the STEP Facility

The package conta ins two compiled functions which are loaded by
(fasload step fasl dsk liblsp)
The user interface is through the function (fexpr) step, which sets switches to put the
LISP interpreter in and out of "stepping" mode. The basic commands are:

(step t)
(step nil)

; Turn on stepping mode.
;Turn off stepping mode.

These commands are usually typed at top level, and wiU take effect immediately (i.e. the
next S-expression typed in will be evaluated in stepping mode). Also Ag, in addition to
returning to top level, turns off stepping mode:
In stepping, mode, the LISP evaluator will print out each S-expression to be
eva luated before evaluation, and the returned value after evaluation, calling itself
recursively to display the stepped evaulation of each argument, if the S-expression is a
function call. After displaying each S-expression,' the evaluator will wait before
evaluation for a command character from the' console:

<space~

Continue stepping recursively.

<rubout>

Show returned value from this level only, and' continue
stepping upward.

<cr> or <tab>

Turn of( stepping. mode. (but continue evaluation without
stepping).

Page 3-40

August 3, 1978

I

o

o

The System

p

Redisplay current form in full (i.e. without pr1nlevel
or pr i n 1ength)

B

Get breakpoint; proceed with IP

M

See ad vanced
Ex pansions.

features

under

Stepping

Macro

More Advanced Features

Selectively turning on step:
(step foo~ fo02 •.• )
If this command is typed at top level, stepping will not commence immediatelYt but rather
when the evaluator first encounters a S-expression whose car is one of fool, fo02, etc.
This form win then display at the console, and the evaluator will be in stepping mode
waiting for a command character.
.

Stepping Macro Expansions:
If the stepper is proceeded with a <space>, it will not step the execution of macro
expansions, but will rather just show the result of the macro of expansion and wait for
another command.

To ~ee the execution of the macro expansion itself t proceed the stepper with an M
instead of a <space>.
Using step with breakpoints:
The above description applies to turning stepping on and off globally at top level.
More detail is necessary to use step flexibly in and out of breakpoints (e.g. together
with trace).

If stepping is turned on by (step t) at top level, the evaluator win NOT be in
stepping mode within a breakpoint loop. If you wish to use stepped evaluation within a
break loop you must turn it on locally by (step t).Conversely, if stepping was not
turned on at top level and it is turned on by (step t) in a break loopt it win NOT be
on when return is made from the break loop by IP.
.

o

However, executing (step nil) inside a break loop will turn off stepping globally,
i.e. within the break loop, and after return has be made by 'P. .
August 3, 1978

l3-1.S.4

Page 3-41

o

Maclisp Referen.ce Manual

The most useful feature is the following, however:
(step)

Command at top level has no immediate effect.

After (step) has been executed at top level, a subsequent (step t) inside of a
break loop will have the effect of turning· on stepping mode both inside the break loop
and globally, Le. the evaluator will start to step as soon as the return is made from the
brea k loop ~y SP. Thus, for instance, one could set trace to break at some specia1 p1ace,
and then use the break to turn on stepping.
prinlevel and prinlength:
In the present version, for convenience, prin1evel and prinlength are lambdabound inside the hooking function to 3 and 5 respectively. These could be changed by
editing the expr code and recompiling.
When the P command is used, prinlevel and prinlength are temporarily bound
to nil. and the toplevel printer (the value of atom prinl) is used to redisplay the
current form.
Overhead of Stepping:
If stepping mode has been turned off by A g, the execution overhead of having the
stepping packing in your LISP is exactly ni 1.
.
If stepping mode has been turned off by (step nil, every call to eval incurs a
sma II overhead --several machine instructions, corresponding to the compiled code for a
simple cond and one function pushdown.

From' a n overhead point of view, running with (step) entered at top leve1 is the
same as running with (step nil).
Stopping stepping by responding <tab> incurs the sa.me continued overhead as
(s tep nil).
Running with (step fool fo02 •. '.) can be more expensive, since a member of
the car of the current form into .the list (foo 1 fo02 ••• ) is reqUired at each call to
eval.
In terms of memory reqUirements, the total compiled stepping package occupies about
423 words of binary program storage.
Interaction with debug and trace:
Page 3-42

l3-1.5.4

August 3, 1978

o

The System

No special interactions of the step package with debug, trace, or any other system
packages are known.

The Morgenstern Stepper
The Morgenstern Stepper package provides debugging capabilities for interpreted
LISP programs that are comparable to the capabilities provided by DDT for assembler
code. These capabilities include:

I) Single stepping through the .evaluation of a function and over or into other

interpreted functions, when called, on a selective basis as determined by the user.
Each such form and its resulting value may be displayed.
2) Dynamic breakpointing on one or more of' the following conditions: the form or atom

about to be evaluated matches a pattern you provide; the form being evaluated
involves a specified function; a given atomic symbol evaluates to a given value; a
given atomic symbol is to be bound in a prog, either type of do, or an eva l'd
1ambda-expression; or upon an arbitrary' condition specified by a predicate written
as LISP code.
3) Returning a different value for a given S-expression. This allows for c.hanging the

action that would be ·selected .by conditionals in the program and/or by go's in a
prog or do. You can also go to any tag inside the current prog.
4) These capabilities maybe requested when the program is initially started by a toplevel form, or they may be initiated at any other point in the course of execution either from the terminal while in a breakpOint, or directly by the program.

The stepper may be invoked initially by using the function mev as one would use
eva 1 of one argument; e.g. (mev" (fen argl arg2». From a breakpOint or in a
program, the stepper may be turned on by invoking (hkstart) with no arguments. It
rna y be turned off by the q command described below, or of course by a CTRL/g break.
After mev evaluates its argument, it returns the value and turns off the stepper. Note
that in the above example the,form given as an argument to mev was quoted. If, say, the
value of f was the S-expression (fen argl arg2), then one could use (mev f)
instead.
At any point during the stepping, one may inspect the values of other variables, and
even reapply mev to any form. This may be done in either of three ways. Each command

o

August 3, 1978

~3-1.5.4

Page 3-43

_~~

•

,,¢APtP

0

Maclisp Reference Manual

will be prompted for by II, usually foHowing the last form prj~ted out. Any Sex pression that is typed which is not recognized as a command will be eva l'd (within an
err set to catch errors). Alternatively, the e command to eval any expression, or the h
command to get a nice type of CTRL/h break. (This is really a CTRL/b break, but it
used to be CTR L/h so the command happens to be called h.)
in the its implementation each command must be followed by a space (unless the
command is a list). in the multics implementation each command must be followed by a
newline. actually, this depends not on the implementation but on (status linmode).
each form and result which is printed out will be followed by ·Inumber indicating the
relative level of evaluation (i.e. stack depth since invocation).
the primary commands are:
d (mnemonic for down) go down to the next deeper level of evaluation and display the
first form there before evaluating it. e.g. if the form is a function call, this will

display the first argument of the function if it has arguments in the call; otherwise
it will display the first s-expression of the body of the function. it then prompts for
the next command.
e

( eva 1.) can be used to eva luate an arbitrary expression. it starts a new line, waits
. for you to type the expression, then eva 1's it within an errset, and prints the
result. this is comparable to just typing the expression or atom after the II, but
cannot be confused with a command, and the format is nicer.

o

h (control-h) enters a break loop, and when Ip'ed displays the current form. within the

break, one can inspect the values of variables, etC., and even reapply mev to any
form ..
n

(next) Display the next form at this level, without showing· or inspecting the
evaluation of the lower levels of the current form. The value of the current form is
displayed first. If you wish a condition to be tested for at lower levels. use nn
instead.

nn Like n but slower since it inspects the lower levels. Use instead of n when testing for
a condition.
u (up) Go up to the next higher level of evaluation and show the next form at that
level. The form(s) at the current and lower levels are evaluated without display. As
an example of its use, after you have seen the evaluation of the arguments to a
function, the'next form to be evaluated, if the function is being interpreted, win be
the first S-expression of the function; to avoid seeing how the function is evaluated

Page 3-4'4

~3-1.5.4

August 3, 1978

o

The System

o

internally, you can type u. Note that the lower levels are not inspected - thus if a
conditi.on is to ~e tested for at these levels, use uu.
(u num) If num is positive (or zero), forms are not inspected nor displayed until level
num is returned to. If negative, it goes up (abs num) levels relative to the current
level. Thus (u -1) is equivalent to U.
uu Like u but slower. Use if testing for a condition.
(uu num) Like (u num) but slower. Use if testing for a condition.
Q

(quit) Exit from the stepper.

s (show or display mode) For datapoints and other display terminals, this gives a nice
easily read output of selected levels that constitute the context of the current'
eva luation. Specifica l1y, it selects the current level for spr i ntting (pretty printing)
as a "header", and as you go deeper, the local context is abbreviate-printed under this
header, and the current output will be sprint'ed. s may be used as often as you
like. Headers will automatically' be popped when you return. The command (s
num) selects a particular level as a header. It and the command sn and several
user settable parameters are described in the more detailed section below.
(= s-exp) The S-expression is substituted for the current form and another command is

prompted for (i.e. you can step into or over the new form if you want to). When the
resulting value is returned it wi1l be a~ if the original form had yielded that value.
For example, you can change the apparent truth or falsity of predicates or bypass a
(go label), as well as just returning different values for an S-expression.
(cond ... ) Tests for conditions prior to evaluation of each future form, and when
satisfied will print a message, display the form, .and wait for another command
(which may of course be h for a break). The argument to this cond is an arbitrary
S-expression or symbol which is evaluated like a predicate. This is similar to the
cond feature of the trace package.

In specifying the predicate, the form about to be evaluated may be obtained as the
va lue of the variable %%form. The expression (hook 1eve 1) returns the relative
level of evaluation. More than one predicate may be given, in which case they are
or'ed together, except when two arguments form a special test as described in the
more detailed section below. The condition will remain active at all levels that are
inspected by the stepper until explicitly turned off by (cond nil)~
(matchf ... ) is a function which will pattern match against the current form. It

o

August 3, 1978

~ 3-1.5.4

Page 3-45

o

Maclisp Reference Manual

may be used in the predicate of the condo (Also see its related use as a command.)
T~e argument to matchf is compared to %%form element by element from 1eft to
right. and succeeds when each element of. the ,pattern succeeds. Of importance, the
pattern need not include the entire form.
matches anything. The procedure is
applied recursively to sublists, unless the sublist is of the form (I ••• ) in which
case 1 is bound to the current element of %%form and the cdr (not cadr) of the 1list is evaluated as the test' on that element. Except in this case, atoms and lists
should be given as in the original code since they are not evaluated. Some simple
~x amp les are:

*

(matchf xyz) succeeds if the atom xyz is about to be evaluated.
(matchf (setQ alpha» succeeds if the atom alpha is about to be setq'd.

*

(ma tchf (put prop name
"source»
succeeds if the property source is
about to be putprop'd on the atom pointed to by (i.e. the value of) name.
(matchf (setQ (I member II "(alpha beta s3»»
alpha, beta, or s3 is about to be setq'd.
(matchf (rplacd

succeeds if either

* "(* 9») matches (rplacd (last url1st) "(2 9

4) ).

0'

(matchf « /I member I "( foo bar»» succeeds if a function call to either
foo or bar is about to be evaluated (more precisely if the car of the "form
about to be evaluated is either foo or bar).
nil (cond nil) turns the condition off and saves the current non-n i 1 condition.
(cond) When no argument is given, the last non-ni 1 condition (which is the old
property of %%cond) is established as the' current condition (which is the value of
%%cond). (If the previous condition was not nil then it is saved as the old
property, thus allowing for alternation of two conditions.)
(matchf ... ) is eqUivalent to (cond (matchf .•• », see above.
The following functions are useful in connection with the stepper.
(hkstart) will initiate stepping when encountered in a program or typed from a
breakpoint. (hkstop) will act like the Q command to turn off stepping. (Also see below
for more 'info.)

Page 3-46

~3-1.5.4

August 3, 1978

o

The System

(mbak) is a function to be used like the LISP system's (baklist). (mbak) strips
out from the result of (baklist) those functions that have to do with the stepper.
The rema inder of this section is· a complete 1ist of the Stepper commands, which can
be used for reference.
Commands which are not 1ists must be fo1lQwed by a space. You can use rubout
before completing the command (and its space if necessary). Alternatively, you may abort
th~ command before completing it by doing a CTRL/x break.
Any S-expression that you type which is not recognized as a command will be
evaluated (within an errset to catch errors). Thus you can evaluate any atom or do
any function call simply by typing it foHowing the prompting II as long as it is not
interpretable as one of the commands below (or ni 1). Note that you can actually go to a
tag within your prog simply by typing (go tag) after the II. To evaluate a form
which looks like a command, type (or form) to evaluate it, e.g. (or a) evaluates the
atom a. If you want you can even write functions which know about the stepper and
treat them as commands.
a

(al1) Automatical1y displays all form.s and values seen by the stepper at aU levels.
Typing a space at any time thereafter wi11 cause the stepper to leave this mode
and prompt for a new command. If you want the stepper to wait for a command
after each form, you can use. the d command.
Commands a ad (a -) c and cc pause after each new form is displayed if
%%ac-sleep is non-nil. Its value is us~d as ,the sleep time in seconds.

ad

(all down) Automatically displays all forms and values encountered by the stepper
in evaluating the current form (i.e. at deeper levels). Typing a space prior to
completion will cause the stepper to ~eave this mode and prompt for a new
command. (Also see d.) Sleeps after each ~orm, as described under the a
command.

(a lev) Automaticallydispla.ys all forms and values at the indicated level and lower
(deeper) levels, turning itself off when evaluation pops to a level with a smaller
level number. Typing a space prior to completion will cause the stepper to leave
this mode and prompt for a new command. (Also see d.) Sleeps after each form,
as described under the a command.
b

o

Sets a breakpoint to occur after evaluation of the current form. At the break, the
va lue to' be returned is the value of %%va 1ue, and may be changed by setq'ing
this yariable. The form that yielded this value is the value of %%form. Type IP

August 3, 1978

~3-1.5.4

Page 3-47

_MJ&&i_

o

Maclisp Reference Manual

to proceed from the breakpoint. If you prefer that· the system wait rather than
I?reak see the wt i f command. (b operates by adding the current hooklevel to
%%brea k 1 is t.) You can get automatic breaking at all levels by using (retcond
t) or conditiona I breaking as described below for the (retcond ••• ) command.
c

(current) Au'tomatically displays all forms and values at just the current level.
Typing a space at any time during the display will cause the stepper to leave this
mode and prompt for a new command. The stepper does not inspect the forms of
lower levels - thus if a condition is to be tested for at these levels, use cc. Sleeps
after each form, as described under the a command.

cc

Like c, but inspects the lower levels.

ctog Flips the %%condnotallow toggle Which is initially t, meaning do not allow c, m,
n, or u commands if a condition .is being tested for. nil means anow these
anyway.
(cond ... ) Tests for conditions prior to evaluation of each future form. For pattern
nlatching against the form using the matchf function and for other information
see the description of (eond ... ) above.
special tests for (cond •.. ):
To aid the specification of common tests, the following "flags" are provided - the
same effects could be obtained by inspecting %%form in your own predicate given
to condo If the first argument to the cond is from the set (form formq bind
bindQ atomval atomvalq fen fenQ and andq) then the second argument is
used to derive a test. This process is repeated with the remaining arguments, if
any. The resulting tests, together with any remaining arguments not satisfying
this process, are effectively or'ed together to derive the overall condition (except for
the and andq flag special tests which are and'ed). The arguments are not
evaluated when typed but are evaluated each time the condition is tested. These
flags each may be used more than once.

o

The meanings of these flags are:

andq

atomvalq

Page 3-48

The next argument is and'ed 'with the remaining tests, and
must yield a non-nil value for the remainder of the condition
to succeed. (See the comments for cond in the "complete list of
commands" below regarding the use of sideeff'ects)

I

"

The next argument should be a list of two elements, the first an

l3-1.S.4

- ----- --

---.---.-------~

August 3, 1978

...---.-------

---~

o

The System

o

(unquoted) name of an atom, and the second the value of this
atom for the test to succeed.
bindq

Watch for the following (unquoted) atomic symbol to be bound
In a prog, or .in e'ither type of do, or an explicitly evaluated
1ambda (as distinct from an applied 1ambda or function caU).

fenq Watch for the fo11owing (unquoted) function name'to be seen by eval as the
car of the form about to be evaluated. (This cannot check for
applied or mapped function calls).
formq The fonowing (unquoted) S-expression is to be watched for. E.g. used to
check' when a particular variable is about to be evaluated.
and
These evaluate their argument each time the condition is tested in
bind
order to get the desired S-expression or atom name, and then perform
fen
like their "q" counterparts. These are particularly useful if the flag's
form
argument is the value of a variable. (Be sure not to change the
atomval
variable's value accidenta11y while the condition remains in effect.)

As a si"!lple example, (cond fcnq rplaed) will check and stop when the function
rp 1aed is about to be used (i.e. when it is the the car of the
form to be evaluated).

o

The commands e, m, n, and u do not inspect all levels. and thus the condition
cannot be tested for at these levels. You can use ce, nn, mm, or uu instead, or use
the etog command. Naturally, condition testing slows the speed of execution at
levels that are inspected by the stepper but which you do not have displayed.
If you choose 'to, you can have your predicates produce side-effects such as
recording information of value' to you or setting states for use by the condition
later. You can use the and, andq flags (more than once if you like) to have the
ex pressions executed even upon success,' so long as these flags appear first in the
condition. Other conditions are evaluated in the order of appearance until the
first success is found.

o

d

(down) Displays the next level down. (as described above also).. Note that if the
form is an atom, the effect is the same as the n command. Hence if you want the
stepper to display every form and value, but to wait for a command after each
form, just keep using the d command.

e

(eva1) Can be used to evaluate an arbitrary S-expression. It starts a new line, waits
for you to type the expression, evaluates it within an errset, and prints the

August 3, 1978

~3-1.S.4

Page 3-49

Maclisp Reference Manual

o

result. Comparable to just typing the expression or atom after the II, but cannot
~e confused with a command, and the format is nicer.
(= S-exp lReplaces the current form with the given S-expression, and then prompts for

another command, as described above. If two arguments are given, then this
expression will not be treated as a stepper command, rather it will be evaluated
(see comments at top of this section).
h

CTRL/h break is executed. The current form is redisplayed .
when SP is typed. The form about to be evaluated is the value of %%form. Wi~hin
the break, one can inspect the values of .variables, etc., and even reapply mev to any
form.

k

(kill) Does not evaluate the current form nor display any
value. This is good for avoiding side effects if restepping through a program
again. Equivalent to (= nil) followed by m command.

1r

{last result) A complete rather than abbreviated printout of the
last result is given. (See (p - -) for further information.)

m

o

Next, like n but the result of the current form is not displayed.
I f a cond ition is to be tested for at lower levels, use mm.

(matchf ••• ) is equivalent to (cond (inatchf •••
(cond .... ) above.

mm

», see the the description of

Next, like nn but the result of the current form is, not
displayed..

n

.
(next)· Displays the value of the current form and displays the
next form, then awaits the next command. Does not inspect the lower levels. If a
condition is to be tested for at lower levels, use nn instead.

nn

Page 3-50

Like n but inspects the lower levels..

l3-1.S.4

August 3, 1978

o

1

:1

II

The System

o

(old) Does (mev J'last form). This is useful for seeing how a
form. produced an unexpected value when you went over it with n or nn.· If
reevaluating the form can produce side effects be careful. Can be exited from by
the xx cO":lmand. (The old form is the value of %~oldform.)

01

(old, at current level) Does (mev "last form at tltts level).
Behaves like o. Useful to see the form (at this level) which produced the current
va lue - rather than the last form printed out, as 0 would yield. (The old form
used here can be obtained by (get %%hooklevel "oldform).)

po(in)(print) Redisplays the current form. This is useful if you wish to clear the screen
first with control-L. Gives typical abbreviated display (see (p - except has
somewhat different effect if in display mode (see s command). (For hackers of
special data structures, e.g. "ow)", printing will be done with the function which is
the value of the atom pr i n 1 if non-n i 1 - as also applies to top-level in LISP.
This value of pr i n 1 is checked only in the mev function. Moreover, unless you
request LISP not to "snap links" in compiled code, you may have to reload the
stepper after changing pr i n 1.

»,

o

pp (full print) Gives a complete printout of the current form.
ppp (even better printout) Pretty-prints the current form using the spr 1nt function.
Uses a lot of screen in general, and so will turn on pagepause for you.

(p - -) Resets the parameters for the abbreviated printout used for results, forms and
the p command. The first parameter is the prinlevel, the second is the prinlength;
both must be given. If nil is given instead of a number no abbreviating is done
with respect to that parameter; thus (p nil nil) turns off abbreviation. (The
current settings are the value of %%hookpr in.)
Q

(qu,it) Exits from the stepper. Previously requested breaks and conditions are
disabled, and any non-ni 1- conditions are saved on the old property of the
condition name. (Control-G also exits as usual.)

s (show or display mode) For datapoints and oth~r display terminals, this gives a nice
easily read output of selected levels that constitute the context of the current
evaluation: Specifically, it selects the current level for sprinting as a "header",
a nd as you go deeper, the local context is abbreviate-printed under this header,
and the current output will be sprinted. s may be used as often as you like.
Headers will automatica 11y be popped when you return. All sprinting is done

o

August 3, 1978

l3-1.5.4

Page 3-51

iM.=_O-

Maclisp Reference Manual

o

with pagepause on. If control-X is typed during sprinting, that expression win be
redisplayed using abbreviated-printing instead. When in this display mode, thep
command will clear the screen from the last form down, unless preceeded by
control-L (or if wrap-around occurred), in which case the screen" is fully
redisplayed. Also see (s arg) for more information and options.
( s arg) If arg is positive, this selects the form at that level as the "header" for sChow)
mode. If negative, it uses the form at arg levels above the current one. If arg is
nil. display mode is turned off (headers are remembered though). (s t) just
turns display mode on if currently off using the previously remembered headers if
still applicable; but if it is alrea~y on, this pops the stack of headers by one
(normally headers are automatically popped when the level is returned from). All
sprinting is done with pagepause on. If control-X is typed during sprinting, that
expression will be redisplayed using abbreviated-printing instead. Also see the sn
command.
Several parameters are user settable from their defaults. %%lowerdisplay and
%%lowerdisplay-min control the maximum and minimum number of levels to
display below the header (defaults of 5 and 2). This is done in abbreviate-printed
form using %%shortpr i n which is a list of the prinlevel and prinlength (defaults
3 and 3). Sprinting of forms and results will be abbreviate-sprinted by the
msprint function if the flatsize of the expression exceeds X%flatsize-max
(default about 150). The prinlevel and prinlength for the latter are the list
which is the value of %%sprintabbr (default is (7 8». If %%flatsize is nil,
full sprinting will always be used; (if negative, abbreviate-sprinting win always
be used so that infinite printing circular structures will sprint and abbreviateprint finitely. To turn off sprinting of results setQ %%resu 1 t-spr i nt to nil
(default t). If %%mdistit1e is neither nil nor a" number, it will be evaluated
just a fter the screen is cleared, allowing printing of a title. If it is a number,
that number of blank lines will be left at the top of the screen (also see sviewmsg
function beloW). If the partial clearing of the screen bothers your eyes, setQ'ing
%%eyes tra i n 1 to a number of seconds (e.g. 0.5 to 2.0) will slow down the new
display depending on the number of lines cleared.

o

sn Just for s(how) display mode. It prevents clearing of the screen after prompting for
"another command, but only until the next prompting II after that. Useful if you
want a result to remain displayed a little longer. If you want to prevent clearing
of the screen for more than a couple of times, use (s nil), then do (s t) when
you want to resume display mode.
(retcond ... ) Tests for conditions just after each form is evaluated, and breaks
when such condition is satisfied. At the break, the value to be returned is the

Page 3-52

~3-1.S.4

August 3, 1978

0'

The System

value of %%value, and may be changed by setQ'ing this ·variable. The form that
yield:ed this value is the value of %%form. Type SP to proceed from the breakpoint.
The conditions are specified as for (cond ..• ). Note that (retcond t) win
give you a break as each level is popped (returned from), including levels above
the one where the request was made. (retcond"1 1) disables the retcond. If you
prefer waiting rather than breaking see the wt i f command.
Two additional flags are available:
va 1ueq The test (eQ.ua 1 %%va 1ue next-argument) is performed as if it were
and'ed with the remaining predicates in the condition.
value Like valueq but the test is (equal %%value (eval next-argument)}.
The overa II condition is maintained on the value of the atom %%retcond, and the
previous non-ni 1 condition is on the 9ld property of this atom. If you want both
cond and retcond conditions to be the same you can (setQ %%retcond %%cond).
The va 1ue and va 1ueQ predicates will be ignored in a (cond ••• ).

Ie':
.../

u . (up) Go up to next higher level. Current and lower levels are executed without
display. The lower levels are not inspected - thus if a condition is to be tested for
at these levels, use uu. This can be used to skip the display of a function's
internal evaluation after having seen the arguments, as described in the previous
section.
(u nu.m) If num is positive (or zero), forms are not inspected nor displayed until that
level number is reached. If negative, it goes up this number (absolute value) of
levels relative to the current level. .Thus (u -1) is equivalent to u .
uu Like u, but also inspects lower levels. Use if you have a condition to be tested.
(uu num) Like. (u num) but slower. Use if testing for a condition. Note that (uu
-999) effectively means that you won't see any levels unless the condition in a
cond or retcond is satisfied.
wta 1 (wait-all) Flips a toggle which when on causes a pause after the evaluation of
every form, but before that value is returned. The system waits for an input
character. Typing y(es), b(reak), or h (for control-h) followed by space win cause a
break as would the b command. Typing just a space, or any other character
f oHowed by a space, will proceed from the pause. Default is off.
.wt if (wait-if) Flips a toggle which when on causes requests by the band (retcond
... ) commands to result in a pause rather than a break. The pause is .1ik~ that

. August 3, 1978

~ 3-1.5.4

Page 3-53

o

Mac1isp Reference Manual
of the. wta 1 com'mand, and may be proceeded by a space; or a break initiated by
typing y, b, or h folJowed by a space. Default is off.
xx Does a control-X type of LISP quit. (A control-X typed after the II prompt will be
caught by an errset. The xx command is executed outside of that errset.)

The following other facilities exist:
(gethk 1eve 1 num) This function returns the S-expression that is on the execution
stack of the stepper at the given level number (see hkshow). Can be used to get
an unsprinted unabbreviated display of the form or to record or process the form
as you desire, including reapplication of mev to it in the current context.
(hkshow num) This function will display previous forms which are on the execution
stack, as seen by the stepper while it has been activated. The previous num of
lev·els are shown, with the current form last. If no argument is given, then all
levels are shown. The display is done under the control ·of prinlevel and
prinlength which are settable by the (p - -) command. Of course this function
can also be used as if it were a command by typing it after the prompting II.
(hkspr i nt num) This function will sprint the form on the level whose number is
given as the argument. Can' also be used as a command.

0'

(hkstart) Use this function to invoke or re'invoke the stepper from a breakpOint or
from a program as described above. If used Within a break, type (hkstart) by'
itself rather than within another S-expression or function, as it has to climb the
stack from. the point of invocation. If an argument is given to this fexpr, it will
be evaluated just prior to establishing stepping, with "'w bound to nil, so that you
can print out information if ca11ed from a program.
.
(It is possible for the invocation of the stepper by this method to have limited scope under

some circumstances. Such a boundary would be a second breakpOint higher on the
stack or a previously terminated invocation of the stepper that is still on the stack. .
Also if the program was initially started without mev, and stepping isretain~d
thoughout the rest of the execution, stepping may also remain for forms typed at
top level - to stop this just do control-G (or use the q command) .)

I

I

1,1

I

II

(h ks top) This function turns off the stepper whenever executed - in the same manner
as the q command would.

"I

'I,

hook 1 is t is an atom whose value is inspected before each attempt to read a command
from the console. If hooklist is non-n i 1, it is assumed to be a list of commands to

Page 3-54

l3-1.S.4

August 3, 1978

o

The System

the stepper - each is printed out when used and treated as if it came from your
typei.n. hook 1 i st is a Iso examined at each level that is inspected by the stepper
even if no command reading is done (e.g. nn or uu modes).
(mbak) This function gives (bak 1 is t) but without the stepper functions, as described
above.
(mev top-form) This function initiates stepping and otherwise acts like eva 1 of one
argument, as described above.
(mspr i nt form) Gives abbreviated sprinting of the form. A second and third numeric
argument specify the effective prinievel and prinlength here, else a list of two
numbers found as the value of msprint are used. The current implementation is
somewhat slow as the regular sprint does not respond to standard abbreviating.

o

(sviewmsg lineno toeval) Useful in conjunction with .s(how) mode. Puts the cursor at
the lineno and evaluates the second argument, then returns the cursor to its
original position. lineno = 0 means top; if negative counts from bottom, with -I
the bottom line .. Typically have %%md i st i t 1e (see (s -) ,command) be a number
to skip lines· on top, and use svi ewmsg to display your debugging information up
there.
If you really want specialized processing in particular situations, you can inspect
and/or change %%form in a (cond ... ) predicate, and %%va 1u~ in a (retcond ••• ).
If %%nohookfl ag is t, form and value printout and command reading (except from a
non-n i 1 hook list) is inhibited until it is reset to n 11. Normal command processing is
. invoked by (%%mhookcom) with %%nohookflag bound to n11. Also described above are
%%breakl 1st. %%cond, %%retcond, and %%hookprin.

1.5.5

The MAR Break Feature

This feature is currently available only in the ITS implementation.
The MAR break feature takes advantage of a hardware feature (the Memory Address
Register break) which interrupts whenever a given memory location is accessed in a
specified way. It allows the LISP user to specify an interrupt function to run whenever
a variabJe or list cell is modified. The user must first "arm" the interrupt by saying
(sstatus mar eond ioe). eond is the condition on which to interrupt: .

o
August 3, 1978

Turn off the mar feature.
Interrupt on instruction fetch.

l3-1.5.4

Page 3-55

M ac1isp. Reference Manual

2
3

Interrupt,on write (modification).
Interrupt on all references.
(numbers are octal)

On a KL-IQ processor, additional conditions are available:
10
II
12
13

Interrupt on data read.
Interrupt on data read or instruction fetch.
Interrupt on data read or write.
Interrupt on instruction fetch or write.

ioc is any s-expression; that cell is the one monitored.

Example:
(setq foo (Jist 'a 'b»
(sstatus mar 2 foo)
will interrupt if the list cell in foo is ever rplaca'd or rplacd'd.

o

An example of the use of the mar-break interrupt:

Page 3-56

l3-1.5.5

August 3, 1978

o

The System

o

(de.fun mar-tracer (x)
« lambda (val)
(sstatus mar 2
(get the-mar-variab1e /value»
(nointerrupt ni 1)
;Iet endpagfn interrupts in
(terpri msgfiles)
(prine 'INow the variable 1 msgfiles)
(print the-mar-variable msgfiles)
(prine' 'I has the valuel msgfiles)
(print val msgfiles»
(symeval the-mar-variable»)
(setq mar-break mar-tracer)
(defun mar fexpr (x)
(cond «null xXsstatus mar 0 nil» .
(t (setq the-mar-variable (car x»
;make sure the 'variable has a value cen
(or (boundp the-mar-variable)
(set the-mar-variab1e nil»
(sstatus mar 2 (get the-mar-variable /value»»)
(mar QUux)
(setQ QUUX 5)
; Now the variable quux has the value 5
5

(do «.quux 0 (+ QUUX 1») .( (= quux 2»
(hack QUux»
;Now the variable quux has the value 0
;Now the variable quux has the value 1
;Now the variable quux has the value 2
; Now the variable quux has the value 5
nil
Notice that Quuxis' altered by the do loop, and also by the restoration of the old value 5.
This example is for a KA-IO processor. On a KA-IO, the user interrupt is always run
after the location has been changed. On a KL-IO processor, the interrupt occurs just
before a modification or access rather than just after.
The mar break feature is sometimes used by DDT to debug the LISP system. As
long as DDT and LISP do not both try to use the mar break feature on the same LISP
at the same time, there should be no problem. (sstatus mar 0 n11) releases the mar
break feature entirely for use by DDT.

o

August 3, 1978

~3-1.5.5

Page 3-57

2(,

--~

o

Maclisp Reference Manual

The suspend function will attempt t~ save and restore the state of the mar break
featu~e. If you don't want an armed mar break to persist beyond a call to suspend, turn

it off first with (sstatus mar 0 nil).
When a CTRL/g quit (or the "g function) forces a quit back to top level, it disables
the mar break before unwinding variable bindings and re-enables it afterwards. This is
because during a CTRL/g quit LISP may not be in a good state for running user
interrupt functions.

o

Page 3-58

13-1.5.5

August 3, .1978

o

The System

1.6

Storage Management

In Mac1isp storage for programs and data is automatically managed by the system.
The casual user need not concern himself with storage management and need not read
this section. However, the user who is curious about the implementation or who has to
construct a subsystem on top of Maclisp may need to be concerned with how the internal
storage management routines work and how to control their general functioning. In no
case is it necessary to control the exact step by step operations of storage management,
but a variety of functions are provided to set the general policy foHowed by the LISP.
storage management procedures.

1.S.1

o

Garbage Collection

Garbage collection is the mechanism which LISP uses to control storage allocation.
Whenever LISP feels that too much storage is being used, a garbage collection is
initiated. The garbage coHector traces through all the S-expressions which can be
reached by car'ing and cdr'ing from internal atomic symbols' values and property lists,
from forms and temporary results currently being used by the evaluator, from data . used
by compiled code, and from the saved v~lues of bound variables. All the data which it
finds in this way is "good" data, in that it is possible for it to be used again.
Everything else is garbage, which can never again be used for anything' because it
cannot be accessed, so the storage used by it is reclaimed and reused for creating new Sex pressions.

gc

FSUBR

( gc) causes a garbage collection and returns ni 1.

gctwa

FSUBR

gctwa is used to control the garbage collection of "truly worthless atoms,"
which are atomic symbols which have no value and no properties, and which are
not referenced by any list structure, other than the obarray (the current obarray if
there IS more than one).
. ( gctwa) causes truly worthless atoms to be removed on the next garbage
collection.

C'·'','\

August 3, 1978

~3-1.6

Page 3-59

''I
I

Maclisp Reference Manual,

(gctwa t) causes truly worthless atoms to be, removed on each garbage
.collection from now on. Note: gctwa does not evaluate its argument.
(gctwa nil) causes this continual removal of truly worthless atoms to be shut
off, but it does not affect whether the next garbage collection removes twa's.
The value returned by gctwa is a fixnum which is 0 jf no garbage collection
of truly worthless atoms will be done, I if twa's are to be gc'ed on the next garbage
collection, 10 if twa's are to be gc'ed on an garbage collections, or II jf both. (These
numbers are octal; the decimal values are 0, I, 8, 9.)

SWITCH
If the value of Ad is non-rii 1, the garbage collector prints an informative
message each time garbage collection occurs. (In a Newio implementation, this
message is output to the' files in msgfi 1es, see page 3-15) In the PDP-IO
implementation, it also prints a message when a space is expanded without first
doing a complete garbage collection, or when a file or inferior job is closed because
a file object was garbage collected. See also (status gcwho).

See also the user interrupts gc-daemon, gc-overf1ow, and gc-lossage.

1.6.2

Spaces

In Mac1isp the storage used for LISP objects is divided into several conceptual
subdivisions, called spaces. Each space contains a different type of object. Allocation
proceeds separately in the different spaces, but garbage collection of all spaces occurs
together since an object in one space could contain a pointer to an object in any ot"er
space.
For example, in the PDP-IO implementation, the spaces are as fonows:

--

----

lIS T

Conses (dotted pairs) and lists.

FIXNUH

Fixnums.

FlONUM

Flonums.

BIGNUH

Bignum headers. Bignums also occupy fixnum and list space.

Page 3-60

i3-1.6.1

------,,--,,-----~----,,-------

- --------" ... _------

'August 3, 1978

o

The System

o
SYMBOL

Atomic symbols:

HUNK4

Hunks of various sizes. PDP-lO implementations without hunks do not
have' these spaces.

HUNKS'
HUNK16

ARRAY

"Special array cells."

REGPOL

The "regular" pushdown list.

SPECPOL The "special" pushdown list, used in binding.
FXPOL

The fixnum pushdown list, used for temporary numeric values.

FLPOL

The Ronum pushdown list, used f~r temporary numeric values.

Binary Program Space lIsed to hold arrays and compiled code.
pure LIST, pure FIXNUM, pure FLONUM, pure BIGNUM, pure HUNG4, ...
These spaces are used to store "pure" (read-only) data of the indicated
types. This is a feature used to make subsystems .more efficient. See page

3-67.
In the Multics implementation, the spaces ~re:
list

Conses (dotted pairs), lists, atomic symbols, bignums, and strings.

Static Storage

Arrays, files, and linkage to compiled code.

markedpdl

A pushdown list of LISP objects.

unmarkedpdl

A pushdown list of machine data, not LISP objects.

Note: it:' the Multics implementation there is no space for numbers because numbers
are stored in such a way that they do not take up any extra room.
The precise spaces available in a given implementation can be determined by using

o

(status spcnames), (status purspcnames),and (status pdlnames).
August 3, 1978

~ 3-1.6.2

Page 3-61

.WMilbiJ1&....1i&1lM1;UUU, I, ,AP

MA¢-*P¥p· -

___

4#44

¢A.4

M:@,.t

o

Maclisp Reference Manual

Associated with each space is information determining when an attempt to allocate in
that spac~ should cause a garbage collection. The idea is that one should allocate for
quite a while in' a space, and then decide that it is worth the trouble of doing an
expensive garbage collection in order'to prevent the space from using too many bits of
actua I storage.
The exact nature of this information varies with the space. In a pushdown Jist (pd1)
. space, a 11 information must be stored contiguously, so the only parameter of interest is
how big the pdl is. This can be measured in three ways, so there a~e three parameters
associated with a pdl:
pd 1 s fze The number of words of valid data in the pdl at the moment.
pdlmax

The size to which the pdf may grow before intervention is required. This is
used to detect infinite recursion.

pd 1room The size beyond which the pdl may not grow no matter what.

A space such as a list space has three parameters, called the gcsize, gcmax, and
gcmin. These are in machine-dependent units of "words". The gcsize is the expected
size of the space; as objects are allocated in the space, it win grow without garbage
collection until it reaches this size. When it gets above this size garbage collection will
occasionally be required, under control of the other two parameters.
The gcmax is the maximum size to which the space should grow; if it gets this big
garbage collections may occur quite frequently in an attempt to prevent it from growing
bigger.
The gcmin specifies the minimum amount of free space after a garbage collection. It
y be either a fixnum. which specifies the number of words to be free, or a flonum, which
specifies the fraction of the space to be free. The exact interpretation of this depends on
the implementation. In the PDP-IO implementation, which uses free storage lists, the
gcmin is the number of words which must be on the free storage list after a garbage
collection. If there are not this many, the space is grown, except if its size approaches
gcmax it may not be grown by the full amount. In the Multics implementation, which
uses a compacting garbage collector, the criterion for garbage col1ection is not when a
free list is exhausted but when the space reaches a certain size. This size is the
max imum of gcsize and the sum of the size after compactification plus gcmin (if it is a
fixnum) or the size after compactification times I/(l-gcmin) (if gcmin 'is a flonum.) The
effect of this is to allow the same amount of allocation between garbage collections as
there would be in the PDP-IO implementation with the same gcmin.

rna

Page 3-62

13-1.6.2

August 3, 1978

i'
I

I

o

I

\'

The System

Note that these controls over the sizes of spaces are somewhat inexact, since there is
rounding .. For instance, the PDP-IO. implementation presently al10cates memory to
spaces in blocks of 512. words. The Multics implementation al10cates at least 16384.
words between garbage collections and presently controls the size of pushdown lists in
blocks of 16. words.
.
Some spaces, such as Binary Program Space in the PDP-JO implementation or Static
storage in the Multics implementation are not subject to detailed control by the user.
The management of these spaces is entirely automatic. Generally these are spaces where
the rate of allocati~n is fairly placid and most objects, once allocated, are used forever.
and never freed. Hence the exact policy used for storage management in these spaces is
not too important.

1.S.3

Storage Control Functions
SUBR 1 a~g

a110c

c

The all oc function is used to examine and set parameters of various spaces
ha ving to do with storage management. To set parameters, the argument to
a110c should be a list containing an even number of elements. The first element
of a pa ir is the name of a space, and the second is either a fixnum or a 3-Jist. A
fixnum specifies the pdlmax (for a pdl space) or the gcsize and gcmax (for other
spa.ces.) A 3-list specifies, from left to right, the gcsize, gcmax, and gcmin. nil
means "don't change this parameter." Otherwise a fixnum must be supplied, except
in the third element (the gcmin), where a flonum is acceptable. A 3-list cannot be·
used with apd I space.
An example of this use of all OC, in the PDP-10 implementation:

(alloc /(list (30000. 5000. 0.25)
fixnum (4000. 7000. nil)
symbol 6000.
regpdl 2000.»
or, in the Multics implementation:

(alloc /(list (30000. nil 0.3)
markedpdl 5000 .
.unmarkedpdl 5000.»

August 3, 1978

l3-1.6.2

Page 3-63

o

Mac1isp Reference Manual

a110e may also be called with an argument of t, which causes it to return a
.list of all the spaces and their parameters. This list is in a. form such that it
cou Id be gi ven back to all oe at some later time to set the parameters back to what
they are now.

See page3-S7 for some status functions which are related to the topic of storage
spaces.

1.8.4

Dynamio Spaoe and Pdl·· E~pansion

There are several user interrupts generated by the storage management. See section
page 3-16 for a description of user interrupts. The ge-daemon interrupt occurs after
each garbage collection. The argument passed to the .gc-daemon interrupt handler is a
list of spaces and their sizes. In the POP-tO implementation, the items on the list are of
the form: (space-name free-before free-after size-before siu-after), where space is the
name of a space, and free-before indicates the number of cells free before the garbage
co11ection and free-after indicates the number of cells free afterwards. The last two
numbers a re the size of the space (see (status spes i ze» before and after the ce.
(The sizes are in PDP-IO words.) In the Multics' implementation, the items are of the
form: (space before . after). In the Multics implementation, where "free cells" is a
meaningless concept, only the difference of these two numbers is significant; it represents
the amount of compaction achieved.
.

o

The ge·1ossage interrupt occurs if the garbage collector tries to expand a space but
fai1s because, for example, the operating system will not give it any more storage. The
argument passed to the interrupt service function is the name of the space that lost. If
the' interrupt handler returns, the value is ignored, and another garbage collection is
attempted.
The pd1-overf1ow interrupt is signalled when some pushdown list exceeds its
pdlmax. The pdlmax is increased slightly so that the interrupt handler will have room
to run. The argument passed to the interrupt function is the name of the pdl that
overflowed. If the interrupt function uses too much pd1, this interrupt win occur again.
If this happens enough times, the pdlma'x will reach the pd1room, there win be no room
in the pd 1 to take a user interrupt, and an uncorrectable error win occur.
The interrupt function can decide to terminate the computation that overflowed the
pd 1, for example by doing (~g) or a throw, or it can increase the pdlmax by using
a110e or (sstatus pdlmax) and then continue the computation by returning. Note

Page 3-64

l3-1.6.3

August 3, 1978

I,

!.

o

I!

The System

o

that, un like most other user interrupts, if the pd l-overfl ow interrupt function returns
nil (or th~ "; bkpt pd l-overfl ow" is IP'ed), the computation is continued as if the
pd 1 overflow had not occurred.
.
The gc-overflow interrupt occurs when some space (other than a pdl) exceeds its
gcmax. This gives the user a chance to decide that the size of the space should be
increased and the computation continued, or that something is wrong and the
computation should be terminated. The argument passed to the interrupt handler is the
name of the space that overflowed. The interrupt handling function wi11 be able to run
because the garbage collector makes sure that the space is sufficiently large before
signa lhng the interrupt, even if this makes it become somewhat larger than its gcmax.
This interrupt is similar to pdl-overflow in that if the interrupt handler function
. returns at all, even if it returns nil, the interrupted computation proceeds. To terminate
the computation an explicit ("'g) or throw must be done.

1.,8.5 ·Initial Allocation

c

The PDP-IO implementations of Mac1isp run on a machine with a limited-size
address space. Consequently the allocation of portions of this address space to different
uses, such as LISP storage spaces, becomes important. This is particularly true of the
DEC-to implementations, which cannot take advantage of paging.
When LISP is first entered, it goes through a dialogue with the user known as
"a l1ocation," Normal1y the dialogue simply consists of the user declining to specify
anything, in which case LISP chooses SUitable defaults. If a large problem is to be
worked on, the defaults may be inappropriate and it may be necessary to explicitly
allocate a larger amount of storage. It is also possible for the user's replies to come from·
a file.
If LISP is called with a command line from DDT, for example

:LISP INDEX LOADER COM:
it reads the indicated file in the same way that it would read .LISP. (INIT). See below.

On the other hand, if LISP is called without a command line, it identifies itself and
asks

ALLOC?
Suitable responses are Y, Nt and CTRL/q. There are other obscure characters which can

o

August 3, 1978

l3-1.6.4

Page 3-65

_ _ _ WA&&I;.'

o

Mac1isp Reference Manual

be used as replies to this question, but these three are sufficient for most purposes. ("?"
causes. a list of sUitable responses to be printed out.) "N" means that you do not want to
specify al1ocation. You will get the default. CTRL/q means to read your initialization
file (see below.) "Y" means that you wish to go through the following sequence of
questions and answers,
LISP types out the names of various spaces and their sizes. If the name of the space
is preceded by "~"', then it cannot be expanded once allocated by this dialogue. After
each question you rna y enter altmode, which terminates the dialogue and gives the
rema'ining parameters default values, or space, which goes on to the next question.
Before your altmode or space you may put a number which i~ the size you want that
space to be, instead of the number that was printed. CTRL/g restarts the dialogue with
the" ALLOC?" q~estion.
I f you reply with a CTR L/q, it means to read your initialization file. In the ITS
implementation, this is either ,u.dir; . LISP. (INIT) or (INIT); udir • LISP. J where
udir is your master sname. In the TOPS-IO implementation, this is IISP. INI in the
directory you are logged in to.
In the Multics implementation, this is
hd>start_up. LISP, where hd is your home directory. Since the Multics implementation
doesn't have the allocation dialogue, this file is always read when the LISP command is
given with no arguments.
The first form in the file should be a comment which is used to answer the questions.
Note that supplying nonexistent space names in the comment'doesn't hurt, so you can
use the same comment for different implementations. An example of the form of this
comment is:

o

(comment fixnum 5000 symbol 4000 flonum 2000
bignum 1400 regpdl 5000 hunk8' 30000)

The remaining forms in the file are simply read and evaluated using the 'standard
read-evaJ-print loop.

Page 3-66

l3-1.6.5

August 3, 1978

o

o

The System

1.7

1.7.1

Implementing .Subsystems with Maolisp

Entering LISP

A subsystem is an entity that exists in most time-sharing systems. It is normally a
complete world which the user enters by typing a command. He then has whatever
facilities the sUbsystem offers. A subsystem can be oriented toward programming, as the,
M aclisp subsystem itself is, or it can be oriented toward a particular application, for
instance compiling LISP programs, op~rating machinery, or solving differential
equations.
M aclisp' is frequently used as a base on which to build subsystems. Consequently it
has been eqUipped with a number of mechanisms which aflow the subsystem writer to
ga in complete control over the operation of Mac1isp, make it possible to hide the vagaries
of M aclisp from the naive user of a different subsystem, and provide increased efficiency
in memory a nd processor u~age for heavily-used sUbsystems.

o

in the ITS implementation
LISP may be entered by the : LISP (or LISP"'K) command. The environment set up
by this command is the standard initial environment. LISP now goes through an
allocation dialogue and optionally reads your .LISP. (INIT) file. See page 3-65 for
information on this.
LISP may be entered by the command :LISP namel name2 dey dir (or :lISP
dev:dlr ;namel name2). In this case the file dev:dir;namel name2 is read in the
same wa y as a . LISP. (IN IT) file. This can be used to start up a subsystem. The
deVice defaults to 'DSK, the directory defaults to your current DOT master sname
( •• MSNAME). and the file names default to • LISP. (INIT).
It is also possible to build a subsystem in a LISP, then save it as TS FOO. The :FOO
(or FOO"'K) command will then enter the subsystem, bypassing the allocation dialogue.

in the DEC-10 implementation
LISP may be entered by the monitor command R LISP or RUN IISP. The allocation
dia,logue (see page 3-65) is entered. Optionally a LISP. INI in the user's directory may
be read. If the DEC-IO monitor al10ws the use of additional arguments on the R

August 3, 1978

Page 3-67

EZU-.w&I&MWI&&WMI&tfii,MMEAM 44 ]\A tV ". ¥ '

o

Mac1isp Reference Manual

, command line. then the particular name of a file may be specified (but not a directory).
The extension defaults to IN!. This file is read in the same way as a LISP.lNI file.
This can be used to start up a subsystem .
. As' in the ITS implementation. a subsystem can be saved and then invoked by the
appropriate R or RUN command.

in the Multics implementation
The Maclisp subsystem is entered by issuing the LISP command at Multics
command level. If LISP is called with no arguments. a copy of the standard initial
environment containing all the system functions and variables is made the current
environment. If the LISP command is issued with an argument, the argument
concatenated with ".sv.LISP" is the path name of a saved environment which is copied
into the current environment. This saved environment would contain some subsystem,
which wil1 receive control. Additional arguments to the LISP command in this case are
actually arguments to the subsystem.
Often one constructs a trivial command for getting into a subsystem, which simply
calls the LISP command with the right arguments.
For instance, the LISP compiler subsystem may be entered through the
LISP compiler command, which ca1ls LISP with the pathname of the saved environment
containing the ,LISP compiler as the first argument, and the arguments to the
LISP ...compiler command as the remaining arguments.
When the standard initial environment (i.e. the, ordinary Maclisp subsystem) is
entered, it checks for a segment named starLup.LISP in the user's home directory. If
such a segment exists, it is read in, using the load function. This facility anows users
to "customize" LISP.

1.7.2

Saving an Environment

A subsystem is constructed by the following procedure. One starts with the ordinary
M aclisp subsystem, and defines a number of function definitions and variable values.
This creates an environment which is capable of implementing the desired SUbsystem.
This environment is then saved in a file, and necessary mechanisms are set up so that an
operating-system command can invoke LISP and cause it to set up the environment

Page 3-68

~3-1. 7.1

August 3, 1978

o

0,

The System

sa ved in' the fil~. W.hen the saved environment is invoked control is passed to the
functions in it which then proceed to do the business of the subsystem.
The exact way of saving the environment differs from implementation
implementation. In the Multics implementation there is a function ca11ed save:

to

FSUBR

save

(save foo) saves the current LisP environment in a file named foo.sv.LISP
in the working directory. foo is not evaluated. The saving operation destroys the
working copy of the environment, so when the save is complete LISP returns to
Multics command level.

All variable values, file objects, array contents, and function definitions (and
other properties) are saved, but the contents of the push down lists, induding
previous values of bound variables, cannot be saved, so save should only be used
from top level. (See also the section on Gaining and Keeping Control, below)

c

In the PDP-IO implementations there is a function ca11ed suspend:
suspend

LSUBR 0 to 2 args

suspend puts LISP in a state such that it can be :PDUMP'ed (ITS) or
SSA V E'd (DEC-IO) and later restarted. When the saved core image is restarted,
everything will be the same as it was when suspended, and, control win return
from the invocation of suspend.
suspend may be used at any point in a computation, with the restriction that
no I/O devices other than the terminal may be in use. If an I/O device other than
the terminal is in use, a fa i l-act correctable error occurs, indicating the
offending device(s).
In the ITS implementation, care is taken so that all subsystems saved with'
suspend from the same version of LISP will share the pure pages of LISP. In
addition, all invocations of a particular subsystem will share the pure pages
peculiar to that subsystem. Declaration of data to be placed, in 'pure pages is
described in a later section.
In the TOPS-IO implementation, care is taken so that a11 LISPs and
subsystems saved from LISP will share the same high segment.

o

Aug'ust 3, 1978

~3-1. 7.2

Page 3-69

_

iMi

WIll

&i&i;p&&M:rn,_

T ii, ;

I

;

%iF

'..

o

Mac1isp Reference Manual

After susp'en-d has prepared the LISP core-image for dumping, it returns
c;:ontr<?1 to the operating system so that it can be dumped.
If suspend is given an argument, that argument is explodec'ed and the
resulting character string is passed back to the operating system as a command.
(See eli ne and va 1ret.) (On ITS this is done with a •VALUE; on SAIL this is
done with a PTLOAO. On TOPS-IO the argument is ignored.)
The SAIL version uses the second argument, if present, as a file name. The
high segment is dumped under this name. The low segment should then be saved
with SAVE, not SSAVE. This is used to create subsystems that can share the same
high segment containing code specific to the subsystem.
Commonly one will write a setup routine for a subsystem like this:
(progn
(terpri)
(prine 'options:)
... read in options
(terpr.i)
(prine 'loading)
•.. load in files of functions
(gc)
(ss~atus gctime 0)
(suspend)
(start-the-subsystem)

o

))

The subsystem's environment is now ready for dumping. Alternatively, one
might write (on ITS)
(suspend 'I:POUMP OSK:FOOOIR; 'TS NSUBSYSI

:SALL DONESI
I)
.

-

which will do the dump itself and print a message when done. On SAIL one
might write
.
(suspend 'ISAVE SYS:FOO.SAVI

'(FOO SHR SYS»
See also the va lret function.

~3-1. 7.2

Page 3-70

--

---~------------

.. ------~---- ..- - - - -

---------~.-.---------

- ..

----~------.----

August 3, 1978

o

The System

1.7.3

Gaining and Keeping Control

In the Multics implementation, wheria saved environment is restarted it looks like
an error that returns to top level. The forms in the errl1st are evaluated. These
forms should do whatever is necessary to start up the subsystem. The arguments to the
command which invoked the subsystem may be obtained via (status arg) or (status
jcl ).
In the PDP-IO implementations, when a saved environment is restarted execution
continues from the point where suspend was called. The next form evaluated should do
whatever is necessary to start up the subsystem. (It is also possible to cause the same
return to top level on startup as in the Multics implementation by using va lret instead
of suspend.) The arguments of the command line which invoked the subsystem may be .
obta ined via (status jc 1 ).
'
If the subsystem wants to hide the underlying Mac1isp from the user, it has a
number of facilities available. By setting up its own user-interrupt handlers it can
handle any LISP errors which occur itself. In Newio implementations, it can alter,
augment, or abolish standard interrupt control characters. It can replace the Mac1isp
interpretive interaction loop with its own by using (sstatus top 1eve 1) and
(sstatus break level). It can also provide a totally different interaction loop by not
returning control to the LISP top level when it is started, but instead retaining control
in its own fun~tions which read and respond to user input.

o

It is possible for a subsystem to retain the trappings of M,ac1isp but change the way
things read and print. Macro characters and the read table can be used to change the
way input is parsed; alternatively, setq'ing the variable read will redefine the system
reader function (in the PDP-IO implementations). An output by Mac1isp (with the
exception of character-string messages) is done through the function pr 1n 1, and the
subsystem may redefine this function. In the Multics implementation one simply
redefines it, but in the PDP-IO' implementations the variable pr in 1 must be bound to the
function which is to substitute for prinl.
Some subsystems don't do any of this, but simply consi~t of standard Mac1isp
augmented by some additional functions which may be used in forms typed in at top
level.

1.7.4

0 ,'
,

Purity

",,/

August 3, 1978

~3-1. 7.3

Page 3-71

LLEOili1IbAl.,:;OO;hllii==;;:J.¥ Jr In;;

o

M aclisp Reference Manual

In the PDP-IO implementations, there are some facilities which allow subsystems to
put th~ir non-changing data, function definitions, binary code, etc. into pure pages. This
decreases the load on memory by sharing pages between multiple users of the sam.e
subsystem.
There are some extra storage spaces which are used to store pure (unchanging)
LISP objects. These are the pure list, pure fixnum, pure flonum, pure bignum, and pure
hunk spaces ..
pur copy

SUBR 1 arg

This function makes and returns a copy of its argument in pure storage.
This is primarily of use in the creation of large sharable systems like M ACSYM A.
In implementations other than PDP-IO implementations with pure spaces,
purcopy simply returns its argument.

There are a number of features which control how binary code and constants
are purified when a compiled program is loaded into LISP.

bporg

o

VARIABLE
The value of bporg should always be a fixnum, whose value is the address of
the first unused word of binary program space. This value generally should not
be altered by the user, but only examined: bporg is updated whenever binary code
is loaded by 1ap or fas load.

bpend

VARIABLE
This variable should also always have a fixnum as its value; this indicates the
last a.vailable word of binary program" space. This is updated by many internal
LISP routines, such as the garbage collector, the array allocator, and lap and
fasload.

pagebporg

SUBR no args

Causes the variablebporg to be adjusted upwards so as to lie on a page
boundary. This is principally useful on ITS in conJunction with the function
pur i fy. pagebporg returns the new value of bporg.

Page 3-72

l3-1. 7.4

August 3,1978

The System

getsp

LSUBR I to 2 args
(getsp n flag) ensures that (- bpend bporg) is at least n, allocating more
memory if necessary. If flag is non-n11, then the memory added is marked as
being potentially purifiable by pur i fy. If flag is omitted, the value of pure is
used. This is generally used by clever subsystems loaders to expand binary
prog~am space quickly so that fas load will not require several garbage collections
to do the same thing. It can also be used by programs which create and destroy
many arrays. See also noret.

noret

VARIABLE
Normally the garbage collector will return memory to the time-sharing system
if (- bpend bporg) is very large, but setting noret non-n i 1 prevents this.
This is useful in conjunction with getsp.

purify

o

o

SUER 3 args

The first two arguments to pur i fy should be fixnums, delimiting a range of
memory within the LISP system. The third argument is a flag. If it is nil, then
the pages covered by the specified range of memory are made impure, i.e. writable.
If it is t, then the pages are made pure, i.e. read-only and sharable. If it is
bporg, then the pages are made pure, but in addition some work is done to make
sure that no UUO on those pages may ever be "clobbered". (See pure and
pure 1obr 1) This option should always be used if the pages involved contain
binary code loaded by lap or fasload. Presently purify does nothing in the
TOPS-IO implementation; it is intended primarily for producing systems built on
LISP, such as M ACSYM A, in such a way that pure pages can be shared between
users. Example: the fo11owing function might be used to produce a sharable
system on ITS:

August 3, 1978

~3-1. 7.4

Page 3-73

_MIIII&&l4IDi1W=UGll$ "

; ;

1M

o

Maclisp Reference Manual

(defun superdump ()
(setq lopage (pagebporg»
;savelowpageaddress
(setq pure 3)
;specifies pure code
(setq lopage (+ lopage 6000» ;allow for area I
; (ITS page a 2000 words)
(fas load funny fas 1)
;Ioad up system
(fasload weird fasl)
(uread some lap)
(sstatus topleve1'
;set up top level for system
"(top-handler»
(setq hi page (pagebporg»
;save high page address
(purify lopage (1- hipage) "bporg)
;purify pages
(suspend "I: pdump sys: ts super"" I) ;tell ddt to dump
(terpr i)
;stuff for system startup
(prine "welcome! to! supersystem!!)
(terpri»

VARIABLE

pure

This variable, initially ni 1, should be made non-n1 1 by the user before loading
binary code which is to be made pure. It signals lap and fasload to be
circumspect about any UUO's in the code, because pure UUO's cannot be clobbered· to
be PUSHJ's or JRS T's. 1ap solves this problem by clobbering the UUO immediately if
the referenced function is already defined and is itself a subr rather than an
ex pr; otherwise the UUO is made permanently unc10bberable (j.e. CALL is converted
to CALLF, etc.).·
'

o

fas load is somewhat more clever: it too tries to clobber each UUO immediately.
but if it can't it puts the address of the UUO on a list called purelobrl, which is
checked at the end of each call to fasload, and each UUO on the Jist is clobbered
·at that time, if the appropriate function had been loaded by that caU to fasload.
If the function· never does get defined, then pur 1fy win also check pure 1obr 1
and convert each UUO to its permanently unclobberable form.
1

I'

If pure has a fixnum as its value, then fasload (but. not lap) behaves
somewhat differently. pure should be the desired size in words of the "uuoUnks
area"; this is rounded up to a whole number of pages. (If pure is between I and
8, it is the number of pages rather than the number of words.) Let the number of
pages be n. First fas load calls pagebporg, and then reserves 2n pages of

Page 3-74

l3-1. 7.4

August 3, 1978

,"i
,

'

~,

o

o

, The System

binary program space. unless a previous can to fasload has already reserved
them (Le. they are reserved only once). Thus fas load has two sets of n pag~s to
work with; we shan ca II the first set "area I" and the second set "area 2". Now
whenever fas load has to load a c10bberable UUO, it does not place it in the code
being loaded, but rather hashes it and places it in area I if it was not there
a tread y; a copy is placed in the same relative position in area 2. Then an XCT
instruction pointing to the UUO in area I is placed in the binary code. When an
loading has been done. area 2 may be purified, but area I may not.

c

Now when running the code, the UUO's pointed to by the XCrs may be
clobbered (the PDP-IO LISP UUO handler is clever about xcT), provided, of
course. that the va lue of nouuo is nil, and the code will run faster the second
time around because the XCT's will point to PUSHJ's. However, if (sstatus
uuo 1 inks) is called. then area 2 is copied back into area I, effectively
unc10bbering all the UUO's. This ailows the called functions to be traced again, for
example, or redefined as expr code. Naturally, an area large enough to contain
all the UUO's should be reserved; (status uuolinks) (q.v.) yields information
relevant to this. As a rule of thumb.' the area hsould be 201. larger than the
number of functions called by the loaded code (including LISP functions such as
eQua 1). For the DEC-IO version, pur,~ may be set to a negative value. the
magnitude is used as above, while the sign' controls which segment to load into
(positive = low segments, negative = high segment). A negative value also causes
uuolinks a'rea 1 to go in the low segment, and area 2 in the high segment. For
compatibility, a negative value means the same as a positive value to the ITS
implementation.

purclobrl

VARIABLE

Used by fas load to keep track of UUO's which are potentially but not
immediately c1obberable.

VARIABLE

*pure

This variable controls automatic purification of S-expressions and atomic
symbols. If it is set non-n i 1 (the initial value is n i 1), then the following are
placed in pure storage spaces instead of regular storage spaces: pnames of atomic
symbols; list. fixnum, Honum, bignum, and hunk constants used by code loaded
with fas load; properties whose indicators are in the list which is the value of the
va riable putprop (initia1Jy subr. fsubr, and 1subr). In the SAIL
implementation, if *pur~ is a fixnum, it should be an estimate of the total number

o

August 3, 1978

l3-1. 7.4

Page 3-75

~iiiiiiHWIGBM&Ii_MiliililiWii!liiIiA&lMWMiWiMW&&IJiWILQi4k;g=;

AM

;;;4\4;, q.j

I

4 k

"

"

M aclisp Reference Manual

o

of pure data structures needed, including all files previously loaded and the
it:litial LISP system pure data structures (currently about 6000. words). This
causes purcopy to use the high segment for pure data. Making the estimate in
*pure too large merely wastes space in the high segment; making it too smal1
causes purcopy to make copies in the low segment when it runs out of room in the
high segment. This whole feature only works if pure is a negat~ve fixnum.

putprop

VARIABLE

If the value of *pure is non-ni 1 and the third argument to the putprop
function is in the list of indicators which is the value of the variable putprop,
then the second a rgument is passed through purcopy to purify the structure.
Furthermore, the two cells of the property list are cons'ed from pure list space.
Since impure cells must precede pure cells in the property· list, putprop may not
put a new property at the front of the property list in this case.

The putprop and remprop functions know about purified property lists. If
necessary. they will copy the property list (but not the properties themselves) into
non-pure storage so that it can be modified. This is true regardless of the value
of *pure. Recall also that defprop and defun use putprop.

Page 3-76

l3-1.7.4

August 3, 1978 .

o

o

The System

o
1.8

Miscellaneous 'Functions

1.8.1

The Status Functions
FSUBR

status

The status special form is used to get the value of various system
parameters. Its first argument, not evaluated, is an atomic symbol indicating
which of its many functions status should perform. The use of additional
arguments depends on what the first argument is. These arguments mayor may
not be evaluated, depending on the first argument. If certain additional
arguments are omitted, a default value is supplied, again depending on what the
first argument is. The various status functions are listed below.

FSUBR

sstatus

The sstatus special form is used to set the value of various system
parameters. Its arguments are similar to those of status.
These are the things that you can do with status and sstatus:
STATUS FUNCTIONS FOR I/O

o

tabs i ze

( s ta tus tabs i ze) returns the number of character positions assumed
between tab stops, which depends on the implementation. Currently this is 8
in the PDP-IO implementation and 10. in the Multics imple!'"entation.

newl ine

(status newline) returns a fixnum which is the ascii code for the
character which marks the end of a line of input. For example, one might
say (= (setq ch (tyi» (status newline» . Cureently this is 15
(octal) in the PDP-IO implementation and 12 (octal) in the Multics
implementation.

charmode

(status charmode f) returns the value of the character-mode switch for
the file f.. If f is t or omitted the value of ty.o (the default output
termina 1) is assumed. If the character-mode switch is t (the normal case for
the termina I) output is sent to the deVice as soon as it is generated. If the
switch is nil (the normal case for files other than the terminal) output is
held until a newline is typed, an error occurs, input is requested, or the

August 3, 1978

~ 3-1.8

Page 3-77

Mac1isp Reference Manual

o

buffer becomes full. (In the Multics implementation, you can also cause the
buffer to be sent by using. the force-output function.) This provides
increased efficiency at the cost of not immediately seeing all output in some
cases.
(sstatus charmode x f) sets the character-mode switch of the file f (f
may be t or omitted to signify the output terminal in the tyo variable) to x,
which may be n11 or t. x and f are ,evaluated. Currently in ~he PDP-IO
implementation it is not possible to set the character-mode sWitch; one must
spec~fy it initially to open. See also (status linmode) and (status.
fi lemode).
1 inmode

ttyint

(status 1 inmode) reads the "line mode" .and (sstatus 1 inmode x) sets
the "line mode" to x (t or nil.) These functions take an optional extra
argument, which - is the file whose line mode is being discussed. This
defaults to the value of tyi (the default input terminal). In any case, this
file must be a terminal. In some implementations the "line mode" may not be
changed. If the "line mode" is t, user input is buffered up a line at a time
before being sent to LISP. The input-editing conventions of the host
operating system are used. If the "line mode" is n 11, LISP sees each
character as it is typed and applies its own input editing conventions. This
mode can provide input facilities more suited to LISP and possibly better
handling of the terminal,' if it is a type that LISP knows a great deal
,about. However, it uses more machine resources. It is possible for a user
program to take direct control of the terminal when the "line mode" is nil;
however, this may require knowledge of the (sstatus tty). The Multics
implementation always operates with a "line mode" of t. See also the
(sstatus ttyscan) function below.

o

ttyint char func file) turns on a tty interrupt character.
When the character char is typed on the input tty file, the LISP program
will be interrupted and the function fune will be applied to two arguments
- file and char. If file is omitted, the value of tyi (the default input file) is·
assumed. The char may be either a character object or a· fixnum (ascii code).
Any of the 128. ascii characters may be used. The fune may be either an
ordinary functional form or a fixnum, which means the default system
action for the character with that ascii value. For instance a fune of 7
means quit back to the top level of LISP (control-G). If fune is nil, the
char is made non-interrupting. All three arguments are evaluated.
(ssta~us

I

In the ITS implementation, it may be necessary to use (sstatus tty) to
inform ITS about non-standard interrupt characters.

Page 3-78

13-1.8.1

August S, 1978

o

o

The System

In PDP-IO implementations which support fixnum tty input mode (more
. than 128. characters), then when an interrupt occurs the character is folded
down to 7 bits before selecting an interrupt ftinction. However, the
unfolded character is passed as the second argument to the interrupt
function, so that the function can filter out unwanted characters. If a
fixnum is used for the function, then the fixnum may specify required or
forbidden supra-ascii bits as foHows: adding bit n to the fixnum requires
the bit, and adding (Ish n 18.) forbids it. For example~ in the ITS
implementation using 400000207 (octal) as a function allows CTRL/g to
perform a qUit, but not the "pi" character or control-meta-g, since 200
requires the control bit and 400000000 forbids the meta bit.
standard subsystem convention (used by NCOMPLR,
MACSYMA, and SCHEME, for example) is to use ,..,.. (controluparrow, ascii 036) as a quit character which restarts the subsystem.
This leaves "'g with its normal meaning of "exit to LISP topleve.,"
which is occasionally also useful.

Example:

a

(sstatus ttyint 36
(function (lambda

o

(f c)

(sstatus top1evel /(restart-subsystem»
(do nil «or (= (listen f) 0)
(= (tyi f) 36»»

("'g»»
(defun restart-subsystem ()
(setQ err1ist nil)
(sstatus top1evel nil)
(nointerrupt nil)
(initialize-the-world)
(enter-subsystem»
(status ttyint char jile) returns func, the interrupt function for the
character char on the tty file. file may be omitted. It defaults to t.
ttycons

o

(sstatus ttycons tty1 tty2) binds two tty files into a console. One
should be an input tty and the other an output tty. If tty1 or tty2 is t, it
will be taken as the appropriate direction of the default terminal
(determined by the variables tyi and tyo). The binding into a console is
primarily used for purposes of echoing. In addition, interrupt characters
typed on an input tty file should affect the output on its corresponding
output tty file, not on some other tty. If ttyl or ttyZ already has a

August 3, 1978

Page 3~79

~3-t8.1

iiMMMi

====iG£MWGAM;;;UUC""UWMliQAI\TT"

o

Mac1isp Reference Manual

ttycons relationship, that relationship is broken before the new one is
established.
If one ~rgument is a tty and the other is nil, a ttycons relationship
involving that tty will be broken. Closing a tty file automatically breaks
any ttycons relationship it may have. (See close.)
To put echoing at the bottom of the screen, distinct from output,
(sstatus ttycons t
(setq echotty (open 'tty: '(echo out tty
echotty) )
which conses tty input with a new tty output channel which is set to go to
the echo area at the bottom of the screen.
(status ttycons tty/) returns the other tty file which.is bound into a
console with ttyl, or nil if there is none.
f1lemode

(status filemode file) => (open-mode-list • internal:-cruft).
open-mode-list is a suitable second argument for the open function.
internal-cruft is a list of implementation-dependent information which may
sometimes be needed by special programs..

o

The following symbols may appear in internal-cruft. (These are the
standardized ones; additional symbols may appear at the discretion of the·
implementation.)
cursorpos

This file (an output tty) has the ability to position its
cursor anywhere on the screen. See cursorpos.

fi1epos

The filepos function can be used to access randomly
within the file. See the fi1 epos function.

rubout

This file (an output tty) has selective erase capability.
(cur sorpos 'x) will work. See also the rubout
function, page.

sai 1

This file (an output tty) has the so-caned SAIL character
set. This is an extension of ascii which is related to but
not necessarily identical to the actual character set used
at SAIL.

Page 3-80

.--~--~~.--

..--.. ---~

_ . _ - - - - - ..... ------- -- ..

l3-1.8.1

---.------~-~---

._ ..._----_._._-_._-----

August S, 1978

o

o

The System

If file is a closed file object, (status fi-1emode) merely returns nil
. instead of giving an error.
ttyscan

(sstatus ttyscan rune file) al10ws the user to supply a function which
performs initial processing of terminal input. fune. is a functional form,
and file must be a tty input file. If it is omitted, the value of ty1 (the
default input terminal) is assumed. Both arguments are evaluated.
When LISP wants to take input from file, it first cans the prescan function,
which is supposed to gobble down a complete unit of input (for instance an
S-expression) and return a list of characters. The prescanner supplied
automatically by LISP when a tty input file is first opened counts
parentheses and does fancy rubout processing on display terminals. It also
implements the CTRL/k, CTRLI1, and CTRL/u characters (as appropriate
to the implementation) which allow the complete input to be redisplayed or
cancelled, and takes care of force-feed characters. A user-written
prescanner might provide additional features such as super-parentheses,
name recognition and completion, or fancy editing.

C\
.J",I

The prescan function fune is applied to three arguments: the file, the name
of the input function on whose behalf it is acting (read~ readch, or
read 1 i ne), and a fixnum which, in the case of read, is the count of the
number of unmatched Jeft-parentheses. It is supposed to return a list of
fixnums, which represent characters. The prescan function shou.ld read the
input with tyi, since it and tyipeek are the only input functions which
don't call the prescan.
If the prescan function returns nil, an eof condition occurs for the input
file. This is the standard way to signal over-rubout.
There is a fUnction called rubout to assist the pre-scanner in processing
rubouts. It is described on page.
It is a good idea for the prescari function to 1ambda-bind echofi 1es to
nil so that characters do not appear in the echo files twice, and so that the
echo, files reflect the "clean" input after rubout processing. The systemsupplied prescan function does this.
(status ttyscan file) returns the jile's fune.
This feature does not presently exist in the Multics implementation.

o

August 3, 1978

e3-1.8.1

Page 3-81

MWiIiAM===aQ:r;;;4ii11$(

44 raG $4hNi "A,4

a:::

ki

:;,; --

o

Maclisp Reference Manual

The fol1owing status functions exist only-in the ITS implementation
ttysize

ttytype

(status ttysize f) returns the height and width of the terminal open as
the file f. If f is omitted, the value of tyo (the default output terminal) is
used. The result is a dotted pair of fixnums "(ttyheight . ttywidth)" (cr.
cursorpos). If the terminal is a printing console instead of a display, then
the height wil1 be a very large number such as 200000000000 or so.
(statusttytype f) returns the type of the terminal open as the file f. If

f is omitted, the value of tyo (the default output terminal) is used. The
result is a fixnum taken from the TCTYP (not TTYTYP!) variable in ITS:

o

' Printing terminal.

I
2
3

Good Datapoint.
Bad Datapoint ("loser").
Imlac.
Tektronix.
PDP-II ("Knight") TV.
Memorex.
Software terminal.
Terminet.
Displa.y using standard ascii display codes.
Datamedia.

4
5
6

7
10
11

12

o

This status call is meant only for esoteri, purposes. To find out whether
you can position the cursor or erase characters, use (status f11e~ode).
tty

(status tty f) returns a Jist of three fixnums whi~h control the behavior
of the terminal open as file f. If f is omitted, the value of tyi (the default
input terminal) is used. (sstatus tty x y % f) sets these three fixnums
to x, 'j, and z. If % is omitted, it is not changed. If f is omitted, the value
. of tyi(the default input terminal) is used. The three fixnums are the ITS
variables TTYSTl, TTYST2, and TTYSTS. Their meaning is as follows:
'
TTYSTl and TTYST2 are divided into twelve groups of six bits. Each group
controls a certain subset of the ascii characters. These' groups, in left-toright order within TTYSTI and TTYST2, are:
(0) A@_AF AK AL AN-AR AT_AZ A\_A_

(1) A-Z a-z (letters)
(2) 0-9

(digits)
(3) ! " II S % & " , • : ; ? @ \ ' I (4) + * - I = A _ (arithmetic operators)
Page 3-82

~3-1.8.1

August S, 19'78

o

The System

(5)< > ( ) [ ] (parentheses)
(6) AG AS
(7) AI AJ ~tab, linefeed)
(8) altmode (ascii 33)
(9) AM (carriage return)
(10) rubout (ascii 177)
(1"1) space, AH (backspace)
The meanings of the six bits in each group are:
40
20
10
4

2

1

Echo the character when read by LISP (normal mode).
Echo the character when typed (this may disappear from ITS soon!).
Echo in "image mode" rather than "ascii mode"
Convert lower case' to upper case (applicable only to letters; not
normally used by LISP - the readtable accomplishes case
conversion).
Activation characters. If this bit is not set, then ITS win not
schedule LISP to run when you type a character within the group
even if LISP was waiting for terminal input. The only purpose of
this is to increase the efficiency of the time-sharing system. For
example, letters and digits normally have this bit off, since typing one
cannot terminate an S-expression, and there is no point in
"activating" LISP until an S-expression terminator like space or ")"
has been typed. An exception to this rule is that for tyi and readch
LISP asks ITS to activate on any character. Normally only groups
(0), (5), (6), (7), (9), (10), and (II) are activators. If you alter the
readtable, you may wish to change the activator groups.
Interrupt characters. If this bit is not set, then even if you have used
(ss ta tus t tyi nt) to set up an interrupt function you will not get
the interrupt since ITS won't tell LISP about it. Initially only
groups (0) and (6) cause interrupts (these include an controlcharacters except altmode and format effectors). If you give .. an
interrupt function, for example, you should set this bit for group (3).

On a keyboard with supra-ascii characters, one may wish to use metacharacters for interrupts. Suppose we want meta-D to run the function
foo. "Then we would turn on the interrupt bit for group I (letters) and say:

(sstatus ttyint 104
;letter 0
(function (lambda (f c)
(and (= c 504)
(foo»»

o

;meta bit
; is 400

- filter .out plain "0"
August 3.1978

e3-1.8.1

Page 3-83

-.wamfWA&M&iI&iMiQiiIhlAliUtMJiQJJUM&U_&kt,q ;£I@I, ;; A'WUg

,* #$

i· 4

o

Maclisp Reference Manual

Notice thai this only handles meta-D, not meta-d. To handle the latter, one
must also do (sstatus ttyint 144 ... ).
Another way to filter out plain "D" is

(sstatus ttyint 504
;require meta bit
/(lambda (f c) (foo»)
which is somewhat more efficient. 'On the other hand, to use both meta-D
and control-meta-D, we must do a dispatch on the control bit:

(sstatus ttyint 4
/(lambda (f c)
(cond

; ignore
«or (= c 304)(= c 344»
(setq Ad t»

«or (= c 504)(= c 544»
(meta-d-foo»
«or (= c 704)(= c 744»
(~ontrol-meta-d-foo»»)

The third variable, TTYSTS, has thes'e bits of interrest:
40000_22 (%T5FCO) If set, output on this terminal uses the supra-ascii
convention of an "alpha" prefix for "control" and "beta" for
"meta".
2000o_22 (%TSALT) If set, ascii codes 175 and 176 are not converted to
33 on input.
1000o_22 (%T5ROL) If set, terminal is in scroll mode.
4000_22 (%T5SA1) If set, echoing and ascii output use the SAIL
character set; otherWise, control characters are output in the
form "AX".
10 _22 (%TSNOE) If set, suppress echoing of typed characters.
2_22 (%T5511) If set, terminal uses"super-image input" mode. Not
even "'z and'" _ can take their usual effect for ITS.

o

Notice that some of these bits affect output even though the argument is an
input file; they affect the output terminal which is logically related by ITS
to the input terminal. Normally LISP or the user win arrange for
(s tatus t tycons) to reflect this relationship.

Page 3-84

l3-1.8.1

August S, 1978

o

-~---~'---'---~----'-------~---

The System

o

STATUS FUNCTIONS FOR THE OLD I/O SYSTEM
uread

( status uread) returns a i-list for the current uread input source, or
nil if uread is not being done.
(sstatus uread --args--) is the same as (uread --args--)

uwrite

(status uwrite) returns the 2-list for the current uwr1te output
destination.
(sstatus uwrite --args--) is the same as (uwrite --args--)

crunit

(status crunit) returns a 2-list of the current unit; i.e. device and
directory.
( ss tatus ,crun it devi ce directory) sets the current default device
and directory for uread, etc. The arguments are not evaluated.

crfile

c

(status erfi le) returns a 2-list giving the file names for the current file
in the "uread" 1/0 system.
(sstatus crfile name! name2) sets the current default file names for
uread, etc. The 'arguments are not evaluated.

STATUS FUNCTIONS FOR TH'E READER
See section 13.6.2 for a description of how the parameters controlled by these
fuilctions a re used. A1I of these parameters are kept in the read tables, and the status
functions below deal with the readtable which is the value of the variable readtab 1e.
Note: in the following, c represents an argument specifying a character. If c is nonatomic it is evaluated, and the value must be a fixnum which is the ascii code for a
character. If c is atomic it is not evaluated, and it may be a fixnum or a character object.
chtran

(status chtran c) gets the character translation table entry for the
cha racter c. This is the ascii code of a character substituted for c when it
appears (not preceded by slash) in a pname being read in. This feature is
used in the PDP-IO implementations to translate lower-case input to upper
case.
(sstatus chtran c k) sets c's character translation to k. k is always
evaluated. See the setsyntax function.

August 3, 1978

~3-1.8.1

Page 3-85

_ _ aI&lWi&W!dWAiWMMll&iiliMli&MLi:ml!iAWGGl;,;mwW;;;;:k;;L&;lA41A ,;; j ,ii,

; ".,

QiTAP4#PP .... ~

o

Mac1isp Reference Manual

1,1

syntax

(status syntax c) returns the syntax bits for the character c, as a
·fixnum.
(sstatus syntax c m) sets c's syntax bits to m. m is evaluated and
returned. The setsyntax function is usually a better way to do thiS,
however.

Note that in the a~ove two sstatus calls, if c is a macro character it is changed back to
its standard syntax andchtran before the requested operation is performed. However, if
in the standard readtable c is a macro (Le. / and ; and I), instead of being changed .to
its standard syntax and chtran its syntax is set to 502 (slashified extended alphabetic)
a nd its chtran is set to itself.
macro

(status macro c) returns nil if c is not a macro character. If c is a
macro character it returns a list of the macro character function and the
type, which is ni 1 for normal macros and spl icing for splicing macros.
(sstatus macro c f) makes c a macro character which calls the function f
with no arguments. f is evaluated. A fourth argument to sstatus may be
supplied.' It is not evaluated. If it is an atomic symbol whose pname begins
with s, c is made a splicing· macro. If f is nil, instead of c being made a
macro-character, c's macro abilities are .taken away and c becomes an
ordinary extended-alphabetic character. The setsyntax function is
. generally a better wa y to do this, however.

+

o

(status +) gets the value of the + switch (t or n11) in the readtable.
This switch is normally nil. If it is t, atomic symbols more than one
character long beginning with a + or a - are interpreted as numbers by the
reader even if they contain letters. This allows the use of ihput bases
greater than ten. See i base.
(ss tatus + x) sets the + switch to t or n 11 depending on x, which is
eva luated. The new value of the + switch is returned.

t tyread

( s ta tus t tyread) returns the value of, the ttyread switch in the
readtable. At present this is not used. for anything in the Multics
implementation. In the PDP-IO implementation it controls how tty "force
feed" characters are used.
:1

(sstatus ttyread x) sets thettyread switch to t or nil depending on x,
which is evaluated. Again, file defaults to t. The new value of the switch
is returned.

Page 3-86

~ 3-1.8.1

August 3, 1978

o

o

The System

STATUS FUNCTIONS FOR THE PRINTER
terpri

(status terpr i file) returns the value (t or nil) of the terpri switch for
the jile, which defaults tot. This switch is normally n11. If it is t, the
output functions such as pr i nt and tyo will not output any extra
newlines when lines longer than 1. i ne 1 are typed out. See also the terpr 1
variable.
( ss tatus terpr i x file) sets the.terp~i switch.
(status _ ) returns the value (t or n11) of the _ switch for'the current
readtable. If this switch is t, the _ format for octal fixnums with lots of
trailing zeroes is not used.
(ss tatus _ x jile) sets the _ switch to the value of x, t oro 11.

abbreviate(status abbreviate) returns the value of the abbreviation control. See·
section 13.7 for a description of the abbreviation control. Note that the
abbreviation control is kept in the current read tab Ie.

o

( ss ta tus abbrevi ate n) sets the abbreviation control to n.
(sstatus abbreviate n11) turns off abbreviation.
, ( ss tatus abbrevi ate t) turns on maximal amount of abbreViation.

STATUS
FUNCTIONS
COLLECTOR
gctime

FOR

THE

GARBAGE

(status gctime) returns the number of microseconds spent garbagecol1ecti~g.

(sstatus gctime n) resets the gctime counter to n and returns the
previous value of the gctime counter.
It is a good idea to do (ge) and then (sstatus getime 0) just before
dumping out a subsystem. See also (status gcwho) ..

spcnames

10

(status spenames) returns a list of the names of all the spaces available.
in the LISP being used. These are the names acceptable to the a110c
function and to the following status functions which require a space
argument.

August 3, 1978

e3-1.8.1

Page 3-87

DC

USUUJum=C;;1A&iGUm;;;;:1iMCA ;,,4 ,4 m.l

;

$\

I

,8#M/f2#k G4M!T¥ 44

qu

o

Mac1isp Reference Manual

spes i ze

(s tatus spes i ze space) returns the actual current size of space, in
words. space is evaluated.

gemax

(status gemax space) returns the gemax parameter for space.
sstatus gemax space n) sets the gemax parameter for space to n.
See the all oe function.
(status gemin space) returns the gemin parameter for space.

gemin

sstatus gemin space n) sets the gemin parameter for space to n.
See the all oe function.
(status gesize space) returns the gesize parameter for space. This is
not the actual size of the space, - see (status spcsize).

gesize

ss tatus ges i ze space n) sets the ges i ze parameter for space to n.

o

See the all oe function.
purspenames

(status purspenames) returns a list of nalpes of spaces which
have pure versions. See pur-copy.

pursize

(status purs i ze space) returns the actual current size of the pure
version of space. Only spaces returned by (status purspcnames) have
pure versions. ,

pd1names

(status pd1names) returns a list of the names of an the pdls available
in the LISP being used. These are the names acceptable to the fol1owing
status functions which require a pd 1 argument.

pd 1size

( ~ ta tu s pd 1size pdl) returns the current number of words on a pd 1.

pdlroom

'(status pd1room pdl) returns the "pdlroom" of, a pdl, i.e. the maximum
size to which it may ever grow.

pdlmax'

(status pdlmax pdl) returns the current value of the pdlmax parameter
of a pdl.
(sstatus pd lmax' pdlsize) sets the pdlmax parameter for the pdl space to
size. Both arguments are evaluated. See also the alloc function.
l3-1.8.1

Page 3-88

"'---~-

.. ' "

. . . . .- - ....-

...

,,-~.-,,-

....

_............._ ........ ..

August S, 1978

o

o

The System

The following status function exists only in the PDP-IO implementation
memfree

(status memfree) returns the number of words of address space not yet
allocated for any purpose (i.e. still available for allocation to various
spaces).

ENVIRONMENT ENQUIRIES
Note: the variou.s enquiries related to time may return nil in the rare circumstance that
LIS P cannot determine what time it is.
date

(status date) returns a 3-iist of fixnums indicating the current date as
(last-two-digits-of-the-year month-number day).

dow

(status dow) returns an interned atomic symbol which is the name' of the
current day of the week.

dayt ime

(status dayt ime) returns a 3-list of fixnums indicating the 24-hour time
of day as (hour mi nute second).

system

(status system x) returns a list of the system properties (that is,
properties whose values are supplied in the initial LISP system) of the
atomic symbol x, which is an evaluated argument. This list may contain
subr, fsubr, lsubr, macro, autoload, or array if x is a system
function, and va 1ue if this atomic symbol is a system variable.

lISPversion
(status LISPvers i on) returns the version identification of LISP. This
is usually an atomic symbol.
. jcl

(status jcl) returns the "job command line" from DDT in the PDP-IO
implementation. This is used to specify the init file, but interpretation of
the file name is terminated by altmode, and (in the ITS implementation at
least) additional information may follow the altmode.. The init file may
wish to examine this information. The DEC-IO implementation supports
two syntaxes for jcl:
.R LISP; -jcland .R LISP(-jcl-)
Not all DEC-IO operating systems support both syntaxes, however, and some
support neither. In the Multics implementation this returns the

o

August 3, 1978

€3-1.8.1

Page 3-89

E2222&CtEStoG&i&DtMiAw:;;mw MM,,'; M ,4MiFf\1\4f¥\4f44IM44

4-44P¢¥2 4

¢"'

-- £

~.

II
I

Ii
I

I
,I

o

Maclisp Reference Manual

explodee'd'second argument of the LISP command, or else n11 if the
LISP cpmmand did not have two arguments. (See (status erg).) If
LISP was invoked by
LISP environmenLname "foo bar"
then (status jel) => (f 0 0 I

bar)

This function is also used by subsystems implemented j'n Mac1isp to pick up
the arguments from the command which invoked them.
udir

(status udlr) returns the name of the user's directory. In the ITS
implementation this is the user's "master sname", which is usually the same
as the user's name as returned by (status uname). In the Multics
implementation this is the user's default working directory. In the TOPS10 implementation this is a list (proj prog).

uname

(status' uname) returns an interned atomic symbol whose pname is the
user's login name. In the ITS implementation this is just the .UNAME .
In the Multics implementation this is in the format User.Project.lnstance;
the dot will be slashified if pr i nt is used to display this. In the TOPS-to
implementation this is actually a list (proj prog) representing the projectprogrammer number rather than a symbol. See also (status userid).

o

The following status functions exist only in the PDP-lO implementation.
userid

(status userid) tries to return an identification of the user (as opposed
to an identifica tion of an instance of his being logged in). Thus if a user
is logged in on several terminals, (status uname) may differ among them,
but (status user id) should 'be the same. In the ITS implementation this
returns the .XUNAME as an interned atomic symbol. Normally the
.XUNAME is the same as .UNAME with trailing digits stripped off. It is ,
possible, however, to cause a job to be run with a different .XUNAME.
Subsystem initializations should check th~ userid to determine which jnit
files to use. In the TOPs-lO implementation this the the .GTNMI and
.GTNM2 GETTAB variables as an atomic symbol, if they exist, and
otherwise is the same as (status uname). In the. SAIL implementation
this is the same as (status uname).

jname

(s tatus jname) returns the job name as an interned atomic symbol. The
jname of a job is a unique identifier for it among all of the user's jobs. In
the ITS implementation this is the job's .JNAME. In the DEC-IO
implementation this is nnnLISP, where nnn is the job number in decimal.

i

l3-1.8.1

, Page 3-90

... -""--"'~~--------------"--

"'-

-------..

~

. ---------~-------

... -.-~---

. --------------

August 3, 1978

'~

,I

o

o

The System

xjname

(status xjname) in the I~S implementation returns the .XJNAME as
. an interned atomic symbol. This is normally the name of the program that.
the user invoked to create this job. Usually this wi11 be the same as the
jname, but sa user can invoke severa.1 copies of a program at once, each
having a unique jname but all having the same xjname. In the DEC-tO
implementation this will return the jOb's "program name". On Multics, it
should return (status arg 0).

seglog

(status seglog) returns the logarithm (base 2) of the size of a
"segment", the unit of space allocation. (The size of a segment need not be
the same as the size of a memory page.)

The following status functions only exist in the ITS implementation.
(status its) returns a list of five items (obtained from the SSTATU
symbolic system call):

its

(I) The amount of time in seconds until ITS is going down, as a flonum,

-1.0 if ITS doesn't plan to go down, or -2.0 if ITS already is down.

lei

(2) a fixnum which is nonzero ·if ITS is being debugged.

~)!

. (3) the number of users logged in, as a fixnum.

(4) the number. of memory errors the system has s~rvived, as afixnum.
(5) the time in seconds the system has been up, as a flonum.
Some of this information may be of use to a user handler for the sys-death interrupt.

hactrn

(status hactrn) returns an atomic symbol indicating what kind of job is
superior to the LISP. Current possibilities are ddt, IISP, t (a superior of
unknown type), and nil (no superior).

The foHowing status functions exist only in the Multics implementation.

o

paging

(status paging) returns a list of the paging-device page reads and total
page reads that ha ve been caused by this process.

arg

(status arg n) returns the n+I'th argument of the command which
invoked the subsystem, as an interned atomic symbol. (The first argument,
( status· arg 0), is the name of the subsystem.) nil is returned if n is
greater than the number of arguments to the command ..

August 3,' 1978

~3-1.8.1

Page .3-91

. . . ._I&ii&M. .m=mrar;OC'.=iG£

; inn;;"

"i4 4

AAP#4#f4hG¥\M#

PM;>

o

Maclisp Reference Manual'

STATUS FUNCTIONS FOR THE WHO-LINE
The following status functions exist only in the.lTSimplementation.
whol

(sstatus whol abc d) sets four user parameters for the "who-line"
which appears at the bottom of some display terminals. These control the
print format of information specified by (sstatus who2), (sstatus
who3), and (sstatus gcwho). Each of the four parameters specified eight
bits of information. Parameters a and c must be fixnums; band d may be
fixnums or atomic symbols (which represent the ascii value of the first
character in their pnames). Their meaning is as follows:

a

200 If I, suppress display of entire who-line.
100 If I, suppress space between halves of who2.
70 Mode for printing high 18. bits of who2.
7 Mode for printing low 18. bits of who2.

b

177 If non-zero, print between halves of who2 as an ascii character.
200 If 1, print character twice.

c

200 If I, suppress space between whoZ and who3.
177 As for a, but affects who3.

o

d
377 As for b, but affects who3.
That is, if the who-line is displayed at all, the user information appears in
the form:

where:
PPPPis the result of printing the high 18. bits of whoZ as specified by 4'~
" 70 bits. '
Q..Q..Q.~w 18. bits of who2, by c's 7'bits.

RRRRligh 18. bits of who3, by c's'70 bits.
SSSS low 18. bits of who3, by c's 7 bits.
••

zero to two characters, specified by d.
space, unless a's 100 bit is set.

Page 3-92

l3-1.8.1

August 3, 1978

OJ
'!

-- - - - - - - - - - .._--- - - -

-------~

,--------------~--------,-~-

.. , - , - - - -

The System

space, unless c's 2.00 bit is set.
+

sp~ce, unless c's 100 bit is set.

The possible print modes are:

o

Do not print.
Date in packed form:

774000 Year mod 100.
3600 Month (January -= 1)

174 Da y of month.
Printed as mm/dd/yy.
2

Time in fortieths of a second. Printed as hh:mm:ss.t.

3

Time in half-seconds, printed as hh:mm:ss.
O~tal number.

5

Decimal number (no "." is printed).

6

Three six bit characters.

7

Unused .

. (status whol) returns a list of four fixnums (a bed).
who2

(sstatus who2 x) sets ·the who2 variable to x if it is a fixnum, or to the
sixbit value of the first six characters of the pname of .x if it is a symbol.
(status who2 x) returns who2 as a fixnum.

who3

(sstatus who3 x) and (status who3) are analogous to those for who2.

Example:
(a11 numbers in octal)
(sstatus who! 166 0 144 254)
(sstatus who2 "FOOBAR)
(sstatus who3 (+ (LSH 123422) 3456)

would cause "FOOBAR 1234 ..3456" to appear in the Who-line. The general idea is that

August 3, 1978

l3-1.8.1

Page 3-93

M!i&l&&iAA&&WJ=Ut4L&Git!Mtl&6;UI1#1@4A 4 4 'W; .; 4

'" ¥%t

MA.

;S4MW

4

¢4

,

-¥$

,-

1M4f4b?,

o

Maclisp Reference Manual

the user should set up who 1 just once and then keep updating whoZ and who3 as
appropriate. For example, a routing that processed functions in files might do
(sstatus who 1 166 0 166 0)
and on opening a new file do
(sstatus who2 (cadr (truname infile»)
(sstatus who3 0)
and on encountering a function do
(sstatus who3 fnname)
and so continuously display the filen~me' and function name being processed. One
advantage of doing this over printing the information is that LISP can update who-line
information even though it doesn't have control of the console.

gewho

(sstatus gcwho n) sets the gcwho switch to n. Currently only the low
two bits are significant.

The I bit mea~s that during a garbage collection the who-line should be usurped to
display the message "GC:XXXX", where "XXXX" is the reason for the garbage
collection. On completion of the garbage collection the original user who-line information
is restored.
The 2 bit means that at the end of the garbage collection the who2 word should be
altered so that the low 18. bits get the result of (status get ime), converted to fortieths
of a second, and the high 18 bits get the result of (II (* (status get ime)
Ibo. )( runt ime», which is the percentage of time spent in gc. If the user gives 52
octal and''? as the first two arguments to (sstatus whol), then these quantities will be
displaced in the forin "nn1. hh:mm:ss.t", just like the standard system statistics for the
LISP job. The user can still use who3 for his own purposes.

o

Subsystems which use (sstatus gcwho) should perform
(gc)
(sstatus gctime '0)
before dumping out the subsystem, so that the gc time percentages will be accurate.
(status gcwho) returns the value of the gcwho switch.

I

MISCELLANEOUS STATUS FUNCTIONS
evalhook

Page 3-94

--

-

----~---------.~---~-~

I

!

(sstatus evalhook t) enables the evalhook feat'ure; (sstatus
evalhook nil) disables it. (status evalhook) returns the state of the
switch. See page 3-31 for the details of this feature.

e3-1.8.1

August 3, 1978

o

I

The System

o
to.p 1eve 1

( s ta tu stop 1eve 1) returns the top-level form, .which is continually
·evaluated when LISP is at its top level. If this is nil, a normal read-evalprint loop is used.
(sstatus toplevel x) evaluates and returns x and sets the top level
form to this value.
For example, to make Mac1isp have an evalquote top level Similar to LISP
1.5:
'
(sstatus top1evel
/(progn (print *)
(apply (read) (read»

»

See section 12.1 for further details.,
break1evel

(status breaklevel) returns the break-loop form.
(sstatus
breaklevel x) sets this form. See page 3-6 for how this is used.

uuolinks

(status uuolinks) returns a number which represents the number of
available slots for linking between compiled functions.
(status
uuolinks) returns nil if no uuolinks pages have been set up yet (see
pure). Otherwise it returns a list of two items. The first is t if area 2 has
been purified (and so no new cans may be put in the area), and nil
otherwise. The second is the number of slots not yet used in the uuol1nks
areas.
( ss tatus uuo 1 inks) causes all links between compiled functions to be
"unsnapped." This should be done whenever (nouuo t) is done to insure
that the interpreter always gets a chance to save debugging information on
every function call.

divov

(status divov) returns the state of the "diVide overflow" switch; If this
. SWitch is nil an attempt to divide by zero causes an error. If the switch is
t the result of a division by zero is the numerator plus l.
(sstatus divov x) sets the "diVide overflow" switch to x.
In the PDP-lO implementation, divov applies only to quot lent. II and
lIS d~ not detect division by zero.

mar

o

(sstatus mar cond loc) arms the mar (memory address register) interrupt

August 3, 1978

~3-1.8.1

Page 3-95

4744 ¥ ASP 4

q

r·-

Mac1isp Reference Manual

o

(currently available only in the ITS implementation). (status mar)
returns ali st of cond and loc, or nil if the mar feature is not in use.
See the mar break feature for more details (page 3-55).
features

(status features) returns a list of symbols representing the
features implemented in the LISP being used. The following symbols may
appear in this list:
bibop

PDP-IO big-bag-of-pages
scheme

lap

this LISP has a LISP Assembly Program loaded

sort

the sorting functions described in chapter 11 are
present

edit

the edit function described in chapter 18 is present

fasload

the fasload facility described in chapter 14 is
present

memory

management

o

the "moby I/O" facility is present
bignum

the arbitrary-precision
included in this LISP

hunk

the hunks data type and its associated functions
are present.

funarg

the "fake funarg" feature (second argument to
eva 1, third to app 1y, etc.) is present.

strings

character strings and the functions
described in chapter 8 are present

newio

the I/O functions described in chapter 13 are
included in this LISP; if this feature is not
present only some of those functions are available.

arithmetic

package

on

is

them

I

Page 3-96

roman

this LISP can read and print roman numerals (see
base and. i base.

trace

the trace package (chapter 15) is present.
~3-1.8.~

August 3, 1978

----------------~---------------------------------------------

"

i'

o

The System

o
grindef

the function definition formatter (chapter 16) is
present.

grind

the file formatter (chapter 16) is present.

compiler

this is the LISP compiler (chapter 14) rather than
the interpreter (see also compi ler-state).

fastarith

the

fast-arithmetic
are present

features

of

the

compile~

0

ml

this IISP is on the Mathlab machine at
MIT

ai

this IISP is on the AI"machine at HIT

mc

this IISP is on the Me machine at MIT

SAIL

this IISP is running at SAIL

H6180

this LISP is on an H6180 Multics macb1ne
or a compatible machine such as a 68/60
or a 68/80.

its

this IISP is on some ITS system

Multics

this IISP is on some Hultics.system

TOPS-IO

this IISP is on some DEC TOPS-IO system;
or on some TENEX system since the TENEX
implementation runs under a TOPS-IO
emulator.

A package being "present" means that it has been loaded into
the environment. If (status features) claims it is not present, it
may still be available because it may be automatically loaded when required~
This does not apply to the compiler.
(car (1 as t (status features») is an impleme~tation name, such as
ITS or TOPS-IO or Multics. The main idea behind this status call is that
an application package can be loaded into any Mac1isp implementation and
can decide what to do on the basis of the features it finds available.

o

August 3, 1978

~3-1.8.1

Page 3-97

%M#TW¥%M

4

q

Mac1isp Reference Manual

feature

o

(status feature foo) is roughly equivalent to (memq 'foo (status
features) ), i.e. it determines whether this LISP has the foo-feature.Note
that foo is not evaluated.
(sstatus feature foo) makes foo a feature. foo is not evaluated. For
example, the trace package does" (sstatus feature trace) when it is
loaded.
Example:
(cond «status feature bignum)
(prog2 nil (eval (read» (read»)
(t (read) (eva1 (read» »

;use first
;use second

(defun factorial (n)
;bignum version
(cond «zerop n) 1)
«times n (factorial (subl n»»

»
(defun factorial (~)
;fixnum-only version
(do () «not (> n 13.») ;dountil n i 13.
(error "argument too big
factorial-

o

n
'wrng-type-arg»
(cond «zerop n) 1)
«* n (factorial (1- n»»

»

nofeature (sstatus nofeature foo) makes foo not be a feature.
evaluated.

foo is not

(status nofeature foo) is equivalant to (not (status feature

foo) ).
status

(status status foo) returns tif foo is a valid status function. If it is
not, nil is returned.
(status status) returns a list of valid status functions. The names
are truncated to some implementation-dependent number of characters, such
as 4 or 5.
.
,

ss tatus

(status sstatus foo ) returns t if foo is a valid sstatus function. If it
is not, n 11 is returned.

. Page 3-98

l3-1.B.l

-------------------~~-------

August S, 1978

o

The System

o

(status sstatus) returns a list of valid sstatus functions. As with
,( status status), the names are truncated to some implementationdependent number of characters, such as 4 or 5.

1.8.2

Time
SUBR no args

runtime

(runt ime) returns as a fixnum the number of microseconds of cpu time
used so far by the process in which LISP is running. The difference
between two values of (runt ime) indicates the amount of computation that
was done between the two ca11s to runt ime.

SUBR no args

time

(t ime) returns the time' in seconds that the system has been up, as a
Ronum. The difference between the results of two caUs to t 1me indicates the
amount of elapsed real time. (In the ITS implemen'tation, time that elapses
while the system is stopped due to memory errors is not considered "real"
and not counted. Use (status dayt ime) to measure true "real world"
time.)

SUBR 1 arg

sleep

(s 1eep n) causes a real-time delay of ,n seconds, then returns n. n may be
a fixnum or a ftonum.

See a Iso the a 1armc lock function, section 1;4.3, and the date, dayt ime, and dow
functions of the status special form, described in the preceding section.

1.8.3

Escaping from LISP

It is possible to escape temporarily from LISP to execute a command in the host
operating system. Of course, the program (or user) that supplies the command has to
know which operating system it is running ,under. It is also possible for LISP to return

o

August 3, 1978

l3-1.8.1

Page 3-99

&£1=_:ooS&44

., In ill,

,41

".', M#T4T#4 A¥M.#P

W;

4#

G

T-

Mac1isp Reference Manual

o

permanently to the host operating system. This discards the LISP environment and
gives back whatever·resources, such as memory, it was using.

in the Multics implementation
SUBR 1 arg

cl ine

(c 1 i ne x), where x is a character string, executes the Multics command x
and returns n i 1. Example:

(cline "who -long")

SUBR no args

. quit

(qu it) returns from the LISP command, freeing up the temporary segments
that were used to hold the LISP env·ironment.

in the ITS implementa.tion
lSUBR 0 or 1 args

valret

(va 1ret) does a .LOGOUT if LISP is a top level procedure,and otherwise
valrets ":VK " to DDT.

o

(valret x) effectively performs an exp10dec on x (in practice x is some
strange atomic symbol like I: PROCEED : DISOWN 1 , but it may be any Sexpression). If the string of characters is one of "SAX.", ":KILL ", or ":KILlAM"
then va 1ret performs a "si1e~t kill" by executing a .BREAK 16,20000; otherwise
valret performs a .V.ALUE, giving the character string to DDT to evaluate as
commands.
Examples:

(valret /I:PROCEED :DISOWN I)
starts the LISP running on its own without a terminal.

(valret /1 :KIlL :TECOAMI)
kilts the LISP and starts up a TEeO.

(valret /OINIP)
Page 3-100

l3-1.8.3

August 3, 1978

o

/
....

I

/

'/

o

The System

causes DDT to print out the contents of all non-zero locations in LISP and
then ·return to LISP.·
If the valret command leaves you in DDT (or anywhere other than the
LISP), a :CONTINUE or SP command to DDT will return to the LISP, .which
will then return from the call to va lret. However, va lret differs from suspend
in two ways: . it does not check for open files, and it does not alter the starting
address of the LISP. If you use valret to dump a subsystem, then starting up
the s':Jbsystem causes a return to top level and the consequent evaluation of the
top-level err 1 is t (not the binding of err 1 i st in effect at the time of the
va 1 ret!). Using suspend, the subsystem startup merely causes a return from the
suspend function.

in the 'rOPS-10 implementation
There is currently no way for LISP to return a command string to the
Monitor in the TOPS-JO implementation. However, (valret) will return control
to the monitor so that a command may be manually typed. Then type
CONTINUE to resume LISP.

o

The remarks above about valret and suspend hold for the TOPS-I0
implementation also.

1.8.4

Additional Functions
SUBR 1 arg

subr

.The argument, a fixnum, is taken to be the address of a location within a
compiled or system function. subr attempts to determine the name of the function
by groveling through the current obarray looking at all the compiled function
properties. If it fails it returns "?". This is used by baktrace. for example. This
function may be useful to user handlers for the machine-error interrupt, for
example.

o

August 3, 1978

~3-1.8.3

Page 3-101

o

Mac1isp Reference Manual

The following function exists only in the ITS implementation

lSUBR 2 to 10 args

sysca11

This function allows the LISP user to directly issue ITS symbolic system calls.
The first argument should be
(+ (i sh c 18.) n)
where n is the desired number of output values and cis the control bits for the
ca 11. The second argument should be an atomic symbol whose pname is the name
of the ITS system call. The rest o'f the arguments should be the input arguments .
for the call. An argument may be a fixnum, or a file object (for which the file's
channel number is used). If the call succeeds, a list of n fixnums is returned. If
an error occurs, the ITS error code is returned as a fixnum.
Example: (sysca 11 0 ' scm1 tyi 3)
sets the number of echo lines for the tty to 3 and
returns nil on success.

o

Page 3-102

l3-1.8.4

August 3, 1978

o

